; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\stm32f10x_flash.o --depend=.\Obj\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\usb_library\inc -I..\USB_test -I.\FWlib\inc -I.\user -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Obj\stm32f10x_flash.crf FWlib\SRC\stm32f10x_flash.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;124      */
;;;125    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4af2              LDR      r2,|L1.972|
;;;126    {
;;;127      uint32_t tmpreg = 0;
;;;128      
;;;129      /* Check the parameters */
;;;130      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;131      
;;;132      /* Read the ACR register */
;;;133      tmpreg = FLASH->ACR;  
000002  6811              LDR      r1,[r2,#0]
;;;134      
;;;135      /* Sets the Latency value */
;;;136      tmpreg &= ACR_LATENCY_Mask;
000004  f0010138          AND      r1,r1,#0x38
;;;137      tmpreg |= FLASH_Latency;
000008  4301              ORRS     r1,r1,r0
;;;138      
;;;139      /* Write the ACR register */
;;;140      FLASH->ACR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;141    }
00000c  4770              BX       lr
;;;142    
                          ENDP

                  FLASH_HalfCycleAccessCmd PROC
;;;150      */
;;;151    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
00000e  49ef              LDR      r1,|L1.972|
;;;152    {
;;;153      /* Check the parameters */
;;;154      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;155      
;;;156      /* Enable or disable the Half cycle access */
;;;157      FLASH->ACR &= ACR_HLFCYA_Mask;
000010  680a              LDR      r2,[r1,#0]
000012  f0220208          BIC      r2,r2,#8
000016  600a              STR      r2,[r1,#0]
;;;158      FLASH->ACR |= FLASH_HalfCycleAccess;
000018  680a              LDR      r2,[r1,#0]
00001a  4302              ORRS     r2,r2,r0
00001c  600a              STR      r2,[r1,#0]
;;;159    }
00001e  4770              BX       lr
;;;160    
                          ENDP

                  FLASH_PrefetchBufferCmd PROC
;;;168      */
;;;169    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000020  49ea              LDR      r1,|L1.972|
;;;170    {
;;;171      /* Check the parameters */
;;;172      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;173      
;;;174      /* Enable or disable the Prefetch Buffer */
;;;175      FLASH->ACR &= ACR_PRFTBE_Mask;
000022  680a              LDR      r2,[r1,#0]
000024  f0220210          BIC      r2,r2,#0x10
000028  600a              STR      r2,[r1,#0]
;;;176      FLASH->ACR |= FLASH_PrefetchBuffer;
00002a  680a              LDR      r2,[r1,#0]
00002c  4302              ORRS     r2,r2,r0
00002e  600a              STR      r2,[r1,#0]
;;;177    }
000030  4770              BX       lr
;;;178    
                          ENDP

                  FLASH_Unlock PROC
;;;183      */
;;;184    void FLASH_Unlock(void)
000032  48e6              LDR      r0,|L1.972|
;;;185    {
;;;186      /* Authorize the FPEC Access */
;;;187      FLASH->KEYR = FLASH_KEY1;
000034  49e6              LDR      r1,|L1.976|
000036  6041              STR      r1,[r0,#4]
;;;188      FLASH->KEYR = FLASH_KEY2;
000038  49e6              LDR      r1,|L1.980|
00003a  6041              STR      r1,[r0,#4]
;;;189    }
00003c  4770              BX       lr
;;;190    
                          ENDP

                  FLASH_Lock PROC
;;;195      */
;;;196    void FLASH_Lock(void)
00003e  48e3              LDR      r0,|L1.972|
;;;197    {
;;;198      /* Set the Lock Bit to lock the FPEC and the FCR */
;;;199      FLASH->CR |= CR_LOCK_Set;
000040  6901              LDR      r1,[r0,#0x10]
000042  f0410180          ORR      r1,r1,#0x80
000046  6101              STR      r1,[r0,#0x10]
;;;200    }
000048  4770              BX       lr
;;;201    
                          ENDP

                  FLASH_GetStatus PROC
;;;797      */
;;;798    FLASH_Status FLASH_GetStatus(void)
00004a  49e0              LDR      r1,|L1.972|
;;;799    {
;;;800      FLASH_Status flashstatus = FLASH_COMPLETE;
00004c  2004              MOVS     r0,#4
;;;801      
;;;802      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
00004e  68ca              LDR      r2,[r1,#0xc]
000050  07d2              LSLS     r2,r2,#31
000052  d001              BEQ      |L1.88|
;;;803      {
;;;804        flashstatus = FLASH_BUSY;
000054  2001              MOVS     r0,#1
;;;805      }
;;;806      else 
;;;807      {  
;;;808        if(FLASH->SR & FLASH_FLAG_PGERR)
;;;809        { 
;;;810          flashstatus = FLASH_ERROR_PG;
;;;811        }
;;;812        else 
;;;813        {
;;;814          if(FLASH->SR & FLASH_FLAG_WRPRTERR)
;;;815          {
;;;816            flashstatus = FLASH_ERROR_WRP;
;;;817          }
;;;818          else
;;;819          {
;;;820            flashstatus = FLASH_COMPLETE;
;;;821          }
;;;822        }
;;;823      }
;;;824      /* Return the Flash Status */
;;;825      return flashstatus;
;;;826    }
000056  4770              BX       lr
                  |L1.88|
000058  68ca              LDR      r2,[r1,#0xc]          ;808
00005a  0752              LSLS     r2,r2,#29             ;808
00005c  d501              BPL      |L1.98|
00005e  2002              MOVS     r0,#2                 ;810
                  |L1.96|
000060  4770              BX       lr
                  |L1.98|
000062  68c9              LDR      r1,[r1,#0xc]          ;814
000064  06c9              LSLS     r1,r1,#27             ;814
000066  d5fb              BPL      |L1.96|
000068  2003              MOVS     r0,#3                 ;816
00006a  4770              BX       lr
;;;827    
                          ENDP

                  FLASH_WaitForLastOperation PROC
;;;834      */
;;;835    FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
00006c  b500              PUSH     {lr}
;;;836    { 
00006e  4603              MOV      r3,r0
;;;837      FLASH_Status status = FLASH_COMPLETE;
;;;838       
;;;839      /* Check for the Flash Status */
;;;840      status = FLASH_GetStatus();
000070  f7fffffe          BL       FLASH_GetStatus
;;;841      /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;842      while((status == FLASH_BUSY) && (Timeout != 0x00))
000074  e005              B        |L1.130|
                  |L1.118|
000076  20ff              MOVS     r0,#0xff
                  |L1.120|
000078  1e40              SUBS     r0,r0,#1
00007a  d1fd              BNE      |L1.120|
;;;843      {
;;;844        delay();
;;;845        status = FLASH_GetStatus();
00007c  f7fffffe          BL       FLASH_GetStatus
;;;846        Timeout--;
000080  1e5b              SUBS     r3,r3,#1
                  |L1.130|
000082  2801              CMP      r0,#1                 ;842
000084  d003              BEQ      |L1.142|
;;;847      }
;;;848      if(Timeout == 0x00 )
000086  2b00              CMP      r3,#0
000088  d100              BNE      |L1.140|
                  |L1.138|
;;;849      {
;;;850        status = FLASH_TIMEOUT;
00008a  2005              MOVS     r0,#5
                  |L1.140|
;;;851      }
;;;852      /* Return the operation status */
;;;853      return status;
;;;854    }
00008c  bd00              POP      {pc}
                  |L1.142|
00008e  2b00              CMP      r3,#0                 ;842
000090  d1f1              BNE      |L1.118|
000092  e7fa              B        |L1.138|
;;;855    
                          ENDP

                  FLASH_ErasePage PROC
;;;208      */
;;;209    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000094  b570              PUSH     {r4-r6,lr}
;;;210    {
000096  4605              MOV      r5,r0
;;;211      FLASH_Status status = FLASH_COMPLETE;
;;;212      /* Check the parameters */
;;;213      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;214      /* Wait for last operation to be completed */
;;;215      status = FLASH_WaitForLastOperation(EraseTimeout);
000098  f64076ff          MOV      r6,#0xfff
00009c  4630              MOV      r0,r6
00009e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;216      
;;;217      if(status == FLASH_COMPLETE)
0000a2  2804              CMP      r0,#4
0000a4  d113              BNE      |L1.206|
;;;218      { 
;;;219        /* if the previous operation is completed, proceed to erase the page */
;;;220        FLASH->CR|= CR_PER_Set;
0000a6  4cc9              LDR      r4,|L1.972|
0000a8  6920              LDR      r0,[r4,#0x10]
0000aa  f0400002          ORR      r0,r0,#2
0000ae  6120              STR      r0,[r4,#0x10]
;;;221        FLASH->AR = Page_Address; 
0000b0  6165              STR      r5,[r4,#0x14]
;;;222        FLASH->CR|= CR_STRT_Set;
0000b2  6920              LDR      r0,[r4,#0x10]
0000b4  f0400040          ORR      r0,r0,#0x40
0000b8  6120              STR      r0,[r4,#0x10]
;;;223        
;;;224        /* Wait for last operation to be completed */
;;;225        status = FLASH_WaitForLastOperation(EraseTimeout);
0000ba  4630              MOV      r0,r6
0000bc  f7fffffe          BL       FLASH_WaitForLastOperation
;;;226        if(status != FLASH_BUSY)
0000c0  2801              CMP      r0,#1
0000c2  d004              BEQ      |L1.206|
;;;227        {
;;;228          /* if the erase operation is completed, disable the PER Bit */
;;;229          FLASH->CR &= CR_PER_Reset;
0000c4  6921              LDR      r1,[r4,#0x10]
0000c6  f64172fd          MOV      r2,#0x1ffd
0000ca  4011              ANDS     r1,r1,r2
0000cc  6121              STR      r1,[r4,#0x10]
                  |L1.206|
;;;230        }
;;;231      }
;;;232      /* Return the Erase Status */
;;;233      return status;
;;;234    }
0000ce  bd70              POP      {r4-r6,pc}
;;;235    
                          ENDP

                  FLASH_EraseAllPages PROC
;;;242      */
;;;243    FLASH_Status FLASH_EraseAllPages(void)
0000d0  b530              PUSH     {r4,r5,lr}
;;;244    {
;;;245      FLASH_Status status = FLASH_COMPLETE;
;;;246      /* Wait for last operation to be completed */
;;;247      status = FLASH_WaitForLastOperation(EraseTimeout);
0000d2  f64075ff          MOV      r5,#0xfff
0000d6  4628              MOV      r0,r5
0000d8  f7fffffe          BL       FLASH_WaitForLastOperation
;;;248      
;;;249      if(status == FLASH_COMPLETE)
0000dc  2804              CMP      r0,#4
0000de  d112              BNE      |L1.262|
;;;250      {
;;;251        /* if the previous operation is completed, proceed to erase all pages */
;;;252         FLASH->CR |= CR_MER_Set;
0000e0  4cba              LDR      r4,|L1.972|
0000e2  6920              LDR      r0,[r4,#0x10]
0000e4  f0400004          ORR      r0,r0,#4
0000e8  6120              STR      r0,[r4,#0x10]
;;;253         FLASH->CR |= CR_STRT_Set;
0000ea  6920              LDR      r0,[r4,#0x10]
0000ec  f0400040          ORR      r0,r0,#0x40
0000f0  6120              STR      r0,[r4,#0x10]
;;;254        
;;;255        /* Wait for last operation to be completed */
;;;256        status = FLASH_WaitForLastOperation(EraseTimeout);
0000f2  4628              MOV      r0,r5
0000f4  f7fffffe          BL       FLASH_WaitForLastOperation
;;;257        if(status != FLASH_BUSY)
0000f8  2801              CMP      r0,#1
0000fa  d004              BEQ      |L1.262|
;;;258        {
;;;259          /* if the erase operation is completed, disable the MER Bit */
;;;260          FLASH->CR &= CR_MER_Reset;
0000fc  6921              LDR      r1,[r4,#0x10]
0000fe  f64172fb          MOV      r2,#0x1ffb
000102  4011              ANDS     r1,r1,r2
000104  6121              STR      r1,[r4,#0x10]
                  |L1.262|
;;;261        }
;;;262      }	   
;;;263      /* Return the Erase Status */
;;;264      return status;
;;;265    }
000106  bd30              POP      {r4,r5,pc}
;;;266    
                          ENDP

                  FLASH_EraseOptionBytes PROC
;;;273      */
;;;274    FLASH_Status FLASH_EraseOptionBytes(void)
000108  b530              PUSH     {r4,r5,lr}
;;;275    {
;;;276      FLASH_Status status = FLASH_COMPLETE;
;;;277      
;;;278      /* Wait for last operation to be completed */
;;;279      status = FLASH_WaitForLastOperation(EraseTimeout);
00010a  f64075ff          MOV      r5,#0xfff
00010e  4628              MOV      r0,r5
000110  f7fffffe          BL       FLASH_WaitForLastOperation
;;;280      if(status == FLASH_COMPLETE)
000114  2804              CMP      r0,#4
000116  d128              BNE      |L1.362|
;;;281      {
;;;282        /* Authorize the small information block programming */
;;;283        FLASH->OPTKEYR = FLASH_KEY1;
000118  4cac              LDR      r4,|L1.972|
00011a  48ad              LDR      r0,|L1.976|
00011c  60a0              STR      r0,[r4,#8]
;;;284        FLASH->OPTKEYR = FLASH_KEY2;
00011e  48ad              LDR      r0,|L1.980|
000120  60a0              STR      r0,[r4,#8]
;;;285        
;;;286        /* if the previous operation is completed, proceed to erase the option bytes */
;;;287        FLASH->CR |= CR_OPTER_Set;
000122  6920              LDR      r0,[r4,#0x10]
000124  f0400020          ORR      r0,r0,#0x20
000128  6120              STR      r0,[r4,#0x10]
;;;288        FLASH->CR |= CR_STRT_Set;
00012a  6920              LDR      r0,[r4,#0x10]
00012c  f0400040          ORR      r0,r0,#0x40
000130  6120              STR      r0,[r4,#0x10]
;;;289        /* Wait for last operation to be completed */
;;;290        status = FLASH_WaitForLastOperation(EraseTimeout);
000132  4628              MOV      r0,r5
000134  f7fffffe          BL       FLASH_WaitForLastOperation
;;;291        
;;;292        if(status == FLASH_COMPLETE)
;;;293        {
;;;294          /* if the erase operation is completed, disable the OPTER Bit */
;;;295          FLASH->CR &= CR_OPTER_Reset;
;;;296           
;;;297          /* Enable the Option Bytes Programming operation */
;;;298          FLASH->CR |= CR_OPTPG_Set;
;;;299          /* Enable the readout access */
;;;300          OB->RDP= RDP_Key; 
;;;301          /* Wait for last operation to be completed */
;;;302          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;303     
;;;304          if(status != FLASH_BUSY)
;;;305          {
;;;306            /* if the program operation is completed, disable the OPTPG Bit */
;;;307            FLASH->CR &= CR_OPTPG_Reset;
000138  f64175ef          MOV      r5,#0x1fef
00013c  2804              CMP      r0,#4                 ;292
00013e  d10f              BNE      |L1.352|
000140  6920              LDR      r0,[r4,#0x10]         ;295
000142  f64171df          MOV      r1,#0x1fdf            ;295
000146  4008              ANDS     r0,r0,r1              ;295
000148  6120              STR      r0,[r4,#0x10]         ;295
00014a  6920              LDR      r0,[r4,#0x10]         ;298
00014c  f0400010          ORR      r0,r0,#0x10           ;298
000150  6120              STR      r0,[r4,#0x10]         ;298
000152  49a1              LDR      r1,|L1.984|
000154  20a5              MOVS     r0,#0xa5              ;300
000156  8008              STRH     r0,[r1,#0]            ;300
000158  f04f000f          MOV      r0,#0xf               ;302
00015c  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L1.352|
;;;308          }
;;;309        }
;;;310        else
;;;311        {
;;;312          if (status != FLASH_BUSY)
000160  2801              CMP      r0,#1
000162  d002              BEQ      |L1.362|
000164  6921              LDR      r1,[r4,#0x10]         ;307
000166  4029              ANDS     r1,r1,r5              ;307
000168  6121              STR      r1,[r4,#0x10]         ;307
                  |L1.362|
;;;313          {
;;;314            /* Disable the OPTPG Bit */
;;;315            FLASH->CR &= CR_OPTPG_Reset;
;;;316          }
;;;317        }  
;;;318      }
;;;319      /* Return the erase status */
;;;320      return status;
;;;321    }
00016a  bd30              POP      {r4,r5,pc}
;;;322    
                          ENDP

                  FLASH_ProgramWord PROC
;;;330      */
;;;331    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
00016c  b5f0              PUSH     {r4-r7,lr}
;;;332    {
00016e  4606              MOV      r6,r0
000170  460d              MOV      r5,r1
;;;333      FLASH_Status status = FLASH_COMPLETE;
;;;334      /* Check the parameters */
;;;335      assert_param(IS_FLASH_ADDRESS(Address));
;;;336      /* Wait for last operation to be completed */
;;;337      status = FLASH_WaitForLastOperation(ProgramTimeout);
000172  200f              MOVS     r0,#0xf
000174  f7fffffe          BL       FLASH_WaitForLastOperation
;;;338      
;;;339      if(status == FLASH_COMPLETE)
000178  2804              CMP      r0,#4
00017a  d116              BNE      |L1.426|
;;;340      {
;;;341        /* if the previous operation is completed, proceed to program the new first 
;;;342        half word */
;;;343        FLASH->CR |= CR_PG_Set;
00017c  4c93              LDR      r4,|L1.972|
00017e  6920              LDR      r0,[r4,#0x10]
000180  f0400001          ORR      r0,r0,#1
000184  6120              STR      r0,[r4,#0x10]
;;;344      
;;;345        *(__IO uint16_t*)Address = (uint16_t)Data;
000186  8035              STRH     r5,[r6,#0]
;;;346        /* Wait for last operation to be completed */
;;;347        status = FLASH_WaitForLastOperation(ProgramTimeout);
000188  200f              MOVS     r0,#0xf
00018a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;348     
;;;349        if(status == FLASH_COMPLETE)
;;;350        {
;;;351          /* if the previous operation is completed, proceed to program the new second 
;;;352          half word */
;;;353          *(__IO uint16_t*)(Address + 2) = Data >> 16;
;;;354        
;;;355          /* Wait for last operation to be completed */
;;;356          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;357            
;;;358          if(status != FLASH_BUSY)
;;;359          {
;;;360            /* Disable the PG Bit */
;;;361            FLASH->CR &= CR_PG_Reset;
00018e  f64177fe          MOV      r7,#0x1ffe
000192  2804              CMP      r0,#4                 ;349
000194  d104              BNE      |L1.416|
000196  0c28              LSRS     r0,r5,#16             ;353
000198  8070              STRH     r0,[r6,#2]            ;353
00019a  200f              MOVS     r0,#0xf               ;356
00019c  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L1.416|
;;;362          }
;;;363        }
;;;364        else
;;;365        {
;;;366          if (status != FLASH_BUSY)
0001a0  2801              CMP      r0,#1
0001a2  d002              BEQ      |L1.426|
0001a4  6921              LDR      r1,[r4,#0x10]         ;361
0001a6  4039              ANDS     r1,r1,r7              ;361
0001a8  6121              STR      r1,[r4,#0x10]         ;361
                  |L1.426|
;;;367          {
;;;368            /* Disable the PG Bit */
;;;369            FLASH->CR &= CR_PG_Reset;
;;;370          }
;;;371         }
;;;372      }
;;;373      /* Return the Program Status */
;;;374      return status;
;;;375    }
0001aa  bdf0              POP      {r4-r7,pc}
;;;376    
                          ENDP

                  FLASH_ProgramHalfWord PROC
;;;384      */
;;;385    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
0001ac  b570              PUSH     {r4-r6,lr}
;;;386    {
0001ae  4605              MOV      r5,r0
0001b0  460e              MOV      r6,r1
;;;387      FLASH_Status status = FLASH_COMPLETE;
;;;388      /* Check the parameters */
;;;389      assert_param(IS_FLASH_ADDRESS(Address));
;;;390      /* Wait for last operation to be completed */
;;;391      status = FLASH_WaitForLastOperation(ProgramTimeout);
0001b2  200f              MOVS     r0,#0xf
0001b4  f7fffffe          BL       FLASH_WaitForLastOperation
;;;392      
;;;393      if(status == FLASH_COMPLETE)
0001b8  2804              CMP      r0,#4
0001ba  d10f              BNE      |L1.476|
;;;394      {
;;;395        /* if the previous operation is completed, proceed to program the new data */
;;;396        FLASH->CR |= CR_PG_Set;
0001bc  4c83              LDR      r4,|L1.972|
0001be  6920              LDR      r0,[r4,#0x10]
0001c0  f0400001          ORR      r0,r0,#1
0001c4  6120              STR      r0,[r4,#0x10]
;;;397      
;;;398        *(__IO uint16_t*)Address = Data;
0001c6  802e              STRH     r6,[r5,#0]
;;;399        /* Wait for last operation to be completed */
;;;400        status = FLASH_WaitForLastOperation(ProgramTimeout);
0001c8  200f              MOVS     r0,#0xf
0001ca  f7fffffe          BL       FLASH_WaitForLastOperation
;;;401        if(status != FLASH_BUSY)
0001ce  2801              CMP      r0,#1
0001d0  d004              BEQ      |L1.476|
;;;402        {
;;;403          /* if the program operation is completed, disable the PG Bit */
;;;404          FLASH->CR &= CR_PG_Reset;
0001d2  6921              LDR      r1,[r4,#0x10]
0001d4  f64172fe          MOV      r2,#0x1ffe
0001d8  4011              ANDS     r1,r1,r2
0001da  6121              STR      r1,[r4,#0x10]
                  |L1.476|
;;;405        }
;;;406      } 
;;;407      /* Return the Program Status */
;;;408      return status;
;;;409    }
0001dc  bd70              POP      {r4-r6,pc}
;;;410    
                          ENDP

                  FLASH_ProgramOptionByteData PROC
;;;419      */
;;;420    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
0001de  b570              PUSH     {r4-r6,lr}
;;;421    {
0001e0  4605              MOV      r5,r0
0001e2  460e              MOV      r6,r1
;;;422      FLASH_Status status = FLASH_COMPLETE;
;;;423      /* Check the parameters */
;;;424      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;425      status = FLASH_WaitForLastOperation(ProgramTimeout);
0001e4  200f              MOVS     r0,#0xf
0001e6  f7fffffe          BL       FLASH_WaitForLastOperation
;;;426      if(status == FLASH_COMPLETE)
0001ea  2804              CMP      r0,#4
0001ec  d113              BNE      |L1.534|
;;;427      {
;;;428        /* Authorize the small information block programming */
;;;429        FLASH->OPTKEYR = FLASH_KEY1;
0001ee  4c77              LDR      r4,|L1.972|
0001f0  4877              LDR      r0,|L1.976|
0001f2  60a0              STR      r0,[r4,#8]
;;;430        FLASH->OPTKEYR = FLASH_KEY2;
0001f4  4877              LDR      r0,|L1.980|
0001f6  60a0              STR      r0,[r4,#8]
;;;431        /* Enables the Option Bytes Programming operation */
;;;432        FLASH->CR |= CR_OPTPG_Set; 
0001f8  6920              LDR      r0,[r4,#0x10]
0001fa  f0400010          ORR      r0,r0,#0x10
0001fe  6120              STR      r0,[r4,#0x10]
;;;433        *(__IO uint16_t*)Address = Data;
000200  802e              STRH     r6,[r5,#0]
;;;434        
;;;435        /* Wait for last operation to be completed */
;;;436        status = FLASH_WaitForLastOperation(ProgramTimeout);
000202  200f              MOVS     r0,#0xf
000204  f7fffffe          BL       FLASH_WaitForLastOperation
;;;437        if(status != FLASH_BUSY)
000208  2801              CMP      r0,#1
00020a  d004              BEQ      |L1.534|
;;;438        {
;;;439          /* if the program operation is completed, disable the OPTPG Bit */
;;;440          FLASH->CR &= CR_OPTPG_Reset;
00020c  6921              LDR      r1,[r4,#0x10]
00020e  f64172ef          MOV      r2,#0x1fef
000212  4011              ANDS     r1,r1,r2
000214  6121              STR      r1,[r4,#0x10]
                  |L1.534|
;;;441        }
;;;442      }    
;;;443      /* Return the Option Byte Data Program Status */
;;;444      return status;
;;;445    }
000216  bd70              POP      {r4-r6,pc}
;;;446    
                          ENDP

                  FLASH_EnableWriteProtection PROC
;;;460      */
;;;461    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
000218  e92d41f0          PUSH     {r4-r8,lr}
;;;462    {
;;;463      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
;;;464      
;;;465      FLASH_Status status = FLASH_COMPLETE;
;;;466      
;;;467      /* Check the parameters */
;;;468      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;469      
;;;470      FLASH_Pages = (uint32_t)(~FLASH_Pages);
00021c  43c0              MVNS     r0,r0
;;;471      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
00021e  b2c4              UXTB     r4,r0
;;;472      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
000220  f3c02507          UBFX     r5,r0,#8,#8
;;;473      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
000224  f3c04607          UBFX     r6,r0,#16,#8
;;;474      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
000228  0e07              LSRS     r7,r0,#24
;;;475      
;;;476      /* Wait for last operation to be completed */
;;;477      status = FLASH_WaitForLastOperation(ProgramTimeout);
00022a  200f              MOVS     r0,#0xf
00022c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;478      
;;;479      if(status == FLASH_COMPLETE)
000230  2804              CMP      r0,#4
000232  d13a              BNE      |L1.682|
;;;480      {
;;;481        /* Authorizes the small information block programming */
;;;482        FLASH->OPTKEYR = FLASH_KEY1;
000234  f8dfc194          LDR      r12,|L1.972|
000238  4965              LDR      r1,|L1.976|
00023a  f8cc1008          STR      r1,[r12,#8]
;;;483        FLASH->OPTKEYR = FLASH_KEY2;
00023e  4965              LDR      r1,|L1.980|
000240  f8cc1008          STR      r1,[r12,#8]
;;;484        FLASH->CR |= CR_OPTPG_Set;
000244  f8dc1010          LDR      r1,[r12,#0x10]
;;;485        if(WRP0_Data != 0xFF)
;;;486        {
;;;487          OB->WRP0 = WRP0_Data;
000248  f8df8190          LDR      r8,|L1.988|
00024c  f0410110          ORR      r1,r1,#0x10           ;484
000250  f8cc1010          STR      r1,[r12,#0x10]        ;484
000254  2cff              CMP      r4,#0xff              ;485
000256  d006              BEQ      |L1.614|
000258  f8a84808          STRH     r4,[r8,#0x808]
;;;488          
;;;489          /* Wait for last operation to be completed */
;;;490          status = FLASH_WaitForLastOperation(ProgramTimeout);
00025c  200f              MOVS     r0,#0xf
00025e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;491        }
;;;492        if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
000262  2804              CMP      r0,#4
000264  d118              BNE      |L1.664|
                  |L1.614|
000266  2dff              CMP      r5,#0xff
000268  d006              BEQ      |L1.632|
;;;493        {
;;;494          OB->WRP1 = WRP1_Data;
00026a  f8a8580a          STRH     r5,[r8,#0x80a]
;;;495          
;;;496          /* Wait for last operation to be completed */
;;;497          status = FLASH_WaitForLastOperation(ProgramTimeout);
00026e  200f              MOVS     r0,#0xf
000270  f7fffffe          BL       FLASH_WaitForLastOperation
;;;498        }
;;;499        if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
000274  2804              CMP      r0,#4
000276  d10f              BNE      |L1.664|
                  |L1.632|
000278  2eff              CMP      r6,#0xff
00027a  d006              BEQ      |L1.650|
;;;500        {
;;;501          OB->WRP2 = WRP2_Data;
00027c  f8a8680c          STRH     r6,[r8,#0x80c]
;;;502          
;;;503          /* Wait for last operation to be completed */
;;;504          status = FLASH_WaitForLastOperation(ProgramTimeout);
000280  200f              MOVS     r0,#0xf
000282  f7fffffe          BL       FLASH_WaitForLastOperation
;;;505        }
;;;506        
;;;507        if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000286  2804              CMP      r0,#4
000288  d106              BNE      |L1.664|
                  |L1.650|
00028a  2fff              CMP      r7,#0xff
00028c  d006              BEQ      |L1.668|
;;;508        {
;;;509          OB->WRP3 = WRP3_Data;
00028e  f8a8780e          STRH     r7,[r8,#0x80e]
;;;510         
;;;511          /* Wait for last operation to be completed */
;;;512          status = FLASH_WaitForLastOperation(ProgramTimeout);
000292  200f              MOVS     r0,#0xf
000294  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L1.664|
;;;513        }
;;;514              
;;;515        if(status != FLASH_BUSY)
000298  2801              CMP      r0,#1
00029a  d006              BEQ      |L1.682|
                  |L1.668|
;;;516        {
;;;517          /* if the program operation is completed, disable the OPTPG Bit */
;;;518          FLASH->CR &= CR_OPTPG_Reset;
00029c  f8dc1010          LDR      r1,[r12,#0x10]
0002a0  f64172ef          MOV      r2,#0x1fef
0002a4  4011              ANDS     r1,r1,r2
0002a6  f8cc1010          STR      r1,[r12,#0x10]
                  |L1.682|
;;;519        }
;;;520      } 
;;;521      /* Return the write protection operation Status */
;;;522      return status;       
;;;523    }
0002aa  e8bd81f0          POP      {r4-r8,pc}
;;;524    
                          ENDP

                  FLASH_ReadOutProtection PROC
;;;535      */
;;;536    FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
0002ae  b570              PUSH     {r4-r6,lr}
;;;537    {
0002b0  4606              MOV      r6,r0
;;;538      FLASH_Status status = FLASH_COMPLETE;
;;;539      /* Check the parameters */
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      status = FLASH_WaitForLastOperation(EraseTimeout);
0002b2  f64075ff          MOV      r5,#0xfff
0002b6  4628              MOV      r0,r5
0002b8  f7fffffe          BL       FLASH_WaitForLastOperation
;;;542      if(status == FLASH_COMPLETE)
0002bc  2804              CMP      r0,#4
0002be  d118              BNE      |L1.754|
;;;543      {
;;;544        /* Authorizes the small information block programming */
;;;545        FLASH->OPTKEYR = FLASH_KEY1;
0002c0  4c42              LDR      r4,|L1.972|
0002c2  4843              LDR      r0,|L1.976|
0002c4  60a0              STR      r0,[r4,#8]
;;;546        FLASH->OPTKEYR = FLASH_KEY2;
0002c6  4843              LDR      r0,|L1.980|
0002c8  60a0              STR      r0,[r4,#8]
;;;547        FLASH->CR |= CR_OPTER_Set;
0002ca  6920              LDR      r0,[r4,#0x10]
0002cc  f0400020          ORR      r0,r0,#0x20
0002d0  6120              STR      r0,[r4,#0x10]
;;;548        FLASH->CR |= CR_STRT_Set;
0002d2  6920              LDR      r0,[r4,#0x10]
0002d4  f0400040          ORR      r0,r0,#0x40
0002d8  6120              STR      r0,[r4,#0x10]
;;;549        /* Wait for last operation to be completed */
;;;550        status = FLASH_WaitForLastOperation(EraseTimeout);
0002da  4628              MOV      r0,r5
0002dc  f7fffffe          BL       FLASH_WaitForLastOperation
;;;551        if(status == FLASH_COMPLETE)
;;;552        {
;;;553          /* if the erase operation is completed, disable the OPTER Bit */
;;;554          FLASH->CR &= CR_OPTER_Reset;
0002e0  f64171df          MOV      r1,#0x1fdf
0002e4  2804              CMP      r0,#4                 ;551
0002e6  d005              BEQ      |L1.756|
;;;555          /* Enable the Option Bytes Programming operation */
;;;556          FLASH->CR |= CR_OPTPG_Set; 
;;;557          if(NewState != DISABLE)
;;;558          {
;;;559            OB->RDP = 0x00;
;;;560          }
;;;561          else
;;;562          {
;;;563            OB->RDP = RDP_Key;  
;;;564          }
;;;565          /* Wait for last operation to be completed */
;;;566          status = FLASH_WaitForLastOperation(EraseTimeout); 
;;;567        
;;;568          if(status != FLASH_BUSY)
;;;569          {
;;;570            /* if the program operation is completed, disable the OPTPG Bit */
;;;571            FLASH->CR &= CR_OPTPG_Reset;
;;;572          }
;;;573        }
;;;574        else 
;;;575        {
;;;576          if(status != FLASH_BUSY)
0002e8  2801              CMP      r0,#1
0002ea  d002              BEQ      |L1.754|
;;;577          {
;;;578            /* Disable the OPTER Bit */
;;;579            FLASH->CR &= CR_OPTER_Reset;
0002ec  6922              LDR      r2,[r4,#0x10]
0002ee  400a              ANDS     r2,r2,r1
0002f0  6122              STR      r2,[r4,#0x10]
                  |L1.754|
;;;580          }
;;;581        }
;;;582      }
;;;583      /* Return the protection operation Status */
;;;584      return status;      
;;;585    }
0002f2  bd70              POP      {r4-r6,pc}
                  |L1.756|
0002f4  6920              LDR      r0,[r4,#0x10]         ;554
0002f6  4008              ANDS     r0,r0,r1              ;554
0002f8  6120              STR      r0,[r4,#0x10]         ;554
0002fa  6921              LDR      r1,[r4,#0x10]         ;556
0002fc  4837              LDR      r0,|L1.988|
0002fe  f0410110          ORR      r1,r1,#0x10           ;556
000302  6121              STR      r1,[r4,#0x10]         ;556
000304  b10e              CBZ      r6,|L1.778|
000306  2100              MOVS     r1,#0                 ;559
000308  e000              B        |L1.780|
                  |L1.778|
00030a  21a5              MOVS     r1,#0xa5              ;563
                  |L1.780|
00030c  f8a01800          STRH     r1,[r0,#0x800]        ;563
000310  4628              MOV      r0,r5                 ;566
000312  f7fffffe          BL       FLASH_WaitForLastOperation
000316  2801              CMP      r0,#1                 ;568
000318  d0eb              BEQ      |L1.754|
00031a  6921              LDR      r1,[r4,#0x10]         ;571
00031c  f64172ef          MOV      r2,#0x1fef            ;571
000320  4011              ANDS     r1,r1,r2              ;571
000322  6121              STR      r1,[r4,#0x10]         ;571
000324  bd70              POP      {r4-r6,pc}
;;;586    
                          ENDP

                  FLASH_UserOptionByteConfig PROC
;;;605      */
;;;606    FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000326  b5f0              PUSH     {r4-r7,lr}
;;;607    {
;;;608      FLASH_Status status = FLASH_COMPLETE; 
;;;609      /* Check the parameters */
;;;610      assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;611      assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;612      assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;613      /* Authorize the small information block programming */
;;;614      FLASH->OPTKEYR = FLASH_KEY1;
000328  4c28              LDR      r4,|L1.972|
00032a  4605              MOV      r5,r0                 ;607
00032c  4828              LDR      r0,|L1.976|
00032e  460e              MOV      r6,r1                 ;607
000330  4617              MOV      r7,r2                 ;607
000332  60a0              STR      r0,[r4,#8]
;;;615      FLASH->OPTKEYR = FLASH_KEY2;
000334  4827              LDR      r0,|L1.980|
000336  60a0              STR      r0,[r4,#8]
;;;616      
;;;617      /* Wait for last operation to be completed */
;;;618      status = FLASH_WaitForLastOperation(ProgramTimeout);
000338  200f              MOVS     r0,#0xf
00033a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;619      
;;;620      if(status == FLASH_COMPLETE)
00033e  2804              CMP      r0,#4
000340  d114              BNE      |L1.876|
;;;621      {  
;;;622        /* Enable the Option Bytes Programming operation */
;;;623        FLASH->CR |= CR_OPTPG_Set; 
000342  6920              LDR      r0,[r4,#0x10]
000344  f0400010          ORR      r0,r0,#0x10
000348  6120              STR      r0,[r4,#0x10]
;;;624               
;;;625        OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (uint16_t)0xF8; 
00034a  4335              ORRS     r5,r5,r6
00034c  4924              LDR      r1,|L1.992|
00034e  433d              ORRS     r5,r5,r7
000350  f04500f8          ORR      r0,r5,#0xf8
000354  8008              STRH     r0,[r1,#0]
;;;626      
;;;627        /* Wait for last operation to be completed */
;;;628        status = FLASH_WaitForLastOperation(ProgramTimeout);
000356  f04f000f          MOV      r0,#0xf
00035a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;629        if(status != FLASH_BUSY)
00035e  2801              CMP      r0,#1
000360  d004              BEQ      |L1.876|
;;;630        {
;;;631          /* if the program operation is completed, disable the OPTPG Bit */
;;;632          FLASH->CR &= CR_OPTPG_Reset;
000362  6921              LDR      r1,[r4,#0x10]
000364  f64172ef          MOV      r2,#0x1fef
000368  4011              ANDS     r1,r1,r2
00036a  6121              STR      r1,[r4,#0x10]
                  |L1.876|
;;;633        }
;;;634      }    
;;;635      /* Return the Option Byte program Status */
;;;636      return status;
;;;637    }
00036c  bdf0              POP      {r4-r7,pc}
;;;638    
                          ENDP

                  FLASH_GetUserOptionByte PROC
;;;644      */
;;;645    uint32_t FLASH_GetUserOptionByte(void)
00036e  4817              LDR      r0,|L1.972|
;;;646    {
;;;647      /* Return the User Option Byte */
;;;648      return (uint32_t)(FLASH->OBR >> 2);
000370  69c0              LDR      r0,[r0,#0x1c]
000372  0880              LSRS     r0,r0,#2
;;;649    }
000374  4770              BX       lr
;;;650    
                          ENDP

                  FLASH_GetWriteProtectionOptionByte PROC
;;;655      */
;;;656    uint32_t FLASH_GetWriteProtectionOptionByte(void)
000376  4815              LDR      r0,|L1.972|
;;;657    {
;;;658      /* Return the Falsh write protection Register value */
;;;659      return (uint32_t)(FLASH->WRPR);
000378  6a00              LDR      r0,[r0,#0x20]
;;;660    }
00037a  4770              BX       lr
;;;661    
                          ENDP

                  FLASH_GetReadOutProtectionStatus PROC
;;;667      */
;;;668    FlagStatus FLASH_GetReadOutProtectionStatus(void)
00037c  4913              LDR      r1,|L1.972|
;;;669    {
;;;670      FlagStatus readoutstatus = RESET;
00037e  2000              MOVS     r0,#0
;;;671      if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
000380  69c9              LDR      r1,[r1,#0x1c]
000382  0789              LSLS     r1,r1,#30
000384  d500              BPL      |L1.904|
;;;672      {
;;;673        readoutstatus = SET;
000386  2001              MOVS     r0,#1
                  |L1.904|
;;;674      }
;;;675      else
;;;676      {
;;;677        readoutstatus = RESET;
;;;678      }
;;;679      return readoutstatus;
;;;680    }
000388  4770              BX       lr
;;;681    
                          ENDP

                  FLASH_GetPrefetchBufferStatus PROC
;;;686      */
;;;687    FlagStatus FLASH_GetPrefetchBufferStatus(void)
00038a  4910              LDR      r1,|L1.972|
;;;688    {
;;;689      FlagStatus bitstatus = RESET;
00038c  2000              MOVS     r0,#0
;;;690      
;;;691      if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
00038e  6809              LDR      r1,[r1,#0]
000390  0689              LSLS     r1,r1,#26
000392  d500              BPL      |L1.918|
;;;692      {
;;;693        bitstatus = SET;
000394  2001              MOVS     r0,#1
                  |L1.918|
;;;694      }
;;;695      else
;;;696      {
;;;697        bitstatus = RESET;
;;;698      }
;;;699      /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;700      return bitstatus; 
;;;701    }
000396  4770              BX       lr
;;;702    
                          ENDP

                  FLASH_ITConfig PROC
;;;713      */
;;;714    void FLASH_ITConfig(uint16_t FLASH_IT, FunctionalState NewState)
000398  4a0c              LDR      r2,|L1.972|
;;;715    {
;;;716      /* Check the parameters */
;;;717      assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;718      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;719      if(NewState != DISABLE)
00039a  2900              CMP      r1,#0
;;;720      {
;;;721        /* Enable the interrupt sources */
;;;722        FLASH->CR |= FLASH_IT;
;;;723      }
;;;724      else
;;;725      {
;;;726        /* Disable the interrupt sources */
;;;727        FLASH->CR &= ~(uint32_t)FLASH_IT;
00039c  6911              LDR      r1,[r2,#0x10]
00039e  d001              BEQ      |L1.932|
0003a0  4301              ORRS     r1,r1,r0              ;722
0003a2  e000              B        |L1.934|
                  |L1.932|
0003a4  4381              BICS     r1,r1,r0
                  |L1.934|
0003a6  6111              STR      r1,[r2,#0x10]         ;722
;;;728      }
;;;729    }
0003a8  4770              BX       lr
;;;730    
                          ENDP

                  FLASH_GetFlagStatus PROC
;;;741      */
;;;742    FlagStatus FLASH_GetFlagStatus(uint16_t FLASH_FLAG)
0003aa  4601              MOV      r1,r0
;;;743    {
;;;744      FlagStatus bitstatus = RESET;
0003ac  2000              MOVS     r0,#0
;;;745      /* Check the parameters */
;;;746      assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;747      if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
;;;748      {
;;;749        if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
0003ae  4a07              LDR      r2,|L1.972|
0003b0  2901              CMP      r1,#1                 ;747
0003b2  d003              BEQ      |L1.956|
;;;750        {
;;;751          bitstatus = SET;
;;;752        }
;;;753        else
;;;754        {
;;;755          bitstatus = RESET;
;;;756        }
;;;757      }
;;;758      else
;;;759      {
;;;760       if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
0003b4  68d2              LDR      r2,[r2,#0xc]
0003b6  420a              TST      r2,r1
0003b8  d103              BNE      |L1.962|
                  |L1.954|
;;;761        {
;;;762          bitstatus = SET;
;;;763        }
;;;764        else
;;;765        {
;;;766          bitstatus = RESET;
;;;767        }
;;;768      }
;;;769      /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;770      return bitstatus;
;;;771    }
0003ba  4770              BX       lr
                  |L1.956|
0003bc  69d1              LDR      r1,[r2,#0x1c]         ;749
0003be  07c9              LSLS     r1,r1,#31             ;749
0003c0  d0fb              BEQ      |L1.954|
                  |L1.962|
0003c2  2001              MOVS     r0,#1                 ;751
0003c4  4770              BX       lr
;;;772    
                          ENDP

                  FLASH_ClearFlag PROC
;;;782      */
;;;783    void FLASH_ClearFlag(uint16_t FLASH_FLAG)
0003c6  4901              LDR      r1,|L1.972|
;;;784    {
;;;785      /* Check the parameters */
;;;786      assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;787      
;;;788      /* Clear the flags */
;;;789      FLASH->SR = FLASH_FLAG;
0003c8  60c8              STR      r0,[r1,#0xc]
;;;790    }
0003ca  4770              BX       lr
;;;791    
                          ENDP

                  |L1.972|
                          DCD      0x40022000
                  |L1.976|
                          DCD      0x45670123
                  |L1.980|
                          DCD      0xcdef89ab
                  |L1.984|
                          DCD      0x1ffff800
                  |L1.988|
                          DCD      0x1ffff000
                  |L1.992|
                          DCD      0x1ffff802
