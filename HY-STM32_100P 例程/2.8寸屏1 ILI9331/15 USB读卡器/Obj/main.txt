; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\main.o --depend=.\Obj\main.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\usb_library\inc -I..\USB_test -I.\FWlib\inc -I.\user -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Obj\main.crf user\main.c]
                          THUMB

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=1

                  Delay PROC
;;;191    *******************************************************************************/
;;;192    void Delay(vu32 nCount)
000000  e000              B        |L1.4|
                  |L1.2|
;;;193    {
;;;194      for(; nCount!= 0;nCount--);
000002  1e40              SUBS     r0,r0,#1
                  |L1.4|
000004  2800              CMP      r0,#0
000006  d1fc              BNE      |L1.2|
;;;195    }
000008  4770              BX       lr
;;;196    
                          ENDP


                          AREA ||i.GetKey||, CODE, READONLY, ALIGN=2

                  GetKey PROC
;;;207    
;;;208    int GetKey (void)  {                    /* Read character from Serial Port    */
000000  4804              LDR      r0,|L2.20|
;;;209    
;;;210      while (!(USART1->SR & USART_FLAG_RXNE));
000002  bf00              NOP      
                  |L2.4|
000004  f8b01800          LDRH     r1,[r0,#0x800]
000008  0689              LSLS     r1,r1,#26
00000a  d5fb              BPL      |L2.4|
;;;211      return (USART_ReceiveData(USART1));
00000c  4802              LDR      r0,|L2.24|
00000e  f7ffbffe          B.W      USART_ReceiveData
;;;212    }
;;;213    
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40013000
                  |L2.24|
                          DCD      0x40013800

                          AREA ||i.Get_Medium_Characteristics||, CODE, READONLY, ALIGN=2

                  Get_Medium_Characteristics PROC
;;;314    *******************************************************************************/
;;;315    void Get_Medium_Characteristics(void)
000000  4a09              LDR      r2,|L3.40|
;;;316    { unsigned long a,b;
;;;317      //u32 temp1 = 0;
;;;318      //u32 temp2 = 0;
;;;319      //Status = SD_GetCardInfo(&SDCardInfo);	 
;;;320      //SD_GetCardInfo(&MSD_csd);
;;;321    
;;;322      a = SDCardInfo.SD_csd.DeviceSize + 1;
000002  6911              LDR      r1,[r2,#0x10]  ; SDCardInfo
;;;323      b = 1 << (SDCardInfo.SD_csd.DeviceSizeMul + 2);
000004  7e13              LDRB     r3,[r2,#0x18]  ; SDCardInfo
000006  1c49              ADDS     r1,r1,#1              ;322
000008  2001              MOVS     r0,#1
00000a  1c9b              ADDS     r3,r3,#2
00000c  fa00f303          LSL      r3,r0,r3
;;;324    
;;;325      Mass_Block_Count = a * b;
000010  4359              MULS     r1,r3,r1
000012  4b06              LDR      r3,|L3.44|
;;;326      //Mass_Block_Size=1;
;;;327      Mass_Block_Size = 1<<SDCardInfo.SD_csd.RdBlockLen;
000014  6019              STR      r1,[r3,#0]  ; Mass_Block_Count
000016  7a13              LDRB     r3,[r2,#8]  ; SDCardInfo
000018  4a05              LDR      r2,|L3.48|
00001a  4098              LSLS     r0,r0,r3
;;;328      //a = 1<<SDCardInfo.SD_csd.RdBlockLen;
;;;329      //temp2 = 512;
;;;330      Mass_Memory_Size = (Mass_Block_Count * Mass_Block_Size);
00001c  4341              MULS     r1,r0,r1
00001e  6010              STR      r0,[r2,#0]  ; Mass_Block_Size
000020  4804              LDR      r0,|L3.52|
000022  6001              STR      r1,[r0,#0]  ; Mass_Memory_Size
;;;331      //a = 1<<SDCardInfo.SD_csd.RdBlockLen;
;;;332      //a = 1<<SDCardInfo.SD_csd.RdBlockLen;
;;;333      //printf("\r\n  %d \n" ,Mass_Memory_Size);
;;;334      //printf("\r\n  %d \n" ,Mass_Block_Size);
;;;335      //printf("\r\n  %d \n" ,Mass_Block_Count);
;;;336    
;;;337    }
000024  4770              BX       lr
;;;338    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      ||area_number.11||
                  |L3.44|
                          DCD      Mass_Block_Count
                  |L3.48|
                          DCD      Mass_Block_Size
                  |L3.52|
                          DCD      Mass_Memory_Size

                          AREA ||i.SendChar||, CODE, READONLY, ALIGN=2

                  SendChar PROC
;;;199    
;;;200    int SendChar (int ch)  {                /* Write character to Serial Port     */
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;201    
;;;202      USART_SendData(USART1, (unsigned char) ch);
000004  b2c1              UXTB     r1,r0
000006  4805              LDR      r0,|L4.28|
000008  f7fffffe          BL       USART_SendData
;;;203      while (!(USART1->SR & USART_FLAG_TXE));
00000c  4804              LDR      r0,|L4.32|
00000e  bf00              NOP      
                  |L4.16|
000010  f8b01800          LDRH     r1,[r0,#0x800]
000014  0609              LSLS     r1,r1,#24
000016  d5fb              BPL      |L4.16|
;;;204      return (ch);
000018  4620              MOV      r0,r4
;;;205    }
00001a  bd10              POP      {r4,pc}
;;;206    
                          ENDP

                  |L4.28|
                          DCD      0x40013800
                  |L4.32|
                          DCD      0x40013000

                          AREA ||i.Serial_Init||, CODE, READONLY, ALIGN=2

                  Serial_Init PROC
;;;237    ///////////////////////////////////////
;;;238    void Serial_Init(void)
000000  b530              PUSH     {r4,r5,lr}
;;;239    {
000002  b085              SUB      sp,sp,#0x14
;;;240      GPIO_InitTypeDef GPIO_InitStructure;
;;;241      USART_InitTypeDef USART_InitStructure;
;;;242     
;;;243      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);
000004  2101              MOVS     r1,#1
000006  f2440004          MOV      r0,#0x4004
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;244      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
00000e  2100              MOVS     r1,#0
000010  f44f4080          MOV      r0,#0x4000
000014  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;245    
;;;246      /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;247      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000018  f44f7000          MOV      r0,#0x200
00001c  f8ad0000          STRH     r0,[sp,#0]
;;;248      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000020  2003              MOVS     r0,#3
000022  f88d0002          STRB     r0,[sp,#2]
;;;249      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000026  2018              MOVS     r0,#0x18
;;;250      GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  4c2e              LDR      r4,|L5.228|
00002a  f88d0003          STRB     r0,[sp,#3]            ;249
00002e  4669              MOV      r1,sp
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       GPIO_Init
;;;251    
;;;252      /* Configure USART1 Rx (PA.10) as input floating */
;;;253      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000036  1520              ASRS     r0,r4,#20
000038  f8ad0000          STRH     r0,[sp,#0]
;;;254      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003c  2004              MOVS     r0,#4
00003e  f88d0003          STRB     r0,[sp,#3]
;;;255      GPIO_Init(GPIOA, &GPIO_InitStructure);
000042  4669              MOV      r1,sp
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       GPIO_Init
;;;256    
;;;257     
;;;258      //VS1003 PE12, PE13, PE14   CS,SI,CLK
;;;259      
;;;260      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14;
00004a  f44f40e0          MOV      r0,#0x7000
;;;261      
;;;262      GPIO_Init(GPIOE, &GPIO_InitStructure);
00004e  4d26              LDR      r5,|L5.232|
000050  f8ad0000          STRH     r0,[sp,#0]            ;260
000054  4669              MOV      r1,sp
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       GPIO_Init
;;;263    
;;;264      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_13;    //PD13 VS1003 RST   
00005c  1460              ASRS     r0,r4,#17
00005e  f8ad0000          STRH     r0,[sp,#0]
;;;265      GPIO_Init(GPIOD, &GPIO_InitStructure);
000062  4669              MOV      r1,sp
000064  4821              LDR      r0,|L5.236|
000066  f7fffffe          BL       GPIO_Init
;;;266      
;;;267      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_6;    //PC6 VS1003 XDCS   
00006a  2040              MOVS     r0,#0x40
00006c  f8ad0000          STRH     r0,[sp,#0]
;;;268      GPIO_Init(GPIOC, &GPIO_InitStructure);
000070  4669              MOV      r1,sp
000072  481f              LDR      r0,|L5.240|
000074  f7fffffe          BL       GPIO_Init
;;;269    
;;;270      	
;;;271      //PENIRQ, SO	
;;;272      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11;
000078  14e4              ASRS     r4,r4,#19
00007a  f8ad4000          STRH     r4,[sp,#0]
;;;273      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
00007e  2028              MOVS     r0,#0x28
000080  f88d0003          STRB     r0,[sp,#3]
;;;274      //GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
;;;275      GPIO_Init(GPIOB, &GPIO_InitStructure);
000084  4669              MOV      r1,sp
000086  481b              LDR      r0,|L5.244|
000088  f7fffffe          BL       GPIO_Init
;;;276    
;;;277      
;;;278      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11;	 
00008c  f8ad4000          STRH     r4,[sp,#0]
;;;279      GPIO_Init(GPIOE, &GPIO_InitStructure);
000090  4669              MOV      r1,sp
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       GPIO_Init
;;;280    
;;;281    
;;;282    /* USART1 configuration ------------------------------------------------------*/
;;;283      // USART1 configured as follow:
;;;284      USART_InitStructure.USART_BaudRate = 115200;
000098  f44f30e1          MOV      r0,#0x1c200
;;;285      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00009c  9001              STR      r0,[sp,#4]
00009e  2000              MOVS     r0,#0
0000a0  f8ad0008          STRH     r0,[sp,#8]
;;;286      USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000a4  f8ad000a          STRH     r0,[sp,#0xa]
;;;287      USART_InitStructure.USART_Parity = USART_Parity_No;
0000a8  f8ad000c          STRH     r0,[sp,#0xc]
;;;288      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0000ac  f8ad0010          STRH     r0,[sp,#0x10]
;;;289      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0000b0  200c              MOVS     r0,#0xc
;;;290    
;;;291      /* Configure the USART1 */
;;;292      USART_Init(USART1, &USART_InitStructure);
0000b2  4c11              LDR      r4,|L5.248|
0000b4  f8ad000e          STRH     r0,[sp,#0xe]          ;289
0000b8  a901              ADD      r1,sp,#4
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       USART_Init
;;;293    
;;;294      /* Enable the USART Transmoit interrupt: this interrupt is generated when the 
;;;295         USART1 transmit data register is empty */  
;;;296      USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
0000c0  2201              MOVS     r2,#1
0000c2  f2407127          MOV      r1,#0x727
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       USART_ITConfig
;;;297    
;;;298      /* Enable the USART Receive interrupt: this interrupt is generated when the 
;;;299         USART1 receive data register is not empty */
;;;300      USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
0000cc  2201              MOVS     r2,#1
0000ce  f2405125          MOV      r1,#0x525
0000d2  4620              MOV      r0,r4
0000d4  f7fffffe          BL       USART_ITConfig
;;;301    
;;;302      /* Enable USART1 */
;;;303      USART_Cmd(USART1, ENABLE);
0000d8  2101              MOVS     r1,#1
0000da  4620              MOV      r0,r4
0000dc  f7fffffe          BL       USART_Cmd
;;;304      
;;;305    }
0000e0  b005              ADD      sp,sp,#0x14
0000e2  bd30              POP      {r4,r5,pc}
;;;306    
                          ENDP

                  |L5.228|
                          DCD      0x40010800
                  |L5.232|
                          DCD      0x40011800
                  |L5.236|
                          DCD      0x40011400
                  |L5.240|
                          DCD      0x40011000
                  |L5.244|
                          DCD      0x40010c00
                  |L5.248|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;222    *******************************************************************************/
;;;223    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;224    {
;;;225      /* Place your implementation of fputc here */
;;;226      /* e.g. write a character to the USART */
;;;227      USART_SendData(USART1, (u8) ch);
000002  4d07              LDR      r5,|L6.32|
000004  4604              MOV      r4,r0                 ;224
000006  b2c1              UXTB     r1,r0
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       USART_SendData
                  |L6.14|
;;;228    
;;;229      /* Loop until the end of transmission */
;;;230      while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
00000e  2140              MOVS     r1,#0x40
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       USART_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L6.14|
;;;231      {
;;;232      }
;;;233    
;;;234      return ch;
00001a  4620              MOV      r0,r4
;;;235    }
00001c  bd70              POP      {r4-r6,pc}
;;;236    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x40013800

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;89     *******************************************************************************/
;;;90     int main(void)
000000  b508              PUSH     {r3,lr}
;;;91     {
;;;92       GPIO_InitTypeDef GPIO_InitStructure;
;;;93     #ifdef DEBUG
;;;94       debug();
;;;95     #endif
;;;96     
;;;97       Set_System();
000002  f7fffffe          BL       Set_System
;;;98       
;;;99       
;;;100      Serial_Init();
000006  f7fffffe          BL       Serial_Init
;;;101      
;;;102      /////////////////////////////////////////////////////////////////////
;;;103      //////// SDCARD Initialisation //////////////////////////////////////
;;;104      /////////////////Section adapted from ST example/////////////////////
;;;105      
;;;106      /*-------------------------- SD Init ----------------------------- */
;;;107      Status = SD_Init();
00000a  f7fffffe          BL       SD_Init
00000e  4c27              LDR      r4,|L7.172|
;;;108    
;;;109      
;;;110      if (Status == SD_OK)
000010  282a              CMP      r0,#0x2a
000012  7020              STRB     r0,[r4,#0]            ;107
000014  d133              BNE      |L7.126|
;;;111      {	
;;;112         
;;;113    	 Status = SD_GetCardInfo(&SDCardInfo);	   
000016  4826              LDR      r0,|L7.176|
000018  f7fffffe          BL       SD_GetCardInfo
00001c  7020              STRB     r0,[r4,#0]
;;;114      }
;;;115     
;;;116      if (Status == SD_OK)
00001e  282a              CMP      r0,#0x2a
000020  d12d              BNE      |L7.126|
;;;117      {	
;;;118        /*----------------- Select Card --------------------------------*/
;;;119        Status = SD_SelectDeselect((uint32_t) (SDCardInfo.RCA << 16));  
000022  4823              LDR      r0,|L7.176|
000024  f8b0004c          LDRH     r0,[r0,#0x4c]  ; SDCardInfo
000028  0400              LSLS     r0,r0,#16
00002a  f7fffffe          BL       SD_SelectDeselect
00002e  7020              STRB     r0,[r4,#0]
;;;120      }
;;;121    
;;;122     
;;;123      if (Status == SD_OK)
000030  282a              CMP      r0,#0x2a
000032  d124              BNE      |L7.126|
;;;124      {  
;;;125        Status = SD_SetDeviceMode(SD_DMA_MODE);	 
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       SD_SetDeviceMode
00003a  7020              STRB     r0,[r4,#0]
;;;126    	//Status = SD_SetDeviceMode(SD_INTERRUPT_MODE);	
;;;127    	//Status = SD_SetDeviceMode(SD_POLLING_MODE);  
;;;128      }
;;;129      
;;;130      if (Status == SD_OK)
00003c  282a              CMP      r0,#0x2a
00003e  d11e              BNE      |L7.126|
;;;131      {	 
;;;132         
;;;133    	  //Status = SD_ReadBlock(0x00, Buffer_Block_Rx, BlockSize);  
;;;134    	  //Status = SD_WriteBlock(0x00, Buffer_Block_Tx, BlockSize);   
;;;135          Status = SD_ReadMultiBlocks(0x00, Buffer_MultiBlock_Rx, BlockSize, NumberOfBlocks);	
000040  2302              MOVS     r3,#2
000042  021d              LSLS     r5,r3,#8
000044  462a              MOV      r2,r5
000046  491b              LDR      r1,|L7.180|
000048  2000              MOVS     r0,#0
00004a  f7fffffe          BL       SD_ReadMultiBlocks
00004e  7020              STRB     r0,[r4,#0]
;;;136    	 
;;;137      }
;;;138      
;;;139     
;;;140      if (Status == SD_OK)
000050  282a              CMP      r0,#0x2a
000052  d114              BNE      |L7.126|
;;;141      {	
;;;142        /* Read block of 512 bytes from address 0 */
;;;143        Status = SD_ReadBlock(0x00, Buffer_Block_Rx, BlockSize);  
000054  4916              LDR      r1,|L7.176|
000056  462a              MOV      r2,r5
000058  3150              ADDS     r1,r1,#0x50
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       SD_ReadBlock
000060  7020              STRB     r0,[r4,#0]
;;;144      }
;;;145    
;;;146     
;;;147      
;;;148      if (Status == SD_OK)
000062  282a              CMP      r0,#0x2a
000064  d10b              BNE      |L7.126|
;;;149      {
;;;150        /* Read block of many bytes from address 0 */
;;;151        Status = SD_ReadMultiBlocks(0x00, Buffer_MultiBlock_Rx, BlockSize, NumberOfBlocks);	 
000066  2302              MOVS     r3,#2
000068  462a              MOV      r2,r5
00006a  4912              LDR      r1,|L7.180|
00006c  2000              MOVS     r0,#0
00006e  f7fffffe          BL       SD_ReadMultiBlocks
000072  7020              STRB     r0,[r4,#0]
;;;152      }
;;;153    
;;;154      if (Status == SD_OK)
000074  282a              CMP      r0,#0x2a
000076  d102              BNE      |L7.126|
;;;155      {	 
;;;156        /* Check the corectness of written dada */
;;;157        
;;;158    
;;;159    	printf("\r\nSD SDIO-1bit模式 测试TF卡读写成功！ \n ");
000078  a00f              ADR      r0,|L7.184|
00007a  f7fffffe          BL       __2printf
                  |L7.126|
;;;160      }  
;;;161    
;;;162    
;;;163       
;;;164      Get_Medium_Characteristics();
00007e  f7fffffe          BL       Get_Medium_Characteristics
;;;165      Set_USBClock();
000082  f7fffffe          BL       Set_USBClock
;;;166      USB_Interrupts_Config(); 
000086  f7fffffe          BL       USB_Interrupts_Config
;;;167      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
00008a  f44f5000          MOV      r0,#0x2000
00008e  f8ad0000          STRH     r0,[sp,#0]
;;;168      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000092  2003              MOVS     r0,#3
000094  f88d0002          STRB     r0,[sp,#2]
;;;169      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
000098  2014              MOVS     r0,#0x14
00009a  f88d0003          STRB     r0,[sp,#3]
;;;170      GPIO_Init(GPIOC, &GPIO_InitStructure);
00009e  4669              MOV      r1,sp
0000a0  4810              LDR      r0,|L7.228|
0000a2  f7fffffe          BL       GPIO_Init
;;;171      USB_Init();
0000a6  f7fffffe          BL       USB_Init
                  |L7.170|
;;;172    
;;;173      
;;;174      
;;;175      while (1)
0000aa  e7fe              B        |L7.170|
;;;176      {	
;;;177        //printf("\nTEST OK!\n");
;;;178        //if (JoyState() != 0)
;;;179        //{
;;;180        //  Joystick_Send(JoyState());
;;;181        //}
;;;182      }
;;;183    }
;;;184    
                          ENDP

                  |L7.172|
                          DCD      ||area_number.23||
                  |L7.176|
                          DCD      ||area_number.11||
                  |L7.180|
                          DCD      ||area_number.11||+0x250
                  |L7.184|
0000b8  0d0a5344          DCB      "\r\nSD SDIO-1bit",196,163,202,189," ",178,226,202,212,"T"
0000bc  20534449
0000c0  4f2d3162
0000c4  6974c4a3
0000c8  cabd20b2
0000cc  e2cad454
0000d0  46bfa8b6          DCB      "F",191,168,182,193,208,180,179,201,185,166,163,161," \n"
0000d4  c1d0b4b3
0000d8  c9b9a6a3
0000dc  a1200a  
0000df  2000              DCB      " ",0
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L7.228|
                          DCD      0x40011000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USART_InitStructure
                          %        16

                          AREA ||area_number.10||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.10||, ||.bss||
                  RxBuffer1
                          %        44

                          AREA ||area_number.11||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.bss||
                  SDCardInfo
                          %        80
                  Buffer_Block_Rx
                          %        512
                  Buffer_MultiBlock_Rx
                          %        1024

                          AREA ||area_number.12||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.bss||
                  Buffer_Block_Tx
                          %        512

                          AREA ||area_number.13||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.bss||
                  Buffer_MultiBlock_Tx
                          %        1024

                          AREA ||.data||, DATA, ALIGN=0

                  TxBuffer1
000000  55534152          DCB      0x55,0x53,0x41,0x52
000004  5420496e          DCB      0x54,0x20,0x49,0x6e
000008  74657272          DCB      0x74,0x65,0x72,0x72
00000c  75707420          DCB      0x75,0x70,0x74,0x20
000010  4578616d          DCB      0x45,0x78,0x61,0x6d
000014  706c653a          DCB      0x70,0x6c,0x65,0x3a
000018  20546869          DCB      0x20,0x54,0x68,0x69
00001c  73206973          DCB      0x73,0x20,0x69,0x73
000020  20555341          DCB      0x20,0x55,0x53,0x41
000024  52543120          DCB      0x52,0x54,0x31,0x20
000028  44454d4f          DCB      0x44,0x45,0x4d,0x4f
00002c  00                DCB      0x00

                          AREA ||area_number.16||, DATA, ALIGN=0

                          EXPORTAS ||area_number.16||, ||.data||
                  TxCounter1
000000  00                DCB      0x00

                          AREA ||area_number.17||, DATA, ALIGN=0

                          EXPORTAS ||area_number.17||, ||.data||
                  RxCounter1
000000  00                DCB      0x00

                          AREA ||area_number.18||, DATA, ALIGN=0

                          EXPORTAS ||area_number.18||, ||.data||
                  NbrOfDataToTransfer1
000000  2c                DCB      0x2c

                          AREA ||area_number.19||, DATA, ALIGN=0

                          EXPORTAS ||area_number.19||, ||.data||
                  NbrOfDataToRead1
000000  2c                DCB      0x2c

                          AREA ||area_number.20||, DATA, ALIGN=0

                          EXPORTAS ||area_number.20||, ||.data||
                  EraseStatus
000000  00                DCB      0x00

                          AREA ||area_number.21||, DATA, ALIGN=0

                          EXPORTAS ||area_number.21||, ||.data||
                  TransferStatus1
000000  00                DCB      0x00

                          AREA ||area_number.22||, DATA, ALIGN=0

                          EXPORTAS ||area_number.22||, ||.data||
                  TransferStatus2
000000  00                DCB      0x00

                          AREA ||area_number.23||, DATA, ALIGN=0

                          EXPORTAS ||area_number.23||, ||.data||
                  Status
000000  2a                DCB      0x2a

                          AREA ||area_number.24||, DATA, ALIGN=0

                          EXPORTAS ||area_number.24||, ||.data||
                  rec_f
000000  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
