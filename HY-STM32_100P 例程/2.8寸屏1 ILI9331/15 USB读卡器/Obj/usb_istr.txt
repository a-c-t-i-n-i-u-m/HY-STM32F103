; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\usb_istr.o --depend=.\Obj\usb_istr.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\usb_library\inc -I..\USB_test -I.\FWlib\inc -I.\user -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Obj\usb_istr.crf user\usb_istr.c]
                          THUMB

                          AREA ||i.USB_Istr||, CODE, READONLY, ALIGN=2

                  USB_Istr PROC
;;;69     *******************************************************************************/
;;;70     void USB_Istr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;71     {
;;;72     
;;;73       wIstr = _GetISTR();
000002  480e              LDR      r0,|L1.60|
000004  f8d01c44          LDR      r1,[r0,#0xc44]
000008  4c0d              LDR      r4,|L1.64|
00000a  8021              STRH     r1,[r4,#0]
;;;74     
;;;75     #if (IMR_MSK & ISTR_RESET)
;;;76       if (wIstr & ISTR_RESET & wInterrupt_Mask)
00000c  8821              LDRH     r1,[r4,#0]  ; wIstr
00000e  4d0d              LDR      r5,|L1.68|
000010  882a              LDRH     r2,[r5,#0]  ; wInterrupt_Mask
000012  4011              ANDS     r1,r1,r2
000014  0549              LSLS     r1,r1,#21
000016  d506              BPL      |L1.38|
;;;77       {
;;;78         _SetISTR((u16)CLR_RESET);
000018  f64f31ff          MOV      r1,#0xfbff
00001c  f8c01c44          STR      r1,[r0,#0xc44]
;;;79         Device_Property.Reset();
000020  4809              LDR      r0,|L1.72|
000022  6840              LDR      r0,[r0,#4]  ; Device_Property
000024  4780              BLX      r0
                  |L1.38|
;;;80     #ifdef RESET_CALLBACK
;;;81         RESET_Callback();
;;;82     #endif
;;;83       }
;;;84     #endif
;;;85       /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;86     #if (IMR_MSK & ISTR_DOVR)
;;;87       if (wIstr & ISTR_DOVR & wInterrupt_Mask)
;;;88       {
;;;89         _SetISTR((u16)CLR_DOVR);
;;;90     #ifdef DOVR_CALLBACK
;;;91         DOVR_Callback();
;;;92     #endif
;;;93       }
;;;94     #endif
;;;95       /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;96     #if (IMR_MSK & ISTR_ERR)
;;;97       if (wIstr & ISTR_ERR & wInterrupt_Mask)
;;;98       {
;;;99         _SetISTR((u16)CLR_ERR);
;;;100    #ifdef ERR_CALLBACK
;;;101        ERR_Callback();
;;;102    #endif
;;;103      }
;;;104    #endif
;;;105      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;106    #if (IMR_MSK & ISTR_WKUP)
;;;107      if (wIstr & ISTR_WKUP & wInterrupt_Mask)
;;;108      {
;;;109        _SetISTR((u16)CLR_WKUP);
;;;110        Resume(RESUME_EXTERNAL);
;;;111    #ifdef WKUP_CALLBACK
;;;112        WKUP_Callback();
;;;113    #endif
;;;114      }
;;;115    #endif
;;;116      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;117    #if (IMR_MSK & ISTR_SUSP)
;;;118      if (wIstr & ISTR_SUSP & wInterrupt_Mask)
;;;119      {
;;;120    
;;;121        /* check if SUSPEND is possible */
;;;122        if (fSuspendEnabled)
;;;123        {
;;;124          Suspend();
;;;125        }
;;;126        else
;;;127        {
;;;128          /* if not possible then resume after xx ms */
;;;129          Resume(RESUME_LATER);
;;;130        }
;;;131        /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
;;;132        _SetISTR((u16)CLR_SUSP);
;;;133    #ifdef SUSP_CALLBACK
;;;134        SUSP_Callback();
;;;135    #endif
;;;136      }
;;;137    #endif
;;;138      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;139    #if (IMR_MSK & ISTR_SOF)
;;;140      if (wIstr & ISTR_SOF & wInterrupt_Mask)
;;;141      {
;;;142        _SetISTR((u16)CLR_SOF);
;;;143        bIntPackSOF++;
;;;144    
;;;145    #ifdef SOF_CALLBACK
;;;146        SOF_Callback();
;;;147    #endif
;;;148      }
;;;149    #endif
;;;150      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;151    #if (IMR_MSK & ISTR_ESOF)
;;;152      if (wIstr & ISTR_ESOF & wInterrupt_Mask)
;;;153      {
;;;154        _SetISTR((u16)CLR_ESOF);
;;;155        /* resume handling timing is made with ESOFs */
;;;156        Resume(RESUME_ESOF); /* request without change of the machine state */
;;;157    
;;;158    #ifdef ESOF_CALLBACK
;;;159        ESOF_Callback();
;;;160    #endif
;;;161      }
;;;162    #endif
;;;163      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;164    #if (IMR_MSK & ISTR_CTR)
;;;165      if (wIstr & ISTR_CTR & wInterrupt_Mask)
000026  8820              LDRH     r0,[r4,#0]  ; wIstr
000028  8829              LDRH     r1,[r5,#0]  ; wInterrupt_Mask
00002a  4008              ANDS     r0,r0,r1
00002c  0400              LSLS     r0,r0,#16
00002e  d503              BPL      |L1.56|
;;;166      {
;;;167        /* servicing of the endpoint correct transfer interrupt */
;;;168        /* clear of the CTR flag into the sub */
;;;169        CTR_LP();
000030  e8bd4070          POP      {r4-r6,lr}
000034  f7ffbffe          B.W      CTR_LP
                  |L1.56|
;;;170    #ifdef CTR_CALLBACK
;;;171        CTR_Callback();
;;;172    #endif
;;;173      }
;;;174    #endif
;;;175    } /* USB_Istr */
000038  bd70              POP      {r4-r6,pc}
;;;176    
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
                          DCD      0x40005000
                  |L1.64|
                          DCD      ||area_number.7||
                  |L1.68|
                          DCD      wInterrupt_Mask
                  |L1.72|
                          DCD      Device_Property

                          AREA ||.data||, DATA, ALIGN=0

                  bIntPackSOF
000000  00                DCB      0x00

                          AREA ||area_number.5||, DATA, ALIGN=2

                          EXPORTAS ||area_number.5||, ||.data||
                  pEpInt_IN
                          DCD      EP1_IN_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process

                          AREA ||area_number.6||, DATA, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.data||
                  pEpInt_OUT
                          DCD      NOP_Process
                          DCD      EP2_OUT_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process

                          AREA ||area_number.7||, DATA, ALIGN=1

                          EXPORTAS ||area_number.7||, ||.data||
                  wIstr
000000  0000              DCB      0x00,0x00
