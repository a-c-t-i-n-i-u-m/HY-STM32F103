; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\hw_config.o --depend=.\Obj\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\usb_library\inc -I..\USB_test -I.\FWlib\inc -I.\user -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Obj\hw_config.crf user\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=1

                  Enter_LowPowerMode PROC
;;;154    *******************************************************************************/
;;;155    void Enter_LowPowerMode(void)
000000  4770              BX       lr
;;;156    {
;;;157    }
;;;158    
                          ENDP


                          AREA ||i.JoyState||, CODE, READONLY, ALIGN=2

                  JoyState PROC
;;;229    *******************************************************************************/
;;;230    u8 JoyState(void)
000000  b510              PUSH     {r4,lr}
;;;231    {
;;;232      /* "right" key is pressed */
;;;233      if (!GPIO_ReadInputDataBit(GPIOE, JOY_RIGHT))
000002  4c17              LDR      r4,|L2.96|
000004  2120              MOVS     r1,#0x20
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ReadInputDataBit
00000c  b1d8              CBZ      r0,|L2.70|
;;;234      {
;;;235        return RIGHT;
;;;236      }
;;;237      /* "left" key is pressed */
;;;238      if (!GPIO_ReadInputDataBit(GPIOE, JOY_LEFT))
00000e  2110              MOVS     r1,#0x10
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       GPIO_ReadInputDataBit
000016  b1c0              CBZ      r0,|L2.74|
;;;239      {
;;;240        return LEFT;
;;;241      }
;;;242      /* "up" key is pressed */
;;;243      if (!GPIO_ReadInputDataBit(GPIOE, JOY_UP))
000018  2104              MOVS     r1,#4
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       GPIO_ReadInputDataBit
000020  b1a8              CBZ      r0,|L2.78|
;;;244      {
;;;245        return UP;
;;;246      }
;;;247      /* "down" key is pressed */
;;;248      if (!GPIO_ReadInputDataBit(GPIOE, JOY_DOWN))
000022  2108              MOVS     r1,#8
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GPIO_ReadInputDataBit
00002a  b190              CBZ      r0,|L2.82|
;;;249      {
;;;250        return DOWN;
;;;251      }
;;;252      if (!GPIO_ReadInputDataBit(GPIOC, JOY_LEFT_BUTTON))
00002c  1461              ASRS     r1,r4,#17
00002e  4c0d              LDR      r4,|L2.100|
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       GPIO_ReadInputDataBit
000036  b170              CBZ      r0,|L2.86|
;;;253      {
;;;254        return LEFT_BUTTON;
;;;255      }
;;;256       if (!GPIO_ReadInputDataBit(GPIOC, JOY_RIGHT_BUTTON))
000038  14a1              ASRS     r1,r4,#18
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       GPIO_ReadInputDataBit
000040  b158              CBZ      r0,|L2.90|
;;;257      {
;;;258        return RIGHT_BUTTON;
;;;259      }
;;;260      /* No key is pressed */
;;;261      else
;;;262      {
;;;263        return 0;
000042  2000              MOVS     r0,#0
;;;264      }
;;;265    }
000044  bd10              POP      {r4,pc}
                  |L2.70|
000046  2003              MOVS     r0,#3                 ;235
000048  bd10              POP      {r4,pc}
                  |L2.74|
00004a  2002              MOVS     r0,#2                 ;240
00004c  bd10              POP      {r4,pc}
                  |L2.78|
00004e  2004              MOVS     r0,#4                 ;245
000050  bd10              POP      {r4,pc}
                  |L2.82|
000052  2001              MOVS     r0,#1                 ;250
000054  bd10              POP      {r4,pc}
                  |L2.86|
000056  2005              MOVS     r0,#5                 ;254
000058  bd10              POP      {r4,pc}
                  |L2.90|
00005a  2006              MOVS     r0,#6                 ;258
00005c  bd10              POP      {r4,pc}
;;;266    
                          ENDP

00005e  0000              DCW      0x0000
                  |L2.96|
                          DCD      0x40011800
                  |L2.100|
                          DCD      0x40011000

                          AREA ||i.Joystick_Send||, CODE, READONLY, ALIGN=1

                  Joystick_Send PROC
;;;273    *******************************************************************************/
;;;274    void Joystick_Send(u8 Keys)
000000  b538              PUSH     {r3-r5,lr}
;;;275    {
;;;276      u8 Mouse_Buffer[4] = {0, 0, 0, 0};
000002  2400              MOVS     r4,#0
;;;277      s8 X = 0, Y = 0,BUTTON=0;
;;;278    
;;;279      switch (Keys)
;;;280      {
;;;281        case LEFT:
;;;282          X += CURSOR_STEP;
;;;283          break;
;;;284        case RIGHT:
;;;285    
;;;286          X -= CURSOR_STEP;
000004  1ee3              SUBS     r3,r4,#3
000006  4621              MOV      r1,r4                 ;277
000008  4622              MOV      r2,r4                 ;277
00000a  4625              MOV      r5,r4                 ;277
00000c  9400              STR      r4,[sp,#0]            ;279
00000e  2807              CMP      r0,#7                 ;279
000010  d22e              BCS      |L3.112|
000012  e8dff000          TBB      [pc,r0]               ;279
000016  2d0a              DCB      0x2d,0x0a
000018  0406080c          DCB      0x04,0x06,0x08,0x0c
00001c  0e00              DCB      0x0e,0x00
00001e  2103              MOVS     r1,#3                 ;282
000020  e008              B        |L3.52|
000022  4619              MOV      r1,r3
;;;287          break;
000024  e006              B        |L3.52|
;;;288        case UP:
;;;289          Y -= CURSOR_STEP;
000026  461a              MOV      r2,r3
;;;290          break;
000028  e004              B        |L3.52|
;;;291        case DOWN:
;;;292          Y += CURSOR_STEP;
00002a  2203              MOVS     r2,#3
;;;293          break;
00002c  e002              B        |L3.52|
;;;294    	 case LEFT_BUTTON:
;;;295          BUTTON = BUTTON|0x01;
00002e  2501              MOVS     r5,#1
;;;296          break;
000030  e000              B        |L3.52|
;;;297     	 case RIGHT_BUTTON:
;;;298          BUTTON = BUTTON|0x02;
000032  2502              MOVS     r5,#2
                  |L3.52|
;;;299          break;
;;;300        
;;;301        default:
;;;302          return;
;;;303      }
;;;304    
;;;305      /* prepare buffer to send */
;;;306      Mouse_Buffer[0] = BUTTON;
000034  f88d5000          STRB     r5,[sp,#0]
;;;307      Mouse_Buffer[1] = X;
000038  f88d1001          STRB     r1,[sp,#1]
;;;308      Mouse_Buffer[2] = Y;
00003c  f88d2002          STRB     r2,[sp,#2]
;;;309    
;;;310      /*copy mouse position info in ENDP1 Tx Packet Memory Area*/
;;;311      UserToPMABufferCopy(Mouse_Buffer, GetEPTxAddr(ENDP1), 4);
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       GetEPTxAddr
000046  4601              MOV      r1,r0
000048  2204              MOVS     r2,#4
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       UserToPMABufferCopy
;;;312      if(Mouse_Buffer[0]!= 0)
000050  f89d0000          LDRB     r0,[sp,#0]
000054  b148              CBZ      r0,|L3.106|
;;;313      {
;;;314        Mouse_Buffer[0] = 0;
000056  f88d4000          STRB     r4,[sp,#0]
;;;315        UserToPMABufferCopy(Mouse_Buffer, GetEPTxAddr(ENDP1), 4);
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       GetEPTxAddr
000060  4601              MOV      r1,r0
000062  2204              MOVS     r2,#4
000064  4668              MOV      r0,sp
000066  f7fffffe          BL       UserToPMABufferCopy
                  |L3.106|
;;;316      } 
;;;317      /* enable endpoint for transmission */
;;;318      SetEPTxValid(ENDP1);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       SetEPTxValid
                  |L3.112|
;;;319    }
000070  bd38              POP      {r3-r5,pc}
;;;320    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=1

                  Leave_LowPowerMode PROC
;;;165    *******************************************************************************/
;;;166    void Leave_LowPowerMode(void)
000000  4770              BX       lr
;;;167    {
;;;168    }
;;;169    
                          ENDP


                          AREA ||i.Led_Config||, CODE, READONLY, ALIGN=2

                  Led_Config PROC
;;;322    
;;;323    void Led_Config(void)
000000  b508              PUSH     {r3,lr}
;;;324    {
;;;325      GPIO_InitTypeDef GPIO_InitStructure;
;;;326    
;;;327      /* Enable GPIOC clock */
;;;328      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;329    
;;;330      /* Configure PC.06, PC.07, PC.08 and PC.09 as output push-pull */
;;;331      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_5 ;
00000a  2020              MOVS     r0,#0x20
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;332      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;333      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;334      GPIO_Init(GPIOB, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L5.40|
000020  f7fffffe          BL       GPIO_Init
;;;335    }
000024  bd08              POP      {r3,pc}
;;;336    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x40010c00

                          AREA ||i.Led_RW_OFF||, CODE, READONLY, ALIGN=2

                  Led_RW_OFF PROC
;;;355    *******************************************************************************/
;;;356    void Led_RW_OFF(void)
000000  2120              MOVS     r1,#0x20
;;;357    {
;;;358      GPIO_ResetBits(GPIOB, GPIO_Pin_5 );
000002  4801              LDR      r0,|L6.8|
000004  f7ffbffe          B.W      GPIO_ResetBits
;;;359    }
;;;360    
                          ENDP

                  |L6.8|
                          DCD      0x40010c00

                          AREA ||i.Led_RW_ON||, CODE, READONLY, ALIGN=2

                  Led_RW_ON PROC
;;;343    *******************************************************************************/
;;;344    void Led_RW_ON(void)
000000  2120              MOVS     r1,#0x20
;;;345    {
;;;346      GPIO_SetBits(GPIOB, GPIO_Pin_5 );
000002  4801              LDR      r0,|L7.8|
000004  f7ffbffe          B.W      GPIO_SetBits
;;;347    }
;;;348    
                          ENDP

                  |L7.8|
                          DCD      0x40010c00

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;50     *******************************************************************************/
;;;51     void Set_System(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;52     {  NVIC_InitTypeDef NVIC_InitStructure;
;;;53       GPIO_InitTypeDef GPIO_InitStructure;
;;;54     
;;;55       /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration -----------------------------*/   
;;;56       /* RCC system reset(for debug purpose) */
;;;57       RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;58     
;;;59       /* Enable HSE */
;;;60       RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3480          MOV      r4,#0x10000
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RCC_HSEConfig
;;;61     
;;;62       /* Wait till HSE is ready */
;;;63       HSEStartUpStatus = RCC_WaitForHSEStartUp();
000010  f7fffffe          BL       RCC_WaitForHSEStartUp
000014  4926              LDR      r1,|L8.176|
;;;64     
;;;65       if(HSEStartUpStatus == SUCCESS)
000016  2801              CMP      r0,#1
000018  7008              STRB     r0,[r1,#0]            ;63
00001a  d125              BNE      |L8.104|
;;;66       {
;;;67         /* Enable Prefetch Buffer */
;;;68         FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;69     
;;;70         /* Flash 2 wait state */
;;;71         FLASH_SetLatency(FLASH_Latency_2);
000022  2002              MOVS     r0,#2
000024  f7fffffe          BL       FLASH_SetLatency
;;;72      
;;;73         /* HCLK = SYSCLK */
;;;74         RCC_HCLKConfig(RCC_SYSCLK_Div1); 
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       RCC_HCLKConfig
;;;75       
;;;76         /* PCLK2 = HCLK */
;;;77         RCC_PCLK2Config(RCC_HCLK_Div1); 
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       RCC_PCLK2Config
;;;78     
;;;79         /* PCLK1 = HCLK/2 */
;;;80         RCC_PCLK1Config(RCC_HCLK_Div2);
000034  11a0              ASRS     r0,r4,#6
000036  f7fffffe          BL       RCC_PCLK1Config
;;;81     
;;;82         /* ADCCLK = PCLK2/6 */
;;;83         RCC_ADCCLKConfig(RCC_PCLK2_Div6);
00003a  1060              ASRS     r0,r4,#1
00003c  f7fffffe          BL       RCC_ADCCLKConfig
;;;84     
;;;85         /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;86         RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
000040  f44f11e0          MOV      r1,#0x1c0000
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       RCC_PLLConfig
;;;87     
;;;88         /* Enable PLL */ 
;;;89         RCC_PLLCmd(ENABLE);
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       RCC_PLLCmd
                  |L8.80|
;;;90     
;;;91         /* Wait till PLL is ready */
;;;92         while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000050  2039              MOVS     r0,#0x39
000052  f7fffffe          BL       RCC_GetFlagStatus
000056  2800              CMP      r0,#0
000058  d0fa              BEQ      |L8.80|
;;;93         {
;;;94         }
;;;95     
;;;96         /* Select PLL as system clock source */
;;;97         RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00005a  2002              MOVS     r0,#2
00005c  f7fffffe          BL       RCC_SYSCLKConfig
                  |L8.96|
;;;98     
;;;99         /* Wait till PLL is used as system clock source */
;;;100        while(RCC_GetSYSCLKSource() != 0x08)
000060  f7fffffe          BL       RCC_GetSYSCLKSource
000064  2808              CMP      r0,#8
000066  d1fb              BNE      |L8.96|
                  |L8.104|
;;;101        {
;;;102        }
;;;103      }
;;;104      /* Enable and GPIOD clock */
;;;105      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
000068  2101              MOVS     r1,#1
00006a  2010              MOVS     r0,#0x10
00006c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;106      
;;;107      /* PD.09 used as USB pull-up */
;;;108      //GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
;;;109      //GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;110      //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
;;;111      //GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;112    
;;;113      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;		         //LED1
000070  2020              MOVS     r0,#0x20
000072  f8ad0004          STRH     r0,[sp,#4]
;;;114      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000076  2003              MOVS     r0,#3
000078  f88d0006          STRB     r0,[sp,#6]
;;;115      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00007c  2010              MOVS     r0,#0x10
00007e  f88d0007          STRB     r0,[sp,#7]
;;;116      GPIO_Init(GPIOB, &GPIO_InitStructure);
000082  a901              ADD      r1,sp,#4
000084  480b              LDR      r0,|L8.180|
000086  f7fffffe          BL       GPIO_Init
;;;117    
;;;118      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
00008a  f44f60c0          MOV      r0,#0x600
00008e  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;119    
;;;120      NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQn;
000092  2031              MOVS     r0,#0x31
000094  f88d0000          STRB     r0,[sp,#0]
;;;121      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000098  2000              MOVS     r0,#0
00009a  f88d0001          STRB     r0,[sp,#1]
;;;122      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00009e  f88d0002          STRB     r0,[sp,#2]
;;;123      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000a2  2001              MOVS     r0,#1
0000a4  f88d0003          STRB     r0,[sp,#3]
;;;124      NVIC_Init(&NVIC_InitStructure);
0000a8  4668              MOV      r0,sp
0000aa  f7fffffe          BL       NVIC_Init
;;;125      //GPIO_ResetBits(GPIOC, GPIO_Pin_13);
;;;126      //GPIO_ResetBits(GPIOC, GPIO_Pin_5);
;;;127      //GPIO_SetBits(GPIOB, GPIO_Pin_5);
;;;128    
;;;129    
;;;130    }
0000ae  bd1c              POP      {r2-r4,pc}
;;;131    
                          ENDP

                  |L8.176|
                          DCD      ||area_number.17||
                  |L8.180|
                          DCD      0x40010c00

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;138    *******************************************************************************/
;;;139    void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;140    {
;;;141       /* USBCLK = PLLCLK */
;;;142      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;143    
;;;144      /* Enable USB clock */
;;;145      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  e8bd4010          POP      {r4,lr}
00000e  05c8              LSLS     r0,r1,#23
000010  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;146    }
;;;147    
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;210    *******************************************************************************/
;;;211    void USB_Cable_Config (FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;212    { 
;;;213      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;214      {
;;;215        GPIO_ResetBits(GPIOC, GPIO_Pin_13);
000004  f44f5100          MOV      r1,#0x2000
;;;216      }
;;;217      else
;;;218      {
;;;219        GPIO_SetBits(GPIOC, GPIO_Pin_13);
000008  4610              MOV      r0,r2
00000a  d001              BEQ      |L10.16|
00000c  f7ffbffe          B.W      GPIO_ResetBits
                  |L10.16|
000010  f7ffbffe          B.W      GPIO_SetBits
;;;220      }
;;;221    }
;;;222    
                          ENDP

                  |L10.20|
                          DCD      0x40011000

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;176    *******************************************************************************/
;;;177    void USB_Interrupts_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;178    {
;;;179        NVIC_InitTypeDef NVIC_InitStructure;
;;;180    
;;;181    #ifdef  VECT_TAB_RAM
;;;182      /* Set the Vector Table base location at 0x20000000 */
;;;183      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
;;;184    #else  /* VECT_TAB_FLASH */
;;;185      /* Set the Vector Table base location at 0x08000000 */
;;;186      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;187    #endif
;;;188    
;;;189      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
00000c  f44f60c0          MOV      r0,#0x600
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;190    
;;;191      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
000014  2014              MOVS     r0,#0x14
000016  f88d0000          STRB     r0,[sp,#0]
;;;192      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00001a  2401              MOVS     r4,#1
00001c  f88d4001          STRB     r4,[sp,#1]
;;;193      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000020  2500              MOVS     r5,#0
000022  f88d5002          STRB     r5,[sp,#2]
;;;194      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000026  f88d4003          STRB     r4,[sp,#3]
;;;195      NVIC_Init(&NVIC_InitStructure);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       NVIC_Init
;;;196      
;;;197      NVIC_InitStructure.NVIC_IRQChannel = USB_HP_CAN1_TX_IRQn;
000030  2013              MOVS     r0,#0x13
000032  f88d0000          STRB     r0,[sp,#0]
;;;198      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;	 
000036  f88d5001          STRB     r5,[sp,#1]
;;;199      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00003a  f88d5002          STRB     r5,[sp,#2]
;;;200      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00003e  f88d4003          STRB     r4,[sp,#3]
;;;201      NVIC_Init(&NVIC_InitStructure);
000042  4668              MOV      r0,sp
000044  f7fffffe          BL       NVIC_Init
;;;202    }
000048  bd38              POP      {r3-r5,pc}
;;;203    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  Mass_Memory_Size
                          DCD      0x00000000

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  Mass_Block_Size
                          DCD      0x00000000

                          AREA ||area_number.16||, DATA, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.data||
                  Mass_Block_Count
                          DCD      0x00000000

                          AREA ||area_number.17||, DATA, ALIGN=0

                          EXPORTAS ||area_number.17||, ||.data||
                  HSEStartUpStatus
000000  00                DCB      0x00
