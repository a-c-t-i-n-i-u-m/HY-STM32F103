; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\stm32f10x_flash.o --depend=.\Obj\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\usb_library\inc -I..\USB_test -I.\FWlib\inc -I.\user -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Obj\stm32f10x_flash.crf FWlib\SRC\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;782      */
;;;783    void FLASH_ClearFlag(uint16_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;784    {
;;;785      /* Check the parameters */
;;;786      assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;787      
;;;788      /* Clear the flags */
;;;789      FLASH->SR = FLASH_FLAG;
000002  60c8              STR      r0,[r1,#0xc]
;;;790    }
000004  4770              BX       lr
;;;791    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;460      */
;;;461    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;462    {
;;;463      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
;;;464      
;;;465      FLASH_Status status = FLASH_COMPLETE;
;;;466      
;;;467      /* Check the parameters */
;;;468      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;469      
;;;470      FLASH_Pages = (uint32_t)(~FLASH_Pages);
000004  43c0              MVNS     r0,r0
;;;471      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
000006  b2c4              UXTB     r4,r0
;;;472      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
000008  f3c02507          UBFX     r5,r0,#8,#8
;;;473      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
00000c  f3c04607          UBFX     r6,r0,#16,#8
;;;474      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
000010  0e07              LSRS     r7,r0,#24
;;;475      
;;;476      /* Wait for last operation to be completed */
;;;477      status = FLASH_WaitForLastOperation(ProgramTimeout);
000012  200f              MOVS     r0,#0xf
000014  f7fffffe          BL       FLASH_WaitForLastOperation
;;;478      
;;;479      if(status == FLASH_COMPLETE)
000018  2804              CMP      r0,#4
00001a  d13a              BNE      |L2.146|
;;;480      {
;;;481        /* Authorizes the small information block programming */
;;;482        FLASH->OPTKEYR = FLASH_KEY1;
00001c  f8df907c          LDR      r9,|L2.156|
000020  4a1d              LDR      r2,|L2.152|
000022  f8c92008          STR      r2,[r9,#8]
;;;483        FLASH->OPTKEYR = FLASH_KEY2;
000026  4a1e              LDR      r2,|L2.160|
000028  f8c92008          STR      r2,[r9,#8]
;;;484        FLASH->CR |= CR_OPTPG_Set;
00002c  f8d92010          LDR      r2,[r9,#0x10]
;;;485        if(WRP0_Data != 0xFF)
;;;486        {
;;;487          OB->WRP0 = WRP0_Data;
000030  f8df8070          LDR      r8,|L2.164|
000034  f0420210          ORR      r2,r2,#0x10           ;484
000038  f8c92010          STR      r2,[r9,#0x10]         ;484
00003c  2cff              CMP      r4,#0xff              ;485
00003e  d006              BEQ      |L2.78|
000040  f8a84808          STRH     r4,[r8,#0x808]
;;;488          
;;;489          /* Wait for last operation to be completed */
;;;490          status = FLASH_WaitForLastOperation(ProgramTimeout);
000044  200f              MOVS     r0,#0xf
000046  f7fffffe          BL       FLASH_WaitForLastOperation
;;;491        }
;;;492        if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
00004a  2804              CMP      r0,#4
00004c  d118              BNE      |L2.128|
                  |L2.78|
00004e  2dff              CMP      r5,#0xff
000050  d006              BEQ      |L2.96|
;;;493        {
;;;494          OB->WRP1 = WRP1_Data;
000052  f8a8580a          STRH     r5,[r8,#0x80a]
;;;495          
;;;496          /* Wait for last operation to be completed */
;;;497          status = FLASH_WaitForLastOperation(ProgramTimeout);
000056  200f              MOVS     r0,#0xf
000058  f7fffffe          BL       FLASH_WaitForLastOperation
;;;498        }
;;;499        if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
00005c  2804              CMP      r0,#4
00005e  d10f              BNE      |L2.128|
                  |L2.96|
000060  2eff              CMP      r6,#0xff
000062  d006              BEQ      |L2.114|
;;;500        {
;;;501          OB->WRP2 = WRP2_Data;
000064  f8a8680c          STRH     r6,[r8,#0x80c]
;;;502          
;;;503          /* Wait for last operation to be completed */
;;;504          status = FLASH_WaitForLastOperation(ProgramTimeout);
000068  200f              MOVS     r0,#0xf
00006a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;505        }
;;;506        
;;;507        if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
00006e  2804              CMP      r0,#4
000070  d106              BNE      |L2.128|
                  |L2.114|
000072  2fff              CMP      r7,#0xff
000074  d006              BEQ      |L2.132|
;;;508        {
;;;509          OB->WRP3 = WRP3_Data;
000076  f8a8780e          STRH     r7,[r8,#0x80e]
;;;510         
;;;511          /* Wait for last operation to be completed */
;;;512          status = FLASH_WaitForLastOperation(ProgramTimeout);
00007a  200f              MOVS     r0,#0xf
00007c  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L2.128|
;;;513        }
;;;514              
;;;515        if(status != FLASH_BUSY)
000080  2801              CMP      r0,#1
000082  d006              BEQ      |L2.146|
                  |L2.132|
;;;516        {
;;;517          /* if the program operation is completed, disable the OPTPG Bit */
;;;518          FLASH->CR &= CR_OPTPG_Reset;
000084  f8d92010          LDR      r2,[r9,#0x10]
000088  f64173ef          MOV      r3,#0x1fef
00008c  401a              ANDS     r2,r2,r3
00008e  f8c92010          STR      r2,[r9,#0x10]
                  |L2.146|
;;;519        }
;;;520      } 
;;;521      /* Return the write protection operation Status */
;;;522      return status;       
;;;523    }
000092  e8bd83f0          POP      {r4-r9,pc}
;;;524    
                          ENDP

000096  0000              DCW      0x0000
                  |L2.152|
                          DCD      0x45670123
                  |L2.156|
                          DCD      0x40022000
                  |L2.160|
                          DCD      0xcdef89ab
                  |L2.164|
                          DCD      0x1ffff000

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;242      */
;;;243    FLASH_Status FLASH_EraseAllPages(void)
000000  b530              PUSH     {r4,r5,lr}
;;;244    {
;;;245      FLASH_Status status = FLASH_COMPLETE;
;;;246      /* Wait for last operation to be completed */
;;;247      status = FLASH_WaitForLastOperation(EraseTimeout);
000002  f64075ff          MOV      r5,#0xfff
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;248      
;;;249      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d112              BNE      |L3.54|
;;;250      {
;;;251        /* if the previous operation is completed, proceed to erase all pages */
;;;252         FLASH->CR |= CR_MER_Set;
000010  4c09              LDR      r4,|L3.56|
000012  6920              LDR      r0,[r4,#0x10]
000014  f0400004          ORR      r0,r0,#4
000018  6120              STR      r0,[r4,#0x10]
;;;253         FLASH->CR |= CR_STRT_Set;
00001a  6920              LDR      r0,[r4,#0x10]
00001c  f0400040          ORR      r0,r0,#0x40
000020  6120              STR      r0,[r4,#0x10]
;;;254        
;;;255        /* Wait for last operation to be completed */
;;;256        status = FLASH_WaitForLastOperation(EraseTimeout);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       FLASH_WaitForLastOperation
;;;257        if(status != FLASH_BUSY)
000028  2801              CMP      r0,#1
00002a  d004              BEQ      |L3.54|
;;;258        {
;;;259          /* if the erase operation is completed, disable the MER Bit */
;;;260          FLASH->CR &= CR_MER_Reset;
00002c  6921              LDR      r1,[r4,#0x10]
00002e  f64172fb          MOV      r2,#0x1ffb
000032  4011              ANDS     r1,r1,r2
000034  6121              STR      r1,[r4,#0x10]
                  |L3.54|
;;;261        }
;;;262      }	   
;;;263      /* Return the Erase Status */
;;;264      return status;
;;;265    }
000036  bd30              POP      {r4,r5,pc}
;;;266    
                          ENDP

                  |L3.56|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;273      */
;;;274    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b530              PUSH     {r4,r5,lr}
;;;275    {
;;;276      FLASH_Status status = FLASH_COMPLETE;
;;;277      
;;;278      /* Wait for last operation to be completed */
;;;279      status = FLASH_WaitForLastOperation(EraseTimeout);
000002  f64075ff          MOV      r5,#0xfff
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;280      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d128              BNE      |L4.98|
;;;281      {
;;;282        /* Authorize the small information block programming */
;;;283        FLASH->OPTKEYR = FLASH_KEY1;
000010  4c15              LDR      r4,|L4.104|
000012  4814              LDR      r0,|L4.100|
000014  60a0              STR      r0,[r4,#8]
;;;284        FLASH->OPTKEYR = FLASH_KEY2;
000016  4815              LDR      r0,|L4.108|
000018  60a0              STR      r0,[r4,#8]
;;;285        
;;;286        /* if the previous operation is completed, proceed to erase the option bytes */
;;;287        FLASH->CR |= CR_OPTER_Set;
00001a  6920              LDR      r0,[r4,#0x10]
00001c  f0400020          ORR      r0,r0,#0x20
000020  6120              STR      r0,[r4,#0x10]
;;;288        FLASH->CR |= CR_STRT_Set;
000022  6920              LDR      r0,[r4,#0x10]
000024  f0400040          ORR      r0,r0,#0x40
000028  6120              STR      r0,[r4,#0x10]
;;;289        /* Wait for last operation to be completed */
;;;290        status = FLASH_WaitForLastOperation(EraseTimeout);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;291        
;;;292        if(status == FLASH_COMPLETE)
;;;293        {
;;;294          /* if the erase operation is completed, disable the OPTER Bit */
;;;295          FLASH->CR &= CR_OPTER_Reset;
;;;296           
;;;297          /* Enable the Option Bytes Programming operation */
;;;298          FLASH->CR |= CR_OPTPG_Set;
;;;299          /* Enable the readout access */
;;;300          OB->RDP= RDP_Key; 
;;;301          /* Wait for last operation to be completed */
;;;302          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;303     
;;;304          if(status != FLASH_BUSY)
;;;305          {
;;;306            /* if the program operation is completed, disable the OPTPG Bit */
;;;307            FLASH->CR &= CR_OPTPG_Reset;
000030  f64175ef          MOV      r5,#0x1fef
000034  2804              CMP      r0,#4                 ;292
000036  d10f              BNE      |L4.88|
000038  6920              LDR      r0,[r4,#0x10]         ;295
00003a  f64171df          MOV      r1,#0x1fdf            ;295
00003e  4008              ANDS     r0,r0,r1              ;295
000040  6120              STR      r0,[r4,#0x10]         ;295
000042  6920              LDR      r0,[r4,#0x10]         ;298
000044  f0400010          ORR      r0,r0,#0x10           ;298
000048  6120              STR      r0,[r4,#0x10]         ;298
00004a  4909              LDR      r1,|L4.112|
00004c  20a5              MOVS     r0,#0xa5              ;300
00004e  8008              STRH     r0,[r1,#0]            ;300
000050  f04f000f          MOV      r0,#0xf               ;302
000054  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L4.88|
;;;308          }
;;;309        }
;;;310        else
;;;311        {
;;;312          if (status != FLASH_BUSY)
000058  2801              CMP      r0,#1
00005a  d002              BEQ      |L4.98|
00005c  6921              LDR      r1,[r4,#0x10]         ;307
00005e  4029              ANDS     r1,r1,r5              ;307
000060  6121              STR      r1,[r4,#0x10]         ;307
                  |L4.98|
;;;313          {
;;;314            /* Disable the OPTPG Bit */
;;;315            FLASH->CR &= CR_OPTPG_Reset;
;;;316          }
;;;317        }  
;;;318      }
;;;319      /* Return the erase status */
;;;320      return status;
;;;321    }
000062  bd30              POP      {r4,r5,pc}
;;;322    
                          ENDP

                  |L4.100|
                          DCD      0x45670123
                  |L4.104|
                          DCD      0x40022000
                  |L4.108|
                          DCD      0xcdef89ab
                  |L4.112|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;208      */
;;;209    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;210    {
000002  4605              MOV      r5,r0
;;;211      FLASH_Status status = FLASH_COMPLETE;
;;;212      /* Check the parameters */
;;;213      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;214      /* Wait for last operation to be completed */
;;;215      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f64076ff          MOV      r6,#0xfff
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;216      
;;;217      if(status == FLASH_COMPLETE)
00000e  2804              CMP      r0,#4
000010  d113              BNE      |L5.58|
;;;218      { 
;;;219        /* if the previous operation is completed, proceed to erase the page */
;;;220        FLASH->CR|= CR_PER_Set;
000012  4c0a              LDR      r4,|L5.60|
000014  6920              LDR      r0,[r4,#0x10]
000016  f0400002          ORR      r0,r0,#2
00001a  6120              STR      r0,[r4,#0x10]
;;;221        FLASH->AR = Page_Address; 
00001c  6165              STR      r5,[r4,#0x14]
;;;222        FLASH->CR|= CR_STRT_Set;
00001e  6920              LDR      r0,[r4,#0x10]
000020  f0400040          ORR      r0,r0,#0x40
000024  6120              STR      r0,[r4,#0x10]
;;;223        
;;;224        /* Wait for last operation to be completed */
;;;225        status = FLASH_WaitForLastOperation(EraseTimeout);
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       FLASH_WaitForLastOperation
;;;226        if(status != FLASH_BUSY)
00002c  2801              CMP      r0,#1
00002e  d004              BEQ      |L5.58|
;;;227        {
;;;228          /* if the erase operation is completed, disable the PER Bit */
;;;229          FLASH->CR &= CR_PER_Reset;
000030  6921              LDR      r1,[r4,#0x10]
000032  f64172fd          MOV      r2,#0x1ffd
000036  4011              ANDS     r1,r1,r2
000038  6121              STR      r1,[r4,#0x10]
                  |L5.58|
;;;230        }
;;;231      }
;;;232      /* Return the Erase Status */
;;;233      return status;
;;;234    }
00003a  bd70              POP      {r4-r6,pc}
;;;235    
                          ENDP

                  |L5.60|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;741      */
;;;742    FlagStatus FLASH_GetFlagStatus(uint16_t FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;743    {
;;;744      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;745      /* Check the parameters */
;;;746      assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;747      if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
;;;748      {
;;;749        if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
000004  4a05              LDR      r2,|L6.28|
000006  2901              CMP      r1,#1                 ;747
000008  d003              BEQ      |L6.18|
;;;750        {
;;;751          bitstatus = SET;
;;;752        }
;;;753        else
;;;754        {
;;;755          bitstatus = RESET;
;;;756        }
;;;757      }
;;;758      else
;;;759      {
;;;760       if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
00000a  68d2              LDR      r2,[r2,#0xc]
00000c  420a              TST      r2,r1
00000e  d103              BNE      |L6.24|
                  |L6.16|
;;;761        {
;;;762          bitstatus = SET;
;;;763        }
;;;764        else
;;;765        {
;;;766          bitstatus = RESET;
;;;767        }
;;;768      }
;;;769      /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;770      return bitstatus;
;;;771    }
000010  4770              BX       lr
                  |L6.18|
000012  69d1              LDR      r1,[r2,#0x1c]         ;749
000014  07c9              LSLS     r1,r1,#31             ;749
000016  d0fb              BEQ      |L6.16|
                  |L6.24|
000018  2001              MOVS     r0,#1                 ;751
00001a  4770              BX       lr
;;;772    
                          ENDP

                  |L6.28|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;686      */
;;;687    FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  4903              LDR      r1,|L7.16|
;;;688    {
;;;689      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;690      
;;;691      if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
000004  6809              LDR      r1,[r1,#0]
000006  0689              LSLS     r1,r1,#26
000008  d500              BPL      |L7.12|
;;;692      {
;;;693        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L7.12|
;;;694      }
;;;695      else
;;;696      {
;;;697        bitstatus = RESET;
;;;698      }
;;;699      /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;700      return bitstatus; 
;;;701    }
00000c  4770              BX       lr
;;;702    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;667      */
;;;668    FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  4903              LDR      r1,|L8.16|
;;;669    {
;;;670      FlagStatus readoutstatus = RESET;
000002  2000              MOVS     r0,#0
;;;671      if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
000004  69c9              LDR      r1,[r1,#0x1c]
000006  0789              LSLS     r1,r1,#30
000008  d500              BPL      |L8.12|
;;;672      {
;;;673        readoutstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;674      }
;;;675      else
;;;676      {
;;;677        readoutstatus = RESET;
;;;678      }
;;;679      return readoutstatus;
;;;680    }
00000c  4770              BX       lr
;;;681    
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;797      */
;;;798    FLASH_Status FLASH_GetStatus(void)
000000  4908              LDR      r1,|L9.36|
;;;799    {
;;;800      FLASH_Status flashstatus = FLASH_COMPLETE;
000002  2004              MOVS     r0,#4
;;;801      
;;;802      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000004  68ca              LDR      r2,[r1,#0xc]
000006  07d2              LSLS     r2,r2,#31
000008  d001              BEQ      |L9.14|
;;;803      {
;;;804        flashstatus = FLASH_BUSY;
00000a  2001              MOVS     r0,#1
;;;805      }
;;;806      else 
;;;807      {  
;;;808        if(FLASH->SR & FLASH_FLAG_PGERR)
;;;809        { 
;;;810          flashstatus = FLASH_ERROR_PG;
;;;811        }
;;;812        else 
;;;813        {
;;;814          if(FLASH->SR & FLASH_FLAG_WRPRTERR)
;;;815          {
;;;816            flashstatus = FLASH_ERROR_WRP;
;;;817          }
;;;818          else
;;;819          {
;;;820            flashstatus = FLASH_COMPLETE;
;;;821          }
;;;822        }
;;;823      }
;;;824      /* Return the Flash Status */
;;;825      return flashstatus;
;;;826    }
00000c  4770              BX       lr
                  |L9.14|
00000e  68ca              LDR      r2,[r1,#0xc]          ;808
000010  0752              LSLS     r2,r2,#29             ;808
000012  d501              BPL      |L9.24|
000014  2002              MOVS     r0,#2                 ;810
                  |L9.22|
000016  4770              BX       lr
                  |L9.24|
000018  68c9              LDR      r1,[r1,#0xc]          ;814
00001a  06c9              LSLS     r1,r1,#27             ;814
00001c  d5fb              BPL      |L9.22|
00001e  2003              MOVS     r0,#3                 ;816
000020  4770              BX       lr
;;;827    
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;644      */
;;;645    uint32_t FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L10.8|
;;;646    {
;;;647      /* Return the User Option Byte */
;;;648      return (uint32_t)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;649    }
000006  4770              BX       lr
;;;650    
                          ENDP

                  |L10.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;655      */
;;;656    uint32_t FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L11.8|
;;;657    {
;;;658      /* Return the Falsh write protection Register value */
;;;659      return (uint32_t)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;660    }
000004  4770              BX       lr
;;;661    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;150      */
;;;151    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000000  4904              LDR      r1,|L12.20|
;;;152    {
;;;153      /* Check the parameters */
;;;154      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;155      
;;;156      /* Enable or disable the Half cycle access */
;;;157      FLASH->ACR &= ACR_HLFCYA_Mask;
000002  680a              LDR      r2,[r1,#0]
000004  f0220208          BIC      r2,r2,#8
000008  600a              STR      r2,[r1,#0]
;;;158      FLASH->ACR |= FLASH_HalfCycleAccess;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;159    }
000010  4770              BX       lr
;;;160    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;713      */
;;;714    void FLASH_ITConfig(uint16_t FLASH_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L13.20|
;;;715    {
;;;716      /* Check the parameters */
;;;717      assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;718      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;719      if(NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;720      {
;;;721        /* Enable the interrupt sources */
;;;722        FLASH->CR |= FLASH_IT;
;;;723      }
;;;724      else
;;;725      {
;;;726        /* Disable the interrupt sources */
;;;727        FLASH->CR &= ~(uint32_t)FLASH_IT;
000004  6911              LDR      r1,[r2,#0x10]
000006  d001              BEQ      |L13.12|
000008  4301              ORRS     r1,r1,r0              ;722
00000a  e000              B        |L13.14|
                  |L13.12|
00000c  4381              BICS     r1,r1,r0
                  |L13.14|
00000e  6111              STR      r1,[r2,#0x10]         ;722
;;;728      }
;;;729    }
000010  4770              BX       lr
;;;730    
                          ENDP

000012  0000              DCW      0x0000
                  |L13.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;195      */
;;;196    void FLASH_Lock(void)
000000  4802              LDR      r0,|L14.12|
;;;197    {
;;;198      /* Set the Lock Bit to lock the FPEC and the FCR */
;;;199      FLASH->CR |= CR_LOCK_Set;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410180          ORR      r1,r1,#0x80
000008  6101              STR      r1,[r0,#0x10]
;;;200    }
00000a  4770              BX       lr
;;;201    
                          ENDP

                  |L14.12|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;168      */
;;;169    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000000  4904              LDR      r1,|L15.20|
;;;170    {
;;;171      /* Check the parameters */
;;;172      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;173      
;;;174      /* Enable or disable the Prefetch Buffer */
;;;175      FLASH->ACR &= ACR_PRFTBE_Mask;
000002  680a              LDR      r2,[r1,#0]
000004  f0220210          BIC      r2,r2,#0x10
000008  600a              STR      r2,[r1,#0]
;;;176      FLASH->ACR |= FLASH_PrefetchBuffer;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;177    }
000010  4770              BX       lr
;;;178    
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;384      */
;;;385    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;386    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;387      FLASH_Status status = FLASH_COMPLETE;
;;;388      /* Check the parameters */
;;;389      assert_param(IS_FLASH_ADDRESS(Address));
;;;390      /* Wait for last operation to be completed */
;;;391      status = FLASH_WaitForLastOperation(ProgramTimeout);
000006  200f              MOVS     r0,#0xf
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;392      
;;;393      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d10f              BNE      |L16.48|
;;;394      {
;;;395        /* if the previous operation is completed, proceed to program the new data */
;;;396        FLASH->CR |= CR_PG_Set;
000010  4c08              LDR      r4,|L16.52|
000012  6920              LDR      r0,[r4,#0x10]
000014  f0400001          ORR      r0,r0,#1
000018  6120              STR      r0,[r4,#0x10]
;;;397      
;;;398        *(__IO uint16_t*)Address = Data;
00001a  802e              STRH     r6,[r5,#0]
;;;399        /* Wait for last operation to be completed */
;;;400        status = FLASH_WaitForLastOperation(ProgramTimeout);
00001c  200f              MOVS     r0,#0xf
00001e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;401        if(status != FLASH_BUSY)
000022  2801              CMP      r0,#1
000024  d004              BEQ      |L16.48|
;;;402        {
;;;403          /* if the program operation is completed, disable the PG Bit */
;;;404          FLASH->CR &= CR_PG_Reset;
000026  6921              LDR      r1,[r4,#0x10]
000028  f64172fe          MOV      r2,#0x1ffe
00002c  4011              ANDS     r1,r1,r2
00002e  6121              STR      r1,[r4,#0x10]
                  |L16.48|
;;;405        }
;;;406      } 
;;;407      /* Return the Program Status */
;;;408      return status;
;;;409    }
000030  bd70              POP      {r4-r6,pc}
;;;410    
                          ENDP

000032  0000              DCW      0x0000
                  |L16.52|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;419      */
;;;420    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;421    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;422      FLASH_Status status = FLASH_COMPLETE;
;;;423      /* Check the parameters */
;;;424      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;425      status = FLASH_WaitForLastOperation(ProgramTimeout);
000006  200f              MOVS     r0,#0xf
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;426      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d113              BNE      |L17.56|
;;;427      {
;;;428        /* Authorize the small information block programming */
;;;429        FLASH->OPTKEYR = FLASH_KEY1;
000010  4c0b              LDR      r4,|L17.64|
000012  480a              LDR      r0,|L17.60|
000014  60a0              STR      r0,[r4,#8]
;;;430        FLASH->OPTKEYR = FLASH_KEY2;
000016  480b              LDR      r0,|L17.68|
000018  60a0              STR      r0,[r4,#8]
;;;431        /* Enables the Option Bytes Programming operation */
;;;432        FLASH->CR |= CR_OPTPG_Set; 
00001a  6920              LDR      r0,[r4,#0x10]
00001c  f0400010          ORR      r0,r0,#0x10
000020  6120              STR      r0,[r4,#0x10]
;;;433        *(__IO uint16_t*)Address = Data;
000022  802e              STRH     r6,[r5,#0]
;;;434        
;;;435        /* Wait for last operation to be completed */
;;;436        status = FLASH_WaitForLastOperation(ProgramTimeout);
000024  200f              MOVS     r0,#0xf
000026  f7fffffe          BL       FLASH_WaitForLastOperation
;;;437        if(status != FLASH_BUSY)
00002a  2801              CMP      r0,#1
00002c  d004              BEQ      |L17.56|
;;;438        {
;;;439          /* if the program operation is completed, disable the OPTPG Bit */
;;;440          FLASH->CR &= CR_OPTPG_Reset;
00002e  6921              LDR      r1,[r4,#0x10]
000030  f64172ef          MOV      r2,#0x1fef
000034  4011              ANDS     r1,r1,r2
000036  6121              STR      r1,[r4,#0x10]
                  |L17.56|
;;;441        }
;;;442      }    
;;;443      /* Return the Option Byte Data Program Status */
;;;444      return status;
;;;445    }
000038  bd70              POP      {r4-r6,pc}
;;;446    
                          ENDP

00003a  0000              DCW      0x0000
                  |L17.60|
                          DCD      0x45670123
                  |L17.64|
                          DCD      0x40022000
                  |L17.68|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;330      */
;;;331    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;332    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;333      FLASH_Status status = FLASH_COMPLETE;
;;;334      /* Check the parameters */
;;;335      assert_param(IS_FLASH_ADDRESS(Address));
;;;336      /* Wait for last operation to be completed */
;;;337      status = FLASH_WaitForLastOperation(ProgramTimeout);
000006  200f              MOVS     r0,#0xf
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;338      
;;;339      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d116              BNE      |L18.62|
;;;340      {
;;;341        /* if the previous operation is completed, proceed to program the new first 
;;;342        half word */
;;;343        FLASH->CR |= CR_PG_Set;
000010  4c0b              LDR      r4,|L18.64|
000012  6920              LDR      r0,[r4,#0x10]
000014  f0400001          ORR      r0,r0,#1
000018  6120              STR      r0,[r4,#0x10]
;;;344      
;;;345        *(__IO uint16_t*)Address = (uint16_t)Data;
00001a  8035              STRH     r5,[r6,#0]
;;;346        /* Wait for last operation to be completed */
;;;347        status = FLASH_WaitForLastOperation(ProgramTimeout);
00001c  200f              MOVS     r0,#0xf
00001e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;348     
;;;349        if(status == FLASH_COMPLETE)
;;;350        {
;;;351          /* if the previous operation is completed, proceed to program the new second 
;;;352          half word */
;;;353          *(__IO uint16_t*)(Address + 2) = Data >> 16;
;;;354        
;;;355          /* Wait for last operation to be completed */
;;;356          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;357            
;;;358          if(status != FLASH_BUSY)
;;;359          {
;;;360            /* Disable the PG Bit */
;;;361            FLASH->CR &= CR_PG_Reset;
000022  f64177fe          MOV      r7,#0x1ffe
000026  2804              CMP      r0,#4                 ;349
000028  d104              BNE      |L18.52|
00002a  0c28              LSRS     r0,r5,#16             ;353
00002c  8070              STRH     r0,[r6,#2]            ;353
00002e  200f              MOVS     r0,#0xf               ;356
000030  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L18.52|
;;;362          }
;;;363        }
;;;364        else
;;;365        {
;;;366          if (status != FLASH_BUSY)
000034  2801              CMP      r0,#1
000036  d002              BEQ      |L18.62|
000038  6921              LDR      r1,[r4,#0x10]         ;361
00003a  4039              ANDS     r1,r1,r7              ;361
00003c  6121              STR      r1,[r4,#0x10]         ;361
                  |L18.62|
;;;367          {
;;;368            /* Disable the PG Bit */
;;;369            FLASH->CR &= CR_PG_Reset;
;;;370          }
;;;371         }
;;;372      }
;;;373      /* Return the Program Status */
;;;374      return status;
;;;375    }
00003e  bdf0              POP      {r4-r7,pc}
;;;376    
                          ENDP

                  |L18.64|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;535      */
;;;536    FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;537    {
000002  4606              MOV      r6,r0
;;;538      FLASH_Status status = FLASH_COMPLETE;
;;;539      /* Check the parameters */
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f64075ff          MOV      r5,#0xfff
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;542      if(status == FLASH_COMPLETE)
00000e  2804              CMP      r0,#4
000010  d118              BNE      |L19.68|
;;;543      {
;;;544        /* Authorizes the small information block programming */
;;;545        FLASH->OPTKEYR = FLASH_KEY1;
000012  4c1a              LDR      r4,|L19.124|
000014  4818              LDR      r0,|L19.120|
000016  60a0              STR      r0,[r4,#8]
;;;546        FLASH->OPTKEYR = FLASH_KEY2;
000018  4819              LDR      r0,|L19.128|
00001a  60a0              STR      r0,[r4,#8]
;;;547        FLASH->CR |= CR_OPTER_Set;
00001c  6920              LDR      r0,[r4,#0x10]
00001e  f0400020          ORR      r0,r0,#0x20
000022  6120              STR      r0,[r4,#0x10]
;;;548        FLASH->CR |= CR_STRT_Set;
000024  6920              LDR      r0,[r4,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6120              STR      r0,[r4,#0x10]
;;;549        /* Wait for last operation to be completed */
;;;550        status = FLASH_WaitForLastOperation(EraseTimeout);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;551        if(status == FLASH_COMPLETE)
;;;552        {
;;;553          /* if the erase operation is completed, disable the OPTER Bit */
;;;554          FLASH->CR &= CR_OPTER_Reset;
000032  f64171df          MOV      r1,#0x1fdf
000036  2804              CMP      r0,#4                 ;551
000038  d005              BEQ      |L19.70|
;;;555          /* Enable the Option Bytes Programming operation */
;;;556          FLASH->CR |= CR_OPTPG_Set; 
;;;557          if(NewState != DISABLE)
;;;558          {
;;;559            OB->RDP = 0x00;
;;;560          }
;;;561          else
;;;562          {
;;;563            OB->RDP = RDP_Key;  
;;;564          }
;;;565          /* Wait for last operation to be completed */
;;;566          status = FLASH_WaitForLastOperation(EraseTimeout); 
;;;567        
;;;568          if(status != FLASH_BUSY)
;;;569          {
;;;570            /* if the program operation is completed, disable the OPTPG Bit */
;;;571            FLASH->CR &= CR_OPTPG_Reset;
;;;572          }
;;;573        }
;;;574        else 
;;;575        {
;;;576          if(status != FLASH_BUSY)
00003a  2801              CMP      r0,#1
00003c  d002              BEQ      |L19.68|
;;;577          {
;;;578            /* Disable the OPTER Bit */
;;;579            FLASH->CR &= CR_OPTER_Reset;
00003e  6922              LDR      r2,[r4,#0x10]
000040  400a              ANDS     r2,r2,r1
000042  6122              STR      r2,[r4,#0x10]
                  |L19.68|
;;;580          }
;;;581        }
;;;582      }
;;;583      /* Return the protection operation Status */
;;;584      return status;      
;;;585    }
000044  bd70              POP      {r4-r6,pc}
                  |L19.70|
000046  6920              LDR      r0,[r4,#0x10]         ;554
000048  4008              ANDS     r0,r0,r1              ;554
00004a  6120              STR      r0,[r4,#0x10]         ;554
00004c  6921              LDR      r1,[r4,#0x10]         ;556
00004e  480d              LDR      r0,|L19.132|
000050  f0410110          ORR      r1,r1,#0x10           ;556
000054  6121              STR      r1,[r4,#0x10]         ;556
000056  b10e              CBZ      r6,|L19.92|
000058  2100              MOVS     r1,#0                 ;559
00005a  e000              B        |L19.94|
                  |L19.92|
00005c  21a5              MOVS     r1,#0xa5              ;563
                  |L19.94|
00005e  f8a01800          STRH     r1,[r0,#0x800]        ;563
000062  4628              MOV      r0,r5                 ;566
000064  f7fffffe          BL       FLASH_WaitForLastOperation
000068  2801              CMP      r0,#1                 ;568
00006a  d0eb              BEQ      |L19.68|
00006c  6921              LDR      r1,[r4,#0x10]         ;571
00006e  f64172ef          MOV      r2,#0x1fef            ;571
000072  4011              ANDS     r1,r1,r2              ;571
000074  6121              STR      r1,[r4,#0x10]         ;571
000076  bd70              POP      {r4-r6,pc}
;;;586    
                          ENDP

                  |L19.120|
                          DCD      0x45670123
                  |L19.124|
                          DCD      0x40022000
                  |L19.128|
                          DCD      0xcdef89ab
                  |L19.132|
                          DCD      0x1ffff000

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;124      */
;;;125    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4a03              LDR      r2,|L20.16|
;;;126    {
;;;127      uint32_t tmpreg = 0;
;;;128      
;;;129      /* Check the parameters */
;;;130      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;131      
;;;132      /* Read the ACR register */
;;;133      tmpreg = FLASH->ACR;  
000002  6811              LDR      r1,[r2,#0]
;;;134      
;;;135      /* Sets the Latency value */
;;;136      tmpreg &= ACR_LATENCY_Mask;
000004  f0010138          AND      r1,r1,#0x38
;;;137      tmpreg |= FLASH_Latency;
000008  4301              ORRS     r1,r1,r0
;;;138      
;;;139      /* Write the ACR register */
;;;140      FLASH->ACR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;141    }
00000c  4770              BX       lr
;;;142    
                          ENDP

00000e  0000              DCW      0x0000
                  |L20.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;183      */
;;;184    void FLASH_Unlock(void)
000000  4803              LDR      r0,|L21.16|
;;;185    {
;;;186      /* Authorize the FPEC Access */
;;;187      FLASH->KEYR = FLASH_KEY1;
000002  4902              LDR      r1,|L21.12|
000004  6041              STR      r1,[r0,#4]
;;;188      FLASH->KEYR = FLASH_KEY2;
000006  4903              LDR      r1,|L21.20|
000008  6041              STR      r1,[r0,#4]
;;;189    }
00000a  4770              BX       lr
;;;190    
                          ENDP

                  |L21.12|
                          DCD      0x45670123
                  |L21.16|
                          DCD      0x40022000
                  |L21.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;605      */
;;;606    FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000000  b5f0              PUSH     {r4-r7,lr}
;;;607    {
;;;608      FLASH_Status status = FLASH_COMPLETE; 
;;;609      /* Check the parameters */
;;;610      assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;611      assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;612      assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;613      /* Authorize the small information block programming */
;;;614      FLASH->OPTKEYR = FLASH_KEY1;
000002  4c12              LDR      r4,|L22.76|
000004  4605              MOV      r5,r0                 ;607
000006  4810              LDR      r0,|L22.72|
000008  460e              MOV      r6,r1                 ;607
00000a  4617              MOV      r7,r2                 ;607
00000c  60a0              STR      r0,[r4,#8]
;;;615      FLASH->OPTKEYR = FLASH_KEY2;
00000e  4810              LDR      r0,|L22.80|
000010  60a0              STR      r0,[r4,#8]
;;;616      
;;;617      /* Wait for last operation to be completed */
;;;618      status = FLASH_WaitForLastOperation(ProgramTimeout);
000012  200f              MOVS     r0,#0xf
000014  f7fffffe          BL       FLASH_WaitForLastOperation
;;;619      
;;;620      if(status == FLASH_COMPLETE)
000018  2804              CMP      r0,#4
00001a  d114              BNE      |L22.70|
;;;621      {  
;;;622        /* Enable the Option Bytes Programming operation */
;;;623        FLASH->CR |= CR_OPTPG_Set; 
00001c  6920              LDR      r0,[r4,#0x10]
00001e  f0400010          ORR      r0,r0,#0x10
000022  6120              STR      r0,[r4,#0x10]
;;;624               
;;;625        OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (uint16_t)0xF8; 
000024  4335              ORRS     r5,r5,r6
000026  490b              LDR      r1,|L22.84|
000028  433d              ORRS     r5,r5,r7
00002a  f04500f8          ORR      r0,r5,#0xf8
00002e  8008              STRH     r0,[r1,#0]
;;;626      
;;;627        /* Wait for last operation to be completed */
;;;628        status = FLASH_WaitForLastOperation(ProgramTimeout);
000030  f04f000f          MOV      r0,#0xf
000034  f7fffffe          BL       FLASH_WaitForLastOperation
;;;629        if(status != FLASH_BUSY)
000038  2801              CMP      r0,#1
00003a  d004              BEQ      |L22.70|
;;;630        {
;;;631          /* if the program operation is completed, disable the OPTPG Bit */
;;;632          FLASH->CR &= CR_OPTPG_Reset;
00003c  6921              LDR      r1,[r4,#0x10]
00003e  f64172ef          MOV      r2,#0x1fef
000042  4011              ANDS     r1,r1,r2
000044  6121              STR      r1,[r4,#0x10]
                  |L22.70|
;;;633        }
;;;634      }    
;;;635      /* Return the Option Byte program Status */
;;;636      return status;
;;;637    }
000046  bdf0              POP      {r4-r7,pc}
;;;638    
                          ENDP

                  |L22.72|
                          DCD      0x45670123
                  |L22.76|
                          DCD      0x40022000
                  |L22.80|
                          DCD      0xcdef89ab
                  |L22.84|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;834      */
;;;835    FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;836    { 
000002  4603              MOV      r3,r0
;;;837      FLASH_Status status = FLASH_COMPLETE;
;;;838       
;;;839      /* Check for the Flash Status */
;;;840      status = FLASH_GetStatus();
000004  f7fffffe          BL       FLASH_GetStatus
;;;841      /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;842      while((status == FLASH_BUSY) && (Timeout != 0x00))
000008  e005              B        |L23.22|
                  |L23.10|
00000a  20ff              MOVS     r0,#0xff
                  |L23.12|
00000c  1e40              SUBS     r0,r0,#1
00000e  d1fd              BNE      |L23.12|
;;;843      {
;;;844        delay();
;;;845        status = FLASH_GetStatus();
000010  f7fffffe          BL       FLASH_GetStatus
;;;846        Timeout--;
000014  1e5b              SUBS     r3,r3,#1
                  |L23.22|
000016  2801              CMP      r0,#1                 ;842
000018  d003              BEQ      |L23.34|
;;;847      }
;;;848      if(Timeout == 0x00 )
00001a  2b00              CMP      r3,#0
00001c  d100              BNE      |L23.32|
                  |L23.30|
;;;849      {
;;;850        status = FLASH_TIMEOUT;
00001e  2005              MOVS     r0,#5
                  |L23.32|
;;;851      }
;;;852      /* Return the operation status */
;;;853      return status;
;;;854    }
000020  bd00              POP      {pc}
                  |L23.34|
000022  2b00              CMP      r3,#0                 ;842
000024  d1f1              BNE      |L23.10|
000026  e7fa              B        |L23.30|
;;;855    
                          ENDP

