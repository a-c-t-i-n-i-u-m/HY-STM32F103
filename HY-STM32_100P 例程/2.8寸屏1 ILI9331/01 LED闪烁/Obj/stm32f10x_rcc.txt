; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\stm32f10x_rcc.o --depend=.\Obj\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Obj\stm32f10x_rcc.crf FWlib\SRC\stm32f10x_rcc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;178      */
;;;179    void RCC_DeInit(void)
000000  48da              LDR      r0,|L1.876|
;;;180    {
;;;181      /* Set HSION bit */
;;;182      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  49d8              LDR      r1,|L1.876|
00000a  6008              STR      r0,[r1,#0]
;;;183      /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
;;;184      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000c  4608              MOV      r0,r1
00000e  6840              LDR      r0,[r0,#4]
000010  49d7              LDR      r1,|L1.880|
000012  4008              ANDS     r0,r0,r1
000014  49d5              LDR      r1,|L1.876|
000016  6048              STR      r0,[r1,#4]
;;;185      
;;;186      /* Reset HSEON, CSSON and PLLON bits */
;;;187      RCC->CR &= (uint32_t)0xFEF6FFFF;
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  49d5              LDR      r1,|L1.884|
00001e  4008              ANDS     r0,r0,r1
000020  49d2              LDR      r1,|L1.876|
000022  6008              STR      r0,[r1,#0]
;;;188      /* Reset HSEBYP bit */
;;;189      RCC->CR &= (uint32_t)0xFFFBFFFF;
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  f4202080          BIC      r0,r0,#0x40000
00002c  6008              STR      r0,[r1,#0]
;;;190      /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
;;;191      RCC->CFGR &= (uint32_t)0xFF80FFFF;
00002e  4608              MOV      r0,r1
000030  6840              LDR      r0,[r0,#4]
000032  f42000fe          BIC      r0,r0,#0x7f0000
000036  6048              STR      r0,[r1,#4]
;;;192      /* Disable all interrupts */
;;;193      RCC->CIR = 0x00000000;
000038  2000              MOVS     r0,#0
00003a  6088              STR      r0,[r1,#8]
;;;194    }
00003c  4770              BX       lr
;;;195    
                          ENDP

                  RCC_HSEConfig PROC
;;;207      */
;;;208    void RCC_HSEConfig(uint32_t RCC_HSE)
00003e  49cb              LDR      r1,|L1.876|
;;;209    {
;;;210      /* Check the parameters */
;;;211      assert_param(IS_RCC_HSE(RCC_HSE));
;;;212      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;213      /* Reset HSEON bit */
;;;214      RCC->CR &= CR_HSEON_Reset;
000040  6809              LDR      r1,[r1,#0]
000042  f4213180          BIC      r1,r1,#0x10000
000046  4ac9              LDR      r2,|L1.876|
000048  6011              STR      r1,[r2,#0]
;;;215      /* Reset HSEBYP bit */
;;;216      RCC->CR &= CR_HSEBYP_Reset;
00004a  4611              MOV      r1,r2
00004c  6809              LDR      r1,[r1,#0]
00004e  f4212180          BIC      r1,r1,#0x40000
000052  6011              STR      r1,[r2,#0]
;;;217      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;218      switch(RCC_HSE)
000054  f5b03f80          CMP      r0,#0x10000
000058  d003              BEQ      |L1.98|
00005a  f5b02f80          CMP      r0,#0x40000
00005e  d10e              BNE      |L1.126|
000060  e006              B        |L1.112|
                  |L1.98|
;;;219      {
;;;220        case RCC_HSE_ON:
;;;221          /* Set HSEON bit */
;;;222          RCC->CR |= CR_HSEON_Set;
000062  49c2              LDR      r1,|L1.876|
000064  6809              LDR      r1,[r1,#0]
000066  f4413180          ORR      r1,r1,#0x10000
00006a  4ac0              LDR      r2,|L1.876|
00006c  6011              STR      r1,[r2,#0]
;;;223          break;
00006e  e007              B        |L1.128|
                  |L1.112|
;;;224          
;;;225        case RCC_HSE_Bypass:
;;;226          /* Set HSEBYP and HSEON bits */
;;;227          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000070  49be              LDR      r1,|L1.876|
000072  6809              LDR      r1,[r1,#0]
000074  f44121a0          ORR      r1,r1,#0x50000
000078  4abc              LDR      r2,|L1.876|
00007a  6011              STR      r1,[r2,#0]
;;;228          break;
00007c  e000              B        |L1.128|
                  |L1.126|
;;;229          
;;;230        default:
;;;231          break;
00007e  bf00              NOP      
                  |L1.128|
000080  bf00              NOP                            ;223
;;;232      }
;;;233    }
000082  4770              BX       lr
;;;234    
                          ENDP

                  RCC_GetFlagStatus PROC
;;;905      */
;;;906    FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000084  b510              PUSH     {r4,lr}
;;;907    {
000086  4601              MOV      r1,r0
;;;908      uint32_t tmp = 0;
000088  2200              MOVS     r2,#0
;;;909      uint32_t statusreg = 0;
00008a  2300              MOVS     r3,#0
;;;910      FlagStatus bitstatus = RESET;
00008c  2000              MOVS     r0,#0
;;;911      /* Check the parameters */
;;;912      assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;913      /* Get the RCC register index */
;;;914      tmp = RCC_FLAG >> 5;
00008e  114a              ASRS     r2,r1,#5
;;;915      if (tmp == 1)               /* The flag to check is in CR register */
000090  2a01              CMP      r2,#1
000092  d102              BNE      |L1.154|
;;;916      {
;;;917        statusreg = RCC->CR;
000094  4cb5              LDR      r4,|L1.876|
000096  6823              LDR      r3,[r4,#0]
000098  e006              B        |L1.168|
                  |L1.154|
;;;918      }
;;;919      else if (tmp == 2)          /* The flag to check is in BDCR register */
00009a  2a02              CMP      r2,#2
00009c  d102              BNE      |L1.164|
;;;920      {
;;;921        statusreg = RCC->BDCR;
00009e  4cb3              LDR      r4,|L1.876|
0000a0  6a23              LDR      r3,[r4,#0x20]
0000a2  e001              B        |L1.168|
                  |L1.164|
;;;922      }
;;;923      else                       /* The flag to check is in CSR register */
;;;924      {
;;;925        statusreg = RCC->CSR;
0000a4  4cb1              LDR      r4,|L1.876|
0000a6  6a63              LDR      r3,[r4,#0x24]
                  |L1.168|
;;;926      }
;;;927      /* Get the flag position */
;;;928      tmp = RCC_FLAG & FLAG_Mask;
0000a8  f001021f          AND      r2,r1,#0x1f
;;;929      if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
0000ac  2401              MOVS     r4,#1
0000ae  4094              LSLS     r4,r4,r2
0000b0  421c              TST      r4,r3
0000b2  d001              BEQ      |L1.184|
;;;930      {
;;;931        bitstatus = SET;
0000b4  2001              MOVS     r0,#1
0000b6  e000              B        |L1.186|
                  |L1.184|
;;;932      }
;;;933      else
;;;934      {
;;;935        bitstatus = RESET;
0000b8  2000              MOVS     r0,#0
                  |L1.186|
;;;936      }
;;;937      /* Return the flag status */
;;;938      return bitstatus;
;;;939    }
0000ba  bd10              POP      {r4,pc}
;;;940    
                          ENDP

                  RCC_WaitForHSEStartUp PROC
;;;241      */
;;;242    ErrorStatus RCC_WaitForHSEStartUp(void)
0000bc  b570              PUSH     {r4-r6,lr}
;;;243    {
;;;244      __IO uint32_t StartUpCounter = 0;
0000be  2400              MOVS     r4,#0
;;;245      ErrorStatus status = ERROR;
0000c0  2500              MOVS     r5,#0
;;;246      FlagStatus HSEStatus = RESET;
0000c2  2600              MOVS     r6,#0
;;;247      
;;;248      /* Wait till HSE is ready and if Time out is reached exit */
;;;249      do
0000c4  bf00              NOP      
                  |L1.198|
;;;250      {
;;;251        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
0000c6  2031              MOVS     r0,#0x31
0000c8  f7fffffe          BL       RCC_GetFlagStatus
0000cc  4606              MOV      r6,r0
;;;252        StartUpCounter++;  
0000ce  1c64              ADDS     r4,r4,#1
;;;253      } while((HSEStatus == RESET) && (StartUpCounter != HSEStartUp_TimeOut));
0000d0  b916              CBNZ     r6,|L1.216|
0000d2  f5b46fa0          CMP      r4,#0x500
0000d6  d1f6              BNE      |L1.198|
                  |L1.216|
;;;254      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
0000d8  2031              MOVS     r0,#0x31
0000da  f7fffffe          BL       RCC_GetFlagStatus
0000de  b108              CBZ      r0,|L1.228|
;;;255      {
;;;256        status = SUCCESS;
0000e0  2501              MOVS     r5,#1
0000e2  e000              B        |L1.230|
                  |L1.228|
;;;257      }
;;;258      else
;;;259      {
;;;260        status = ERROR;
0000e4  2500              MOVS     r5,#0
                  |L1.230|
;;;261      }  
;;;262      return (status);
0000e6  4628              MOV      r0,r5
;;;263    }
0000e8  bd70              POP      {r4-r6,pc}
;;;264    
                          ENDP

                  RCC_AdjustHSICalibrationValue PROC
;;;271      */
;;;272    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
0000ea  4601              MOV      r1,r0
;;;273    {
;;;274      uint32_t tmpreg = 0;
0000ec  2000              MOVS     r0,#0
;;;275      /* Check the parameters */
;;;276      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;277      tmpreg = RCC->CR;
0000ee  4a9f              LDR      r2,|L1.876|
0000f0  6810              LDR      r0,[r2,#0]
;;;278      /* Clear HSITRIM[4:0] bits */
;;;279      tmpreg &= CR_HSITRIM_Mask;
0000f2  f02000f8          BIC      r0,r0,#0xf8
;;;280      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;281      tmpreg |= (uint32_t)HSICalibrationValue << 3;
0000f6  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;282      /* Store the new value */
;;;283      RCC->CR = tmpreg;
0000fa  6010              STR      r0,[r2,#0]
;;;284    }
0000fc  4770              BX       lr
;;;285    
                          ENDP

                  RCC_HSICmd PROC
;;;293      */
;;;294    void RCC_HSICmd(FunctionalState NewState)
0000fe  499e              LDR      r1,|L1.888|
;;;295    {
;;;296      /* Check the parameters */
;;;297      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;298      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000100  6008              STR      r0,[r1,#0]
;;;299    }
000102  4770              BX       lr
;;;300    
                          ENDP

                  RCC_PLLConfig PROC
;;;315      */
;;;316    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000104  4602              MOV      r2,r0
;;;317    {
;;;318      uint32_t tmpreg = 0;
000106  2000              MOVS     r0,#0
;;;319      /* Check the parameters */
;;;320      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;321      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;322      tmpreg = RCC->CFGR;
000108  4b98              LDR      r3,|L1.876|
00010a  6858              LDR      r0,[r3,#4]
;;;323      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;324      tmpreg &= CFGR_PLL_Mask;
00010c  f420107c          BIC      r0,r0,#0x3f0000
;;;325      /* Set the PLL configuration bits */
;;;326      tmpreg |= RCC_PLLSource | RCC_PLLMul;
000110  ea420301          ORR      r3,r2,r1
000114  4318              ORRS     r0,r0,r3
;;;327      /* Store the new value */
;;;328      RCC->CFGR = tmpreg;
000116  4b95              LDR      r3,|L1.876|
000118  6058              STR      r0,[r3,#4]
;;;329    }
00011a  4770              BX       lr
;;;330    
                          ENDP

                  RCC_PLLCmd PROC
;;;337      */
;;;338    void RCC_PLLCmd(FunctionalState NewState)
00011c  4996              LDR      r1,|L1.888|
;;;339    {
;;;340      /* Check the parameters */
;;;341      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;342      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
00011e  6608              STR      r0,[r1,#0x60]
;;;343    }
000120  4770              BX       lr
;;;344    
                          ENDP

                  RCC_SYSCLKConfig PROC
;;;353      */
;;;354    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000122  4601              MOV      r1,r0
;;;355    {
;;;356      uint32_t tmpreg = 0;
000124  2000              MOVS     r0,#0
;;;357      /* Check the parameters */
;;;358      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;359      tmpreg = RCC->CFGR;
000126  4a91              LDR      r2,|L1.876|
000128  6850              LDR      r0,[r2,#4]
;;;360      /* Clear SW[1:0] bits */
;;;361      tmpreg &= CFGR_SW_Mask;
00012a  f0200003          BIC      r0,r0,#3
;;;362      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;363      tmpreg |= RCC_SYSCLKSource;
00012e  4308              ORRS     r0,r0,r1
;;;364      /* Store the new value */
;;;365      RCC->CFGR = tmpreg;
000130  6050              STR      r0,[r2,#4]
;;;366    }
000132  4770              BX       lr
;;;367    
                          ENDP

                  RCC_GetSYSCLKSource PROC
;;;376      */
;;;377    uint8_t RCC_GetSYSCLKSource(void)
000134  488d              LDR      r0,|L1.876|
;;;378    {
;;;379      return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
000136  6840              LDR      r0,[r0,#4]
000138  f000000c          AND      r0,r0,#0xc
;;;380    }
00013c  4770              BX       lr
;;;381    
                          ENDP

                  RCC_HCLKConfig PROC
;;;397      */
;;;398    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
00013e  4601              MOV      r1,r0
;;;399    {
;;;400      uint32_t tmpreg = 0;
000140  2000              MOVS     r0,#0
;;;401      /* Check the parameters */
;;;402      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;403      tmpreg = RCC->CFGR;
000142  4a8a              LDR      r2,|L1.876|
000144  6850              LDR      r0,[r2,#4]
;;;404      /* Clear HPRE[3:0] bits */
;;;405      tmpreg &= CFGR_HPRE_Reset_Mask;
000146  f02000f0          BIC      r0,r0,#0xf0
;;;406      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;407      tmpreg |= RCC_SYSCLK;
00014a  4308              ORRS     r0,r0,r1
;;;408      /* Store the new value */
;;;409      RCC->CFGR = tmpreg;
00014c  6050              STR      r0,[r2,#4]
;;;410    }
00014e  4770              BX       lr
;;;411    
                          ENDP

                  RCC_PCLK1Config PROC
;;;423      */
;;;424    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000150  4601              MOV      r1,r0
;;;425    {
;;;426      uint32_t tmpreg = 0;
000152  2000              MOVS     r0,#0
;;;427      /* Check the parameters */
;;;428      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;429      tmpreg = RCC->CFGR;
000154  4a85              LDR      r2,|L1.876|
000156  6850              LDR      r0,[r2,#4]
;;;430      /* Clear PPRE1[2:0] bits */
;;;431      tmpreg &= CFGR_PPRE1_Reset_Mask;
000158  f42060e0          BIC      r0,r0,#0x700
;;;432      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;433      tmpreg |= RCC_HCLK;
00015c  4308              ORRS     r0,r0,r1
;;;434      /* Store the new value */
;;;435      RCC->CFGR = tmpreg;
00015e  6050              STR      r0,[r2,#4]
;;;436    }
000160  4770              BX       lr
;;;437    
                          ENDP

                  RCC_PCLK2Config PROC
;;;449      */
;;;450    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000162  4601              MOV      r1,r0
;;;451    {
;;;452      uint32_t tmpreg = 0;
000164  2000              MOVS     r0,#0
;;;453      /* Check the parameters */
;;;454      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;455      tmpreg = RCC->CFGR;
000166  4a81              LDR      r2,|L1.876|
000168  6850              LDR      r0,[r2,#4]
;;;456      /* Clear PPRE2[2:0] bits */
;;;457      tmpreg &= CFGR_PPRE2_Reset_Mask;
00016a  f4205060          BIC      r0,r0,#0x3800
;;;458      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;459      tmpreg |= RCC_HCLK << 3;
00016e  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;460      /* Store the new value */
;;;461      RCC->CFGR = tmpreg;
000172  6050              STR      r0,[r2,#4]
;;;462    }
000174  4770              BX       lr
;;;463    
                          ENDP

                  RCC_ITConfig PROC
;;;476      */
;;;477    void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000176  b129              CBZ      r1,|L1.388|
;;;478    {
;;;479      /* Check the parameters */
;;;480      assert_param(IS_RCC_IT(RCC_IT));
;;;481      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;482      if (NewState != DISABLE)
;;;483      {
;;;484        /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
;;;485        *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
000178  4a7c              LDR      r2,|L1.876|
00017a  7a52              LDRB     r2,[r2,#9]
00017c  4302              ORRS     r2,r2,r0
00017e  4b7b              LDR      r3,|L1.876|
000180  725a              STRB     r2,[r3,#9]
000182  e006              B        |L1.402|
                  |L1.388|
;;;486      }
;;;487      else
;;;488      {
;;;489        /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
;;;490        *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000184  4a79              LDR      r2,|L1.876|
000186  7a52              LDRB     r2,[r2,#9]
000188  43c3              MVNS     r3,r0
00018a  b2db              UXTB     r3,r3
00018c  401a              ANDS     r2,r2,r3
00018e  4b77              LDR      r3,|L1.876|
000190  725a              STRB     r2,[r3,#9]
                  |L1.402|
;;;491      }
;;;492    }
000192  4770              BX       lr
;;;493    
                          ENDP

                  RCC_USBCLKConfig PROC
;;;503      */
;;;504    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
000194  4979              LDR      r1,|L1.892|
;;;505    {
;;;506      /* Check the parameters */
;;;507      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;508      *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000196  6008              STR      r0,[r1,#0]
;;;509    }
000198  4770              BX       lr
;;;510    
                          ENDP

                  RCC_ADCCLKConfig PROC
;;;521      */
;;;522    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
00019a  4601              MOV      r1,r0
;;;523    {
;;;524      uint32_t tmpreg = 0;
00019c  2000              MOVS     r0,#0
;;;525      /* Check the parameters */
;;;526      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;527      tmpreg = RCC->CFGR;
00019e  4a73              LDR      r2,|L1.876|
0001a0  6850              LDR      r0,[r2,#4]
;;;528      /* Clear ADCPRE[1:0] bits */
;;;529      tmpreg &= CFGR_ADCPRE_Reset_Mask;
0001a2  f4204040          BIC      r0,r0,#0xc000
;;;530      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;531      tmpreg |= RCC_PCLK2;
0001a6  4308              ORRS     r0,r0,r1
;;;532      /* Store the new value */
;;;533      RCC->CFGR = tmpreg;
0001a8  6050              STR      r0,[r2,#4]
;;;534    }
0001aa  4770              BX       lr
;;;535    
                          ENDP

                  RCC_LSEConfig PROC
;;;545      */
;;;546    void RCC_LSEConfig(uint8_t RCC_LSE)
0001ac  2100              MOVS     r1,#0
;;;547    {
;;;548      /* Check the parameters */
;;;549      assert_param(IS_RCC_LSE(RCC_LSE));
;;;550      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;551      /* Reset LSEON bit */
;;;552      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0001ae  4a74              LDR      r2,|L1.896|
0001b0  7011              STRB     r1,[r2,#0]
;;;553      /* Reset LSEBYP bit */
;;;554      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0001b2  4a6e              LDR      r2,|L1.876|
0001b4  f8821020          STRB     r1,[r2,#0x20]
;;;555      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;556      switch(RCC_LSE)
0001b8  2801              CMP      r0,#1
0001ba  d002              BEQ      |L1.450|
0001bc  2804              CMP      r0,#4
0001be  d108              BNE      |L1.466|
0001c0  e003              B        |L1.458|
                  |L1.450|
;;;557      {
;;;558        case RCC_LSE_ON:
;;;559          /* Set LSEON bit */
;;;560          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
0001c2  2101              MOVS     r1,#1
0001c4  4a6e              LDR      r2,|L1.896|
0001c6  7011              STRB     r1,[r2,#0]
;;;561          break;
0001c8  e004              B        |L1.468|
                  |L1.458|
;;;562          
;;;563        case RCC_LSE_Bypass:
;;;564          /* Set LSEBYP and LSEON bits */
;;;565          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
0001ca  2105              MOVS     r1,#5
0001cc  4a6c              LDR      r2,|L1.896|
0001ce  7011              STRB     r1,[r2,#0]
;;;566          break;            
0001d0  e000              B        |L1.468|
                  |L1.466|
;;;567          
;;;568        default:
;;;569          break;      
0001d2  bf00              NOP      
                  |L1.468|
0001d4  bf00              NOP                            ;561
;;;570      }
;;;571    }
0001d6  4770              BX       lr
;;;572    
                          ENDP

                  RCC_LSICmd PROC
;;;579      */
;;;580    void RCC_LSICmd(FunctionalState NewState)
0001d8  496a              LDR      r1,|L1.900|
;;;581    {
;;;582      /* Check the parameters */
;;;583      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;584      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
0001da  6008              STR      r0,[r1,#0]
;;;585    }
0001dc  4770              BX       lr
;;;586    
                          ENDP

                  RCC_RTCCLKConfig PROC
;;;598      */
;;;599    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
0001de  4963              LDR      r1,|L1.876|
;;;600    {
;;;601      /* Check the parameters */
;;;602      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;603      /* Select the RTC clock source */
;;;604      RCC->BDCR |= RCC_RTCCLKSource;
0001e0  6a09              LDR      r1,[r1,#0x20]
0001e2  4301              ORRS     r1,r1,r0
0001e4  4a61              LDR      r2,|L1.876|
0001e6  6211              STR      r1,[r2,#0x20]
;;;605    }
0001e8  4770              BX       lr
;;;606    
                          ENDP

                  RCC_RTCCLKCmd PROC
;;;614      */
;;;615    void RCC_RTCCLKCmd(FunctionalState NewState)
0001ea  4967              LDR      r1,|L1.904|
;;;616    {
;;;617      /* Check the parameters */
;;;618      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;619      *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
0001ec  6008              STR      r0,[r1,#0]
;;;620    }
0001ee  4770              BX       lr
;;;621    
                          ENDP

                  RCC_GetClocksFreq PROC
;;;627      */
;;;628    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
0001f0  b530              PUSH     {r4,r5,lr}
;;;629    {
;;;630      uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
0001f2  2100              MOVS     r1,#0
0001f4  2200              MOVS     r2,#0
0001f6  2400              MOVS     r4,#0
0001f8  2300              MOVS     r3,#0
;;;631      /* Get SYSCLK source -------------------------------------------------------*/
;;;632      tmp = RCC->CFGR & CFGR_SWS_Mask;
0001fa  4d5c              LDR      r5,|L1.876|
0001fc  686d              LDR      r5,[r5,#4]
0001fe  f005010c          AND      r1,r5,#0xc
;;;633      switch (tmp)
000202  b121              CBZ      r1,|L1.526|
000204  2904              CMP      r1,#4
000206  d005              BEQ      |L1.532|
000208  2908              CMP      r1,#8
00020a  d123              BNE      |L1.596|
00020c  e005              B        |L1.538|
                  |L1.526|
;;;634      {
;;;635        case 0x00:  /* HSI used as system clock */
;;;636          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
00020e  4d5f              LDR      r5,|L1.908|
000210  6005              STR      r5,[r0,#0]
;;;637          break;
000212  e022              B        |L1.602|
                  |L1.532|
;;;638        case 0x04:  /* HSE used as system clock */
;;;639          RCC_Clocks->SYSCLK_Frequency = HSE_Value;
000214  4d5d              LDR      r5,|L1.908|
000216  6005              STR      r5,[r0,#0]
;;;640          break;
000218  e01f              B        |L1.602|
                  |L1.538|
;;;641        case 0x08:  /* PLL used as system clock */
;;;642          /* Get PLL clock source and multiplication factor ----------------------*/
;;;643          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
00021a  4d54              LDR      r5,|L1.876|
00021c  686d              LDR      r5,[r5,#4]
00021e  f4051270          AND      r2,r5,#0x3c0000
;;;644          pllmull = ( pllmull >> 18) + 2;
000222  2502              MOVS     r5,#2
000224  eb054292          ADD      r2,r5,r2,LSR #18
;;;645          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
000228  4d50              LDR      r5,|L1.876|
00022a  686d              LDR      r5,[r5,#4]
00022c  f4053480          AND      r4,r5,#0x10000
;;;646          if (pllsource == 0x00)
000230  b91c              CBNZ     r4,|L1.570|
;;;647          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;648            RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
000232  4d57              LDR      r5,|L1.912|
000234  4355              MULS     r5,r2,r5
000236  6005              STR      r5,[r0,#0]
000238  e00b              B        |L1.594|
                  |L1.570|
;;;649          }
;;;650          else
;;;651          {/* HSE selected as PLL clock entry */
;;;652            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
00023a  4d4c              LDR      r5,|L1.876|
00023c  686d              LDR      r5,[r5,#4]
00023e  f4153f00          TST      r5,#0x20000
000242  d003              BEQ      |L1.588|
;;;653            {/* HSE oscillator clock divided by 2 */
;;;654              RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
000244  4d52              LDR      r5,|L1.912|
000246  4355              MULS     r5,r2,r5
000248  6005              STR      r5,[r0,#0]
00024a  e002              B        |L1.594|
                  |L1.588|
;;;655            }
;;;656            else
;;;657            {
;;;658              RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
00024c  4d4f              LDR      r5,|L1.908|
00024e  4355              MULS     r5,r2,r5
000250  6005              STR      r5,[r0,#0]
                  |L1.594|
;;;659            }
;;;660          }
;;;661          break;
000252  e002              B        |L1.602|
                  |L1.596|
;;;662        default:
;;;663          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
000254  4d4d              LDR      r5,|L1.908|
000256  6005              STR      r5,[r0,#0]
;;;664          break;
000258  bf00              NOP      
                  |L1.602|
00025a  bf00              NOP                            ;637
;;;665      }
;;;666      /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;667      /* Get HCLK prescaler */
;;;668      tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
00025c  4d43              LDR      r5,|L1.876|
00025e  686d              LDR      r5,[r5,#4]
000260  f00501f0          AND      r1,r5,#0xf0
;;;669      tmp = tmp >> 4;
000264  0909              LSRS     r1,r1,#4
;;;670      presc = APBAHBPrescTable[tmp];
000266  4d4b              LDR      r5,|L1.916|
000268  5c6b              LDRB     r3,[r5,r1]
;;;671      /* HCLK clock frequency */
;;;672      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
00026a  6805              LDR      r5,[r0,#0]
00026c  40dd              LSRS     r5,r5,r3
00026e  6045              STR      r5,[r0,#4]
;;;673      /* Get PCLK1 prescaler */
;;;674      tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
000270  4d3e              LDR      r5,|L1.876|
000272  686d              LDR      r5,[r5,#4]
000274  f40561e0          AND      r1,r5,#0x700
;;;675      tmp = tmp >> 8;
000278  0a09              LSRS     r1,r1,#8
;;;676      presc = APBAHBPrescTable[tmp];
00027a  4d46              LDR      r5,|L1.916|
00027c  5c6b              LDRB     r3,[r5,r1]
;;;677      /* PCLK1 clock frequency */
;;;678      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
00027e  6845              LDR      r5,[r0,#4]
000280  40dd              LSRS     r5,r5,r3
000282  6085              STR      r5,[r0,#8]
;;;679      /* Get PCLK2 prescaler */
;;;680      tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
000284  4d39              LDR      r5,|L1.876|
000286  686d              LDR      r5,[r5,#4]
000288  f4055160          AND      r1,r5,#0x3800
;;;681      tmp = tmp >> 11;
00028c  0ac9              LSRS     r1,r1,#11
;;;682      presc = APBAHBPrescTable[tmp];
00028e  4d41              LDR      r5,|L1.916|
000290  5c6b              LDRB     r3,[r5,r1]
;;;683      /* PCLK2 clock frequency */
;;;684      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
000292  6845              LDR      r5,[r0,#4]
000294  40dd              LSRS     r5,r5,r3
000296  60c5              STR      r5,[r0,#0xc]
;;;685      /* Get ADCCLK prescaler */
;;;686      tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
000298  4d34              LDR      r5,|L1.876|
00029a  686d              LDR      r5,[r5,#4]
00029c  f4054140          AND      r1,r5,#0xc000
;;;687      tmp = tmp >> 14;
0002a0  0b89              LSRS     r1,r1,#14
;;;688      presc = ADCPrescTable[tmp];
0002a2  4d3d              LDR      r5,|L1.920|
0002a4  5c6b              LDRB     r3,[r5,r1]
;;;689      /* ADCCLK clock frequency */
;;;690      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
0002a6  68c5              LDR      r5,[r0,#0xc]
0002a8  fbb5f5f3          UDIV     r5,r5,r3
0002ac  6105              STR      r5,[r0,#0x10]
;;;691    }
0002ae  bd30              POP      {r4,r5,pc}
;;;692    
                          ENDP

                  RCC_AHBPeriphClockCmd PROC
;;;708      */
;;;709    void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
0002b0  b129              CBZ      r1,|L1.702|
;;;710    {
;;;711      /* Check the parameters */
;;;712      assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;713      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;714      if (NewState != DISABLE)
;;;715      {
;;;716        RCC->AHBENR |= RCC_AHBPeriph;
0002b2  4a2e              LDR      r2,|L1.876|
0002b4  6952              LDR      r2,[r2,#0x14]
0002b6  4302              ORRS     r2,r2,r0
0002b8  4b2c              LDR      r3,|L1.876|
0002ba  615a              STR      r2,[r3,#0x14]
0002bc  e004              B        |L1.712|
                  |L1.702|
;;;717      }
;;;718      else
;;;719      {
;;;720        RCC->AHBENR &= ~RCC_AHBPeriph;
0002be  4a2b              LDR      r2,|L1.876|
0002c0  6952              LDR      r2,[r2,#0x14]
0002c2  4382              BICS     r2,r2,r0
0002c4  4b29              LDR      r3,|L1.876|
0002c6  615a              STR      r2,[r3,#0x14]
                  |L1.712|
;;;721      }
;;;722    }
0002c8  4770              BX       lr
;;;723    
                          ENDP

                  RCC_APB2PeriphClockCmd PROC
;;;738      */
;;;739    void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
0002ca  b129              CBZ      r1,|L1.728|
;;;740    {
;;;741      /* Check the parameters */
;;;742      assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;743      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;744      if (NewState != DISABLE)
;;;745      {
;;;746        RCC->APB2ENR |= RCC_APB2Periph;
0002cc  4a27              LDR      r2,|L1.876|
0002ce  6992              LDR      r2,[r2,#0x18]
0002d0  4302              ORRS     r2,r2,r0
0002d2  4b26              LDR      r3,|L1.876|
0002d4  619a              STR      r2,[r3,#0x18]
0002d6  e004              B        |L1.738|
                  |L1.728|
;;;747      }
;;;748      else
;;;749      {
;;;750        RCC->APB2ENR &= ~RCC_APB2Periph;
0002d8  4a24              LDR      r2,|L1.876|
0002da  6992              LDR      r2,[r2,#0x18]
0002dc  4382              BICS     r2,r2,r0
0002de  4b23              LDR      r3,|L1.876|
0002e0  619a              STR      r2,[r3,#0x18]
                  |L1.738|
;;;751      }
;;;752    }
0002e2  4770              BX       lr
;;;753    
                          ENDP

                  RCC_APB1PeriphClockCmd PROC
;;;769      */
;;;770    void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
0002e4  b129              CBZ      r1,|L1.754|
;;;771    {
;;;772      /* Check the parameters */
;;;773      assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;774      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;775      if (NewState != DISABLE)
;;;776      {
;;;777        RCC->APB1ENR |= RCC_APB1Periph;
0002e6  4a21              LDR      r2,|L1.876|
0002e8  69d2              LDR      r2,[r2,#0x1c]
0002ea  4302              ORRS     r2,r2,r0
0002ec  4b1f              LDR      r3,|L1.876|
0002ee  61da              STR      r2,[r3,#0x1c]
0002f0  e004              B        |L1.764|
                  |L1.754|
;;;778      }
;;;779      else
;;;780      {
;;;781        RCC->APB1ENR &= ~RCC_APB1Periph;
0002f2  4a1e              LDR      r2,|L1.876|
0002f4  69d2              LDR      r2,[r2,#0x1c]
0002f6  4382              BICS     r2,r2,r0
0002f8  4b1c              LDR      r3,|L1.876|
0002fa  61da              STR      r2,[r3,#0x1c]
                  |L1.764|
;;;782      }
;;;783    }
0002fc  4770              BX       lr
;;;784    
                          ENDP

                  RCC_APB2PeriphResetCmd PROC
;;;798      */
;;;799    void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
0002fe  b129              CBZ      r1,|L1.780|
;;;800    {
;;;801      /* Check the parameters */
;;;802      assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;803      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;804      if (NewState != DISABLE)
;;;805      {
;;;806        RCC->APB2RSTR |= RCC_APB2Periph;
000300  4a1a              LDR      r2,|L1.876|
000302  68d2              LDR      r2,[r2,#0xc]
000304  4302              ORRS     r2,r2,r0
000306  4b19              LDR      r3,|L1.876|
000308  60da              STR      r2,[r3,#0xc]
00030a  e004              B        |L1.790|
                  |L1.780|
;;;807      }
;;;808      else
;;;809      {
;;;810        RCC->APB2RSTR &= ~RCC_APB2Periph;
00030c  4a17              LDR      r2,|L1.876|
00030e  68d2              LDR      r2,[r2,#0xc]
000310  4382              BICS     r2,r2,r0
000312  4b16              LDR      r3,|L1.876|
000314  60da              STR      r2,[r3,#0xc]
                  |L1.790|
;;;811      }
;;;812    }
000316  4770              BX       lr
;;;813    
                          ENDP

                  RCC_APB1PeriphResetCmd PROC
;;;828      */
;;;829    void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000318  b129              CBZ      r1,|L1.806|
;;;830    {
;;;831      /* Check the parameters */
;;;832      assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;833      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;834      if (NewState != DISABLE)
;;;835      {
;;;836        RCC->APB1RSTR |= RCC_APB1Periph;
00031a  4a14              LDR      r2,|L1.876|
00031c  6912              LDR      r2,[r2,#0x10]
00031e  4302              ORRS     r2,r2,r0
000320  4b12              LDR      r3,|L1.876|
000322  611a              STR      r2,[r3,#0x10]
000324  e004              B        |L1.816|
                  |L1.806|
;;;837      }
;;;838      else
;;;839      {
;;;840        RCC->APB1RSTR &= ~RCC_APB1Periph;
000326  4a11              LDR      r2,|L1.876|
000328  6912              LDR      r2,[r2,#0x10]
00032a  4382              BICS     r2,r2,r0
00032c  4b0f              LDR      r3,|L1.876|
00032e  611a              STR      r2,[r3,#0x10]
                  |L1.816|
;;;841      }
;;;842    }
000330  4770              BX       lr
;;;843    
                          ENDP

                  RCC_BackupResetCmd PROC
;;;849      */
;;;850    void RCC_BackupResetCmd(FunctionalState NewState)
000332  491a              LDR      r1,|L1.924|
;;;851    {
;;;852      /* Check the parameters */
;;;853      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;854      *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000334  6008              STR      r0,[r1,#0]
;;;855    }
000336  4770              BX       lr
;;;856    
                          ENDP

                  RCC_ClockSecuritySystemCmd PROC
;;;862      */
;;;863    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000338  490f              LDR      r1,|L1.888|
;;;864    {
;;;865      /* Check the parameters */
;;;866      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;867      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
00033a  64c8              STR      r0,[r1,#0x4c]
;;;868    }
00033c  4770              BX       lr
;;;869    
                          ENDP

                  RCC_MCOConfig PROC
;;;880      */
;;;881    void RCC_MCOConfig(uint8_t RCC_MCO)
00033e  490b              LDR      r1,|L1.876|
;;;882    {
;;;883      /* Check the parameters */
;;;884      assert_param(IS_RCC_MCO(RCC_MCO));
;;;885      /* Perform Byte access to MCO[2:0] bits to select the MCO source */
;;;886      *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
000340  71c8              STRB     r0,[r1,#7]
;;;887    }
000342  4770              BX       lr
;;;888    
                          ENDP

                  RCC_ClearFlag PROC
;;;948      */
;;;949    void RCC_ClearFlag(void)
000344  4809              LDR      r0,|L1.876|
;;;950    {
;;;951      /* Set RMVF bit to clear the reset flags */
;;;952      RCC->CSR |= CSR_RMVF_Set;
000346  6a40              LDR      r0,[r0,#0x24]
000348  f0407080          ORR      r0,r0,#0x1000000
00034c  4907              LDR      r1,|L1.876|
00034e  6248              STR      r0,[r1,#0x24]
;;;953    }
000350  4770              BX       lr
;;;954    
                          ENDP

                  RCC_GetITStatus PROC
;;;966      */
;;;967    ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000352  4601              MOV      r1,r0
;;;968    {
;;;969      ITStatus bitstatus = RESET;
000354  2000              MOVS     r0,#0
;;;970      /* Check the parameters */
;;;971      assert_param(IS_RCC_GET_IT(RCC_IT));
;;;972      /* Check the status of the specified RCC interrupt */
;;;973      if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000356  4a05              LDR      r2,|L1.876|
000358  6892              LDR      r2,[r2,#8]
00035a  420a              TST      r2,r1
00035c  d001              BEQ      |L1.866|
;;;974      {
;;;975        bitstatus = SET;
00035e  2001              MOVS     r0,#1
000360  e000              B        |L1.868|
                  |L1.866|
;;;976      }
;;;977      else
;;;978      {
;;;979        bitstatus = RESET;
000362  2000              MOVS     r0,#0
                  |L1.868|
;;;980      }
;;;981      /* Return the RCC_IT status */
;;;982      return  bitstatus;
;;;983    }
000364  4770              BX       lr
;;;984    
                          ENDP

                  RCC_ClearITPendingBit PROC
;;;996      */
;;;997    void RCC_ClearITPendingBit(uint8_t RCC_IT)
000366  4901              LDR      r1,|L1.876|
;;;998    {
;;;999      /* Check the parameters */
;;;1000     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1001     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1002        pending bits */
;;;1003     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000368  7288              STRB     r0,[r1,#0xa]
;;;1004   }
00036a  4770              BX       lr
;;;1005   
                          ENDP

                  |L1.876|
                          DCD      0x40021000
                  |L1.880|
                          DCD      0xf8ff0000
                  |L1.884|
                          DCD      0xfef6ffff
                  |L1.888|
                          DCD      0x42420000
                  |L1.892|
                          DCD      0x424200d8
                  |L1.896|
                          DCD      0x40021020
                  |L1.900|
                          DCD      0x42420480
                  |L1.904|
                          DCD      0x4242043c
                  |L1.908|
                          DCD      0x007a1200
                  |L1.912|
                          DCD      0x003d0900
                  |L1.916|
                          DCD      APBAHBPrescTable
                  |L1.920|
                          DCD      ADCPrescTable
                  |L1.924|
                          DCD      0x42420440

                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09
                  ADCPrescTable
000010  02040608          DCB      0x02,0x04,0x06,0x08
