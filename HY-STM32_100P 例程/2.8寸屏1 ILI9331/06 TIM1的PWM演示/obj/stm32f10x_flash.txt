; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\obj\stm32f10x_flash.o --depend=.\obj\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\stm32f10x_flash.crf FWlib\SRC\stm32f10x_flash.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;124      */
;;;125    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4601              MOV      r1,r0
;;;126    {
;;;127      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;128      
;;;129      /* Check the parameters */
;;;130      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;131      
;;;132      /* Read the ACR register */
;;;133      tmpreg = FLASH->ACR;  
000004  4af8              LDR      r2,|L1.1000|
000006  6810              LDR      r0,[r2,#0]
;;;134      
;;;135      /* Sets the Latency value */
;;;136      tmpreg &= ACR_LATENCY_Mask;
000008  f0000038          AND      r0,r0,#0x38
;;;137      tmpreg |= FLASH_Latency;
00000c  4308              ORRS     r0,r0,r1
;;;138      
;;;139      /* Write the ACR register */
;;;140      FLASH->ACR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;141    }
000010  4770              BX       lr
;;;142    
                          ENDP

                  FLASH_HalfCycleAccessCmd PROC
;;;150      */
;;;151    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000012  49f5              LDR      r1,|L1.1000|
;;;152    {
;;;153      /* Check the parameters */
;;;154      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;155      
;;;156      /* Enable or disable the Half cycle access */
;;;157      FLASH->ACR &= ACR_HLFCYA_Mask;
000014  6809              LDR      r1,[r1,#0]
000016  f0210108          BIC      r1,r1,#8
00001a  4af3              LDR      r2,|L1.1000|
00001c  6011              STR      r1,[r2,#0]
;;;158      FLASH->ACR |= FLASH_HalfCycleAccess;
00001e  4611              MOV      r1,r2
000020  6809              LDR      r1,[r1,#0]
000022  4301              ORRS     r1,r1,r0
000024  6011              STR      r1,[r2,#0]
;;;159    }
000026  4770              BX       lr
;;;160    
                          ENDP

                  FLASH_PrefetchBufferCmd PROC
;;;168      */
;;;169    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000028  49ef              LDR      r1,|L1.1000|
;;;170    {
;;;171      /* Check the parameters */
;;;172      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;173      
;;;174      /* Enable or disable the Prefetch Buffer */
;;;175      FLASH->ACR &= ACR_PRFTBE_Mask;
00002a  6809              LDR      r1,[r1,#0]
00002c  f0210110          BIC      r1,r1,#0x10
000030  4aed              LDR      r2,|L1.1000|
000032  6011              STR      r1,[r2,#0]
;;;176      FLASH->ACR |= FLASH_PrefetchBuffer;
000034  4611              MOV      r1,r2
000036  6809              LDR      r1,[r1,#0]
000038  4301              ORRS     r1,r1,r0
00003a  6011              STR      r1,[r2,#0]
;;;177    }
00003c  4770              BX       lr
;;;178    
                          ENDP

                  FLASH_Unlock PROC
;;;183      */
;;;184    void FLASH_Unlock(void)
00003e  48eb              LDR      r0,|L1.1004|
;;;185    {
;;;186      /* Authorize the FPEC Access */
;;;187      FLASH->KEYR = FLASH_KEY1;
000040  49e9              LDR      r1,|L1.1000|
000042  6048              STR      r0,[r1,#4]
;;;188      FLASH->KEYR = FLASH_KEY2;
000044  48ea              LDR      r0,|L1.1008|
000046  6048              STR      r0,[r1,#4]
;;;189    }
000048  4770              BX       lr
;;;190    
                          ENDP

                  FLASH_Lock PROC
;;;195      */
;;;196    void FLASH_Lock(void)
00004a  48e7              LDR      r0,|L1.1000|
;;;197    {
;;;198      /* Set the Lock Bit to lock the FPEC and the FCR */
;;;199      FLASH->CR |= CR_LOCK_Set;
00004c  6900              LDR      r0,[r0,#0x10]
00004e  f0400080          ORR      r0,r0,#0x80
000052  49e5              LDR      r1,|L1.1000|
000054  6108              STR      r0,[r1,#0x10]
;;;200    }
000056  4770              BX       lr
;;;201    
                          ENDP

                  FLASH_GetStatus PROC
;;;797      */
;;;798    FLASH_Status FLASH_GetStatus(void)
000058  2004              MOVS     r0,#4
;;;799    {
;;;800      FLASH_Status flashstatus = FLASH_COMPLETE;
;;;801      
;;;802      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
00005a  49e3              LDR      r1,|L1.1000|
00005c  68c9              LDR      r1,[r1,#0xc]
00005e  f0010101          AND      r1,r1,#1
000062  2901              CMP      r1,#1
000064  d101              BNE      |L1.106|
;;;803      {
;;;804        flashstatus = FLASH_BUSY;
000066  2001              MOVS     r0,#1
000068  e00e              B        |L1.136|
                  |L1.106|
;;;805      }
;;;806      else 
;;;807      {  
;;;808        if(FLASH->SR & FLASH_FLAG_PGERR)
00006a  49df              LDR      r1,|L1.1000|
00006c  68c9              LDR      r1,[r1,#0xc]
00006e  f0110f04          TST      r1,#4
000072  d001              BEQ      |L1.120|
;;;809        { 
;;;810          flashstatus = FLASH_ERROR_PG;
000074  2002              MOVS     r0,#2
000076  e007              B        |L1.136|
                  |L1.120|
;;;811        }
;;;812        else 
;;;813        {
;;;814          if(FLASH->SR & FLASH_FLAG_WRPRTERR)
000078  49db              LDR      r1,|L1.1000|
00007a  68c9              LDR      r1,[r1,#0xc]
00007c  f0110f10          TST      r1,#0x10
000080  d001              BEQ      |L1.134|
;;;815          {
;;;816            flashstatus = FLASH_ERROR_WRP;
000082  2003              MOVS     r0,#3
000084  e000              B        |L1.136|
                  |L1.134|
;;;817          }
;;;818          else
;;;819          {
;;;820            flashstatus = FLASH_COMPLETE;
000086  2004              MOVS     r0,#4
                  |L1.136|
;;;821          }
;;;822        }
;;;823      }
;;;824      /* Return the Flash Status */
;;;825      return flashstatus;
;;;826    }
000088  4770              BX       lr
;;;827    
                          ENDP

                  delay PROC
;;;860      */
;;;861    static void delay(void)
00008a  2000              MOVS     r0,#0
;;;862    {
;;;863      __IO uint32_t i = 0;
;;;864      for(i = 0xFF; i != 0; i--)
00008c  20ff              MOVS     r0,#0xff
00008e  e000              B        |L1.146|
                  |L1.144|
000090  1e40              SUBS     r0,r0,#1
                  |L1.146|
000092  2800              CMP      r0,#0
000094  d1fc              BNE      |L1.144|
;;;865      {
;;;866      }
;;;867    }
000096  4770              BX       lr
;;;868    
                          ENDP

                  FLASH_WaitForLastOperation PROC
;;;834      */
;;;835    FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000098  b570              PUSH     {r4-r6,lr}
;;;836    { 
00009a  4604              MOV      r4,r0
;;;837      FLASH_Status status = FLASH_COMPLETE;
00009c  2504              MOVS     r5,#4
;;;838       
;;;839      /* Check for the Flash Status */
;;;840      status = FLASH_GetStatus();
00009e  f7fffffe          BL       FLASH_GetStatus
0000a2  4605              MOV      r5,r0
;;;841      /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;842      while((status == FLASH_BUSY) && (Timeout != 0x00))
0000a4  e005              B        |L1.178|
                  |L1.166|
;;;843      {
;;;844        delay();
0000a6  f7fffffe          BL       delay
;;;845        status = FLASH_GetStatus();
0000aa  f7fffffe          BL       FLASH_GetStatus
0000ae  4605              MOV      r5,r0
;;;846        Timeout--;
0000b0  1e64              SUBS     r4,r4,#1
                  |L1.178|
0000b2  2d01              CMP      r5,#1                 ;842
0000b4  d101              BNE      |L1.186|
0000b6  2c00              CMP      r4,#0                 ;842
0000b8  d1f5              BNE      |L1.166|
                  |L1.186|
;;;847      }
;;;848      if(Timeout == 0x00 )
0000ba  b904              CBNZ     r4,|L1.190|
;;;849      {
;;;850        status = FLASH_TIMEOUT;
0000bc  2505              MOVS     r5,#5
                  |L1.190|
;;;851      }
;;;852      /* Return the operation status */
;;;853      return status;
0000be  4628              MOV      r0,r5
;;;854    }
0000c0  bd70              POP      {r4-r6,pc}
;;;855    
                          ENDP

                  FLASH_ErasePage PROC
;;;208      */
;;;209    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
0000c2  b570              PUSH     {r4-r6,lr}
;;;210    {
0000c4  4605              MOV      r5,r0
;;;211      FLASH_Status status = FLASH_COMPLETE;
0000c6  2404              MOVS     r4,#4
;;;212      /* Check the parameters */
;;;213      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;214      /* Wait for last operation to be completed */
;;;215      status = FLASH_WaitForLastOperation(EraseTimeout);
0000c8  f64070ff          MOV      r0,#0xfff
0000cc  f7fffffe          BL       FLASH_WaitForLastOperation
0000d0  4604              MOV      r4,r0
;;;216      
;;;217      if(status == FLASH_COMPLETE)
0000d2  2c04              CMP      r4,#4
0000d4  d119              BNE      |L1.266|
;;;218      { 
;;;219        /* if the previous operation is completed, proceed to erase the page */
;;;220        FLASH->CR|= CR_PER_Set;
0000d6  48c4              LDR      r0,|L1.1000|
0000d8  6900              LDR      r0,[r0,#0x10]
0000da  f0400002          ORR      r0,r0,#2
0000de  49c2              LDR      r1,|L1.1000|
0000e0  6108              STR      r0,[r1,#0x10]
;;;221        FLASH->AR = Page_Address; 
0000e2  4608              MOV      r0,r1
0000e4  6145              STR      r5,[r0,#0x14]
;;;222        FLASH->CR|= CR_STRT_Set;
0000e6  6900              LDR      r0,[r0,#0x10]
0000e8  f0400040          ORR      r0,r0,#0x40
0000ec  6108              STR      r0,[r1,#0x10]
;;;223        
;;;224        /* Wait for last operation to be completed */
;;;225        status = FLASH_WaitForLastOperation(EraseTimeout);
0000ee  f64070ff          MOV      r0,#0xfff
0000f2  f7fffffe          BL       FLASH_WaitForLastOperation
0000f6  4604              MOV      r4,r0
;;;226        if(status != FLASH_BUSY)
0000f8  2c01              CMP      r4,#1
0000fa  d006              BEQ      |L1.266|
;;;227        {
;;;228          /* if the erase operation is completed, disable the PER Bit */
;;;229          FLASH->CR &= CR_PER_Reset;
0000fc  48ba              LDR      r0,|L1.1000|
0000fe  6900              LDR      r0,[r0,#0x10]
000100  f64171fd          MOV      r1,#0x1ffd
000104  4008              ANDS     r0,r0,r1
000106  49b8              LDR      r1,|L1.1000|
000108  6108              STR      r0,[r1,#0x10]
                  |L1.266|
;;;230        }
;;;231      }
;;;232      /* Return the Erase Status */
;;;233      return status;
00010a  4620              MOV      r0,r4
;;;234    }
00010c  bd70              POP      {r4-r6,pc}
;;;235    
                          ENDP

                  FLASH_EraseAllPages PROC
;;;242      */
;;;243    FLASH_Status FLASH_EraseAllPages(void)
00010e  b510              PUSH     {r4,lr}
;;;244    {
;;;245      FLASH_Status status = FLASH_COMPLETE;
000110  2404              MOVS     r4,#4
;;;246      /* Wait for last operation to be completed */
;;;247      status = FLASH_WaitForLastOperation(EraseTimeout);
000112  f64070ff          MOV      r0,#0xfff
000116  f7fffffe          BL       FLASH_WaitForLastOperation
00011a  4604              MOV      r4,r0
;;;248      
;;;249      if(status == FLASH_COMPLETE)
00011c  2c04              CMP      r4,#4
00011e  d118              BNE      |L1.338|
;;;250      {
;;;251        /* if the previous operation is completed, proceed to erase all pages */
;;;252         FLASH->CR |= CR_MER_Set;
000120  48b1              LDR      r0,|L1.1000|
000122  6900              LDR      r0,[r0,#0x10]
000124  f0400004          ORR      r0,r0,#4
000128  49af              LDR      r1,|L1.1000|
00012a  6108              STR      r0,[r1,#0x10]
;;;253         FLASH->CR |= CR_STRT_Set;
00012c  4608              MOV      r0,r1
00012e  6900              LDR      r0,[r0,#0x10]
000130  f0400040          ORR      r0,r0,#0x40
000134  6108              STR      r0,[r1,#0x10]
;;;254        
;;;255        /* Wait for last operation to be completed */
;;;256        status = FLASH_WaitForLastOperation(EraseTimeout);
000136  f64070ff          MOV      r0,#0xfff
00013a  f7fffffe          BL       FLASH_WaitForLastOperation
00013e  4604              MOV      r4,r0
;;;257        if(status != FLASH_BUSY)
000140  2c01              CMP      r4,#1
000142  d006              BEQ      |L1.338|
;;;258        {
;;;259          /* if the erase operation is completed, disable the MER Bit */
;;;260          FLASH->CR &= CR_MER_Reset;
000144  48a8              LDR      r0,|L1.1000|
000146  6900              LDR      r0,[r0,#0x10]
000148  f64171fb          MOV      r1,#0x1ffb
00014c  4008              ANDS     r0,r0,r1
00014e  49a6              LDR      r1,|L1.1000|
000150  6108              STR      r0,[r1,#0x10]
                  |L1.338|
;;;261        }
;;;262      }	   
;;;263      /* Return the Erase Status */
;;;264      return status;
000152  4620              MOV      r0,r4
;;;265    }
000154  bd10              POP      {r4,pc}
;;;266    
                          ENDP

                  FLASH_EraseOptionBytes PROC
;;;273      */
;;;274    FLASH_Status FLASH_EraseOptionBytes(void)
000156  b510              PUSH     {r4,lr}
;;;275    {
;;;276      FLASH_Status status = FLASH_COMPLETE;
000158  2404              MOVS     r4,#4
;;;277      
;;;278      /* Wait for last operation to be completed */
;;;279      status = FLASH_WaitForLastOperation(EraseTimeout);
00015a  f64070ff          MOV      r0,#0xfff
00015e  f7fffffe          BL       FLASH_WaitForLastOperation
000162  4604              MOV      r4,r0
;;;280      if(status == FLASH_COMPLETE)
000164  2c04              CMP      r4,#4
000166  d13c              BNE      |L1.482|
;;;281      {
;;;282        /* Authorize the small information block programming */
;;;283        FLASH->OPTKEYR = FLASH_KEY1;
000168  48a0              LDR      r0,|L1.1004|
00016a  499f              LDR      r1,|L1.1000|
00016c  6088              STR      r0,[r1,#8]
;;;284        FLASH->OPTKEYR = FLASH_KEY2;
00016e  48a0              LDR      r0,|L1.1008|
000170  6088              STR      r0,[r1,#8]
;;;285        
;;;286        /* if the previous operation is completed, proceed to erase the option bytes */
;;;287        FLASH->CR |= CR_OPTER_Set;
000172  4608              MOV      r0,r1
000174  6900              LDR      r0,[r0,#0x10]
000176  f0400020          ORR      r0,r0,#0x20
00017a  6108              STR      r0,[r1,#0x10]
;;;288        FLASH->CR |= CR_STRT_Set;
00017c  4608              MOV      r0,r1
00017e  6900              LDR      r0,[r0,#0x10]
000180  f0400040          ORR      r0,r0,#0x40
000184  6108              STR      r0,[r1,#0x10]
;;;289        /* Wait for last operation to be completed */
;;;290        status = FLASH_WaitForLastOperation(EraseTimeout);
000186  f64070ff          MOV      r0,#0xfff
00018a  f7fffffe          BL       FLASH_WaitForLastOperation
00018e  4604              MOV      r4,r0
;;;291        
;;;292        if(status == FLASH_COMPLETE)
000190  2c04              CMP      r4,#4
000192  d11d              BNE      |L1.464|
;;;293        {
;;;294          /* if the erase operation is completed, disable the OPTER Bit */
;;;295          FLASH->CR &= CR_OPTER_Reset;
000194  4894              LDR      r0,|L1.1000|
000196  6900              LDR      r0,[r0,#0x10]
000198  f64171df          MOV      r1,#0x1fdf
00019c  4008              ANDS     r0,r0,r1
00019e  4992              LDR      r1,|L1.1000|
0001a0  6108              STR      r0,[r1,#0x10]
;;;296           
;;;297          /* Enable the Option Bytes Programming operation */
;;;298          FLASH->CR |= CR_OPTPG_Set;
0001a2  4608              MOV      r0,r1
0001a4  6900              LDR      r0,[r0,#0x10]
0001a6  f0400010          ORR      r0,r0,#0x10
0001aa  6108              STR      r0,[r1,#0x10]
;;;299          /* Enable the readout access */
;;;300          OB->RDP= RDP_Key; 
0001ac  20a5              MOVS     r0,#0xa5
0001ae  4991              LDR      r1,|L1.1012|
0001b0  8008              STRH     r0,[r1,#0]
;;;301          /* Wait for last operation to be completed */
;;;302          status = FLASH_WaitForLastOperation(ProgramTimeout);
0001b2  f04f000f          MOV      r0,#0xf
0001b6  f7fffffe          BL       FLASH_WaitForLastOperation
0001ba  4604              MOV      r4,r0
;;;303     
;;;304          if(status != FLASH_BUSY)
0001bc  2c01              CMP      r4,#1
0001be  d010              BEQ      |L1.482|
;;;305          {
;;;306            /* if the program operation is completed, disable the OPTPG Bit */
;;;307            FLASH->CR &= CR_OPTPG_Reset;
0001c0  4889              LDR      r0,|L1.1000|
0001c2  6900              LDR      r0,[r0,#0x10]
0001c4  f64171ef          MOV      r1,#0x1fef
0001c8  4008              ANDS     r0,r0,r1
0001ca  4987              LDR      r1,|L1.1000|
0001cc  6108              STR      r0,[r1,#0x10]
0001ce  e008              B        |L1.482|
                  |L1.464|
;;;308          }
;;;309        }
;;;310        else
;;;311        {
;;;312          if (status != FLASH_BUSY)
0001d0  2c01              CMP      r4,#1
0001d2  d006              BEQ      |L1.482|
;;;313          {
;;;314            /* Disable the OPTPG Bit */
;;;315            FLASH->CR &= CR_OPTPG_Reset;
0001d4  4884              LDR      r0,|L1.1000|
0001d6  6900              LDR      r0,[r0,#0x10]
0001d8  f64171ef          MOV      r1,#0x1fef
0001dc  4008              ANDS     r0,r0,r1
0001de  4982              LDR      r1,|L1.1000|
0001e0  6108              STR      r0,[r1,#0x10]
                  |L1.482|
;;;316          }
;;;317        }  
;;;318      }
;;;319      /* Return the erase status */
;;;320      return status;
0001e2  4620              MOV      r0,r4
;;;321    }
0001e4  bd10              POP      {r4,pc}
;;;322    
                          ENDP

                  FLASH_ProgramWord PROC
;;;330      */
;;;331    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
0001e6  b570              PUSH     {r4-r6,lr}
;;;332    {
0001e8  4605              MOV      r5,r0
0001ea  460e              MOV      r6,r1
;;;333      FLASH_Status status = FLASH_COMPLETE;
0001ec  2404              MOVS     r4,#4
;;;334      /* Check the parameters */
;;;335      assert_param(IS_FLASH_ADDRESS(Address));
;;;336      /* Wait for last operation to be completed */
;;;337      status = FLASH_WaitForLastOperation(ProgramTimeout);
0001ee  200f              MOVS     r0,#0xf
0001f0  f7fffffe          BL       FLASH_WaitForLastOperation
0001f4  4604              MOV      r4,r0
;;;338      
;;;339      if(status == FLASH_COMPLETE)
0001f6  2c04              CMP      r4,#4
0001f8  d125              BNE      |L1.582|
;;;340      {
;;;341        /* if the previous operation is completed, proceed to program the new first 
;;;342        half word */
;;;343        FLASH->CR |= CR_PG_Set;
0001fa  487b              LDR      r0,|L1.1000|
0001fc  6900              LDR      r0,[r0,#0x10]
0001fe  f0400001          ORR      r0,r0,#1
000202  4979              LDR      r1,|L1.1000|
000204  6108              STR      r0,[r1,#0x10]
;;;344      
;;;345        *(__IO uint16_t*)Address = (uint16_t)Data;
000206  802e              STRH     r6,[r5,#0]
;;;346        /* Wait for last operation to be completed */
;;;347        status = FLASH_WaitForLastOperation(ProgramTimeout);
000208  200f              MOVS     r0,#0xf
00020a  f7fffffe          BL       FLASH_WaitForLastOperation
00020e  4604              MOV      r4,r0
;;;348     
;;;349        if(status == FLASH_COMPLETE)
000210  2c04              CMP      r4,#4
000212  d10f              BNE      |L1.564|
;;;350        {
;;;351          /* if the previous operation is completed, proceed to program the new second 
;;;352          half word */
;;;353          *(__IO uint16_t*)(Address + 2) = Data >> 16;
000214  0c30              LSRS     r0,r6,#16
000216  8068              STRH     r0,[r5,#2]
;;;354        
;;;355          /* Wait for last operation to be completed */
;;;356          status = FLASH_WaitForLastOperation(ProgramTimeout);
000218  200f              MOVS     r0,#0xf
00021a  f7fffffe          BL       FLASH_WaitForLastOperation
00021e  4604              MOV      r4,r0
;;;357            
;;;358          if(status != FLASH_BUSY)
000220  2c01              CMP      r4,#1
000222  d010              BEQ      |L1.582|
;;;359          {
;;;360            /* Disable the PG Bit */
;;;361            FLASH->CR &= CR_PG_Reset;
000224  4870              LDR      r0,|L1.1000|
000226  6900              LDR      r0,[r0,#0x10]
000228  f64171fe          MOV      r1,#0x1ffe
00022c  4008              ANDS     r0,r0,r1
00022e  496e              LDR      r1,|L1.1000|
000230  6108              STR      r0,[r1,#0x10]
000232  e008              B        |L1.582|
                  |L1.564|
;;;362          }
;;;363        }
;;;364        else
;;;365        {
;;;366          if (status != FLASH_BUSY)
000234  2c01              CMP      r4,#1
000236  d006              BEQ      |L1.582|
;;;367          {
;;;368            /* Disable the PG Bit */
;;;369            FLASH->CR &= CR_PG_Reset;
000238  486b              LDR      r0,|L1.1000|
00023a  6900              LDR      r0,[r0,#0x10]
00023c  f64171fe          MOV      r1,#0x1ffe
000240  4008              ANDS     r0,r0,r1
000242  4969              LDR      r1,|L1.1000|
000244  6108              STR      r0,[r1,#0x10]
                  |L1.582|
;;;370          }
;;;371         }
;;;372      }
;;;373      /* Return the Program Status */
;;;374      return status;
000246  4620              MOV      r0,r4
;;;375    }
000248  bd70              POP      {r4-r6,pc}
;;;376    
                          ENDP

                  FLASH_ProgramHalfWord PROC
;;;384      */
;;;385    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
00024a  b570              PUSH     {r4-r6,lr}
;;;386    {
00024c  4605              MOV      r5,r0
00024e  460e              MOV      r6,r1
;;;387      FLASH_Status status = FLASH_COMPLETE;
000250  2404              MOVS     r4,#4
;;;388      /* Check the parameters */
;;;389      assert_param(IS_FLASH_ADDRESS(Address));
;;;390      /* Wait for last operation to be completed */
;;;391      status = FLASH_WaitForLastOperation(ProgramTimeout);
000252  200f              MOVS     r0,#0xf
000254  f7fffffe          BL       FLASH_WaitForLastOperation
000258  4604              MOV      r4,r0
;;;392      
;;;393      if(status == FLASH_COMPLETE)
00025a  2c04              CMP      r4,#4
00025c  d113              BNE      |L1.646|
;;;394      {
;;;395        /* if the previous operation is completed, proceed to program the new data */
;;;396        FLASH->CR |= CR_PG_Set;
00025e  4862              LDR      r0,|L1.1000|
000260  6900              LDR      r0,[r0,#0x10]
000262  f0400001          ORR      r0,r0,#1
000266  4960              LDR      r1,|L1.1000|
000268  6108              STR      r0,[r1,#0x10]
;;;397      
;;;398        *(__IO uint16_t*)Address = Data;
00026a  802e              STRH     r6,[r5,#0]
;;;399        /* Wait for last operation to be completed */
;;;400        status = FLASH_WaitForLastOperation(ProgramTimeout);
00026c  200f              MOVS     r0,#0xf
00026e  f7fffffe          BL       FLASH_WaitForLastOperation
000272  4604              MOV      r4,r0
;;;401        if(status != FLASH_BUSY)
000274  2c01              CMP      r4,#1
000276  d006              BEQ      |L1.646|
;;;402        {
;;;403          /* if the program operation is completed, disable the PG Bit */
;;;404          FLASH->CR &= CR_PG_Reset;
000278  485b              LDR      r0,|L1.1000|
00027a  6900              LDR      r0,[r0,#0x10]
00027c  f64171fe          MOV      r1,#0x1ffe
000280  4008              ANDS     r0,r0,r1
000282  4959              LDR      r1,|L1.1000|
000284  6108              STR      r0,[r1,#0x10]
                  |L1.646|
;;;405        }
;;;406      } 
;;;407      /* Return the Program Status */
;;;408      return status;
000286  4620              MOV      r0,r4
;;;409    }
000288  bd70              POP      {r4-r6,pc}
;;;410    
                          ENDP

                  FLASH_ProgramOptionByteData PROC
;;;419      */
;;;420    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
00028a  b570              PUSH     {r4-r6,lr}
;;;421    {
00028c  4605              MOV      r5,r0
00028e  460e              MOV      r6,r1
;;;422      FLASH_Status status = FLASH_COMPLETE;
000290  2404              MOVS     r4,#4
;;;423      /* Check the parameters */
;;;424      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;425      status = FLASH_WaitForLastOperation(ProgramTimeout);
000292  200f              MOVS     r0,#0xf
000294  f7fffffe          BL       FLASH_WaitForLastOperation
000298  4604              MOV      r4,r0
;;;426      if(status == FLASH_COMPLETE)
00029a  2c04              CMP      r4,#4
00029c  d117              BNE      |L1.718|
;;;427      {
;;;428        /* Authorize the small information block programming */
;;;429        FLASH->OPTKEYR = FLASH_KEY1;
00029e  4853              LDR      r0,|L1.1004|
0002a0  4951              LDR      r1,|L1.1000|
0002a2  6088              STR      r0,[r1,#8]
;;;430        FLASH->OPTKEYR = FLASH_KEY2;
0002a4  4852              LDR      r0,|L1.1008|
0002a6  6088              STR      r0,[r1,#8]
;;;431        /* Enables the Option Bytes Programming operation */
;;;432        FLASH->CR |= CR_OPTPG_Set; 
0002a8  4608              MOV      r0,r1
0002aa  6900              LDR      r0,[r0,#0x10]
0002ac  f0400010          ORR      r0,r0,#0x10
0002b0  6108              STR      r0,[r1,#0x10]
;;;433        *(__IO uint16_t*)Address = Data;
0002b2  802e              STRH     r6,[r5,#0]
;;;434        
;;;435        /* Wait for last operation to be completed */
;;;436        status = FLASH_WaitForLastOperation(ProgramTimeout);
0002b4  200f              MOVS     r0,#0xf
0002b6  f7fffffe          BL       FLASH_WaitForLastOperation
0002ba  4604              MOV      r4,r0
;;;437        if(status != FLASH_BUSY)
0002bc  2c01              CMP      r4,#1
0002be  d006              BEQ      |L1.718|
;;;438        {
;;;439          /* if the program operation is completed, disable the OPTPG Bit */
;;;440          FLASH->CR &= CR_OPTPG_Reset;
0002c0  4849              LDR      r0,|L1.1000|
0002c2  6900              LDR      r0,[r0,#0x10]
0002c4  f64171ef          MOV      r1,#0x1fef
0002c8  4008              ANDS     r0,r0,r1
0002ca  4947              LDR      r1,|L1.1000|
0002cc  6108              STR      r0,[r1,#0x10]
                  |L1.718|
;;;441        }
;;;442      }    
;;;443      /* Return the Option Byte Data Program Status */
;;;444      return status;
0002ce  4620              MOV      r0,r4
;;;445    }
0002d0  bd70              POP      {r4-r6,pc}
;;;446    
                          ENDP

                  FLASH_EnableWriteProtection PROC
;;;460      */
;;;461    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
0002d2  e92d47f0          PUSH     {r4-r10,lr}
;;;462    {
0002d6  4604              MOV      r4,r0
;;;463      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
0002d8  f64f76ff          MOV      r6,#0xffff
0002dc  4637              MOV      r7,r6
0002de  46b0              MOV      r8,r6
0002e0  46b1              MOV      r9,r6
;;;464      
;;;465      FLASH_Status status = FLASH_COMPLETE;
0002e2  2504              MOVS     r5,#4
;;;466      
;;;467      /* Check the parameters */
;;;468      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;469      
;;;470      FLASH_Pages = (uint32_t)(~FLASH_Pages);
0002e4  43e4              MVNS     r4,r4
;;;471      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
0002e6  b2e6              UXTB     r6,r4
;;;472      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
0002e8  f3c42707          UBFX     r7,r4,#8,#8
;;;473      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
0002ec  f3c44807          UBFX     r8,r4,#16,#8
;;;474      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
0002f0  ea4f6914          LSR      r9,r4,#24
;;;475      
;;;476      /* Wait for last operation to be completed */
;;;477      status = FLASH_WaitForLastOperation(ProgramTimeout);
0002f4  200f              MOVS     r0,#0xf
0002f6  f7fffffe          BL       FLASH_WaitForLastOperation
0002fa  4605              MOV      r5,r0
;;;478      
;;;479      if(status == FLASH_COMPLETE)
0002fc  2d04              CMP      r5,#4
0002fe  d13e              BNE      |L1.894|
;;;480      {
;;;481        /* Authorizes the small information block programming */
;;;482        FLASH->OPTKEYR = FLASH_KEY1;
000300  483a              LDR      r0,|L1.1004|
000302  4939              LDR      r1,|L1.1000|
000304  6088              STR      r0,[r1,#8]
;;;483        FLASH->OPTKEYR = FLASH_KEY2;
000306  483a              LDR      r0,|L1.1008|
000308  6088              STR      r0,[r1,#8]
;;;484        FLASH->CR |= CR_OPTPG_Set;
00030a  4608              MOV      r0,r1
00030c  6900              LDR      r0,[r0,#0x10]
00030e  f0400010          ORR      r0,r0,#0x10
000312  6108              STR      r0,[r1,#0x10]
;;;485        if(WRP0_Data != 0xFF)
000314  2eff              CMP      r6,#0xff
000316  d006              BEQ      |L1.806|
;;;486        {
;;;487          OB->WRP0 = WRP0_Data;
000318  4837              LDR      r0,|L1.1016|
00031a  8006              STRH     r6,[r0,#0]
;;;488          
;;;489          /* Wait for last operation to be completed */
;;;490          status = FLASH_WaitForLastOperation(ProgramTimeout);
00031c  f04f000f          MOV      r0,#0xf
000320  f7fffffe          BL       FLASH_WaitForLastOperation
000324  4605              MOV      r5,r0
                  |L1.806|
;;;491        }
;;;492        if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
000326  2d04              CMP      r5,#4
000328  d108              BNE      |L1.828|
00032a  2fff              CMP      r7,#0xff
00032c  d006              BEQ      |L1.828|
;;;493        {
;;;494          OB->WRP1 = WRP1_Data;
00032e  4833              LDR      r0,|L1.1020|
000330  8007              STRH     r7,[r0,#0]
;;;495          
;;;496          /* Wait for last operation to be completed */
;;;497          status = FLASH_WaitForLastOperation(ProgramTimeout);
000332  f04f000f          MOV      r0,#0xf
000336  f7fffffe          BL       FLASH_WaitForLastOperation
00033a  4605              MOV      r5,r0
                  |L1.828|
;;;498        }
;;;499        if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
00033c  2d04              CMP      r5,#4
00033e  d109              BNE      |L1.852|
000340  f1b80fff          CMP      r8,#0xff
000344  d006              BEQ      |L1.852|
;;;500        {
;;;501          OB->WRP2 = WRP2_Data;
000346  482e              LDR      r0,|L1.1024|
000348  f8a0880c          STRH     r8,[r0,#0x80c]
;;;502          
;;;503          /* Wait for last operation to be completed */
;;;504          status = FLASH_WaitForLastOperation(ProgramTimeout);
00034c  200f              MOVS     r0,#0xf
00034e  f7fffffe          BL       FLASH_WaitForLastOperation
000352  4605              MOV      r5,r0
                  |L1.852|
;;;505        }
;;;506        
;;;507        if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000354  2d04              CMP      r5,#4
000356  d109              BNE      |L1.876|
000358  f1b90fff          CMP      r9,#0xff
00035c  d006              BEQ      |L1.876|
;;;508        {
;;;509          OB->WRP3 = WRP3_Data;
00035e  4828              LDR      r0,|L1.1024|
000360  f8a0980e          STRH     r9,[r0,#0x80e]
;;;510         
;;;511          /* Wait for last operation to be completed */
;;;512          status = FLASH_WaitForLastOperation(ProgramTimeout);
000364  200f              MOVS     r0,#0xf
000366  f7fffffe          BL       FLASH_WaitForLastOperation
00036a  4605              MOV      r5,r0
                  |L1.876|
;;;513        }
;;;514              
;;;515        if(status != FLASH_BUSY)
00036c  2d01              CMP      r5,#1
00036e  d006              BEQ      |L1.894|
;;;516        {
;;;517          /* if the program operation is completed, disable the OPTPG Bit */
;;;518          FLASH->CR &= CR_OPTPG_Reset;
000370  481d              LDR      r0,|L1.1000|
000372  6900              LDR      r0,[r0,#0x10]
000374  f64171ef          MOV      r1,#0x1fef
000378  4008              ANDS     r0,r0,r1
00037a  491b              LDR      r1,|L1.1000|
00037c  6108              STR      r0,[r1,#0x10]
                  |L1.894|
;;;519        }
;;;520      } 
;;;521      /* Return the write protection operation Status */
;;;522      return status;       
00037e  4628              MOV      r0,r5
;;;523    }
000380  e8bd87f0          POP      {r4-r10,pc}
;;;524    
                          ENDP

                  FLASH_ReadOutProtection PROC
;;;535      */
;;;536    FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000384  b570              PUSH     {r4-r6,lr}
;;;537    {
000386  4605              MOV      r5,r0
;;;538      FLASH_Status status = FLASH_COMPLETE;
000388  2404              MOVS     r4,#4
;;;539      /* Check the parameters */
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      status = FLASH_WaitForLastOperation(EraseTimeout);
00038a  f64070ff          MOV      r0,#0xfff
00038e  f7fffffe          BL       FLASH_WaitForLastOperation
000392  4604              MOV      r4,r0
;;;542      if(status == FLASH_COMPLETE)
000394  2c04              CMP      r4,#4
000396  d150              BNE      |L1.1082|
;;;543      {
;;;544        /* Authorizes the small information block programming */
;;;545        FLASH->OPTKEYR = FLASH_KEY1;
000398  4814              LDR      r0,|L1.1004|
00039a  4913              LDR      r1,|L1.1000|
00039c  6088              STR      r0,[r1,#8]
;;;546        FLASH->OPTKEYR = FLASH_KEY2;
00039e  4814              LDR      r0,|L1.1008|
0003a0  6088              STR      r0,[r1,#8]
;;;547        FLASH->CR |= CR_OPTER_Set;
0003a2  4608              MOV      r0,r1
0003a4  6900              LDR      r0,[r0,#0x10]
0003a6  f0400020          ORR      r0,r0,#0x20
0003aa  6108              STR      r0,[r1,#0x10]
;;;548        FLASH->CR |= CR_STRT_Set;
0003ac  4608              MOV      r0,r1
0003ae  6900              LDR      r0,[r0,#0x10]
0003b0  f0400040          ORR      r0,r0,#0x40
0003b4  6108              STR      r0,[r1,#0x10]
;;;549        /* Wait for last operation to be completed */
;;;550        status = FLASH_WaitForLastOperation(EraseTimeout);
0003b6  f64070ff          MOV      r0,#0xfff
0003ba  f7fffffe          BL       FLASH_WaitForLastOperation
0003be  4604              MOV      r4,r0
;;;551        if(status == FLASH_COMPLETE)
0003c0  2c04              CMP      r4,#4
0003c2  d131              BNE      |L1.1064|
;;;552        {
;;;553          /* if the erase operation is completed, disable the OPTER Bit */
;;;554          FLASH->CR &= CR_OPTER_Reset;
0003c4  4808              LDR      r0,|L1.1000|
0003c6  6900              LDR      r0,[r0,#0x10]
0003c8  f64171df          MOV      r1,#0x1fdf
0003cc  4008              ANDS     r0,r0,r1
0003ce  4906              LDR      r1,|L1.1000|
0003d0  6108              STR      r0,[r1,#0x10]
;;;555          /* Enable the Option Bytes Programming operation */
;;;556          FLASH->CR |= CR_OPTPG_Set; 
0003d2  4608              MOV      r0,r1
0003d4  6900              LDR      r0,[r0,#0x10]
0003d6  f0400010          ORR      r0,r0,#0x10
0003da  6108              STR      r0,[r1,#0x10]
;;;557          if(NewState != DISABLE)
0003dc  b195              CBZ      r5,|L1.1028|
;;;558          {
;;;559            OB->RDP = 0x00;
0003de  2000              MOVS     r0,#0
0003e0  4904              LDR      r1,|L1.1012|
0003e2  8008              STRH     r0,[r1,#0]
0003e4  e011              B        |L1.1034|
0003e6  0000              DCW      0x0000
                  |L1.1000|
                          DCD      0x40022000
                  |L1.1004|
                          DCD      0x45670123
                  |L1.1008|
                          DCD      0xcdef89ab
                  |L1.1012|
                          DCD      0x1ffff800
                  |L1.1016|
                          DCD      0x1ffff808
                  |L1.1020|
                          DCD      0x1ffff80a
                  |L1.1024|
                          DCD      0x1ffff000
                  |L1.1028|
;;;560          }
;;;561          else
;;;562          {
;;;563            OB->RDP = RDP_Key;  
000404  20a5              MOVS     r0,#0xa5
000406  4945              LDR      r1,|L1.1308|
000408  8008              STRH     r0,[r1,#0]
                  |L1.1034|
;;;564          }
;;;565          /* Wait for last operation to be completed */
;;;566          status = FLASH_WaitForLastOperation(EraseTimeout); 
00040a  f64070ff          MOV      r0,#0xfff
00040e  f7fffffe          BL       FLASH_WaitForLastOperation
000412  4604              MOV      r4,r0
;;;567        
;;;568          if(status != FLASH_BUSY)
000414  2c01              CMP      r4,#1
000416  d010              BEQ      |L1.1082|
;;;569          {
;;;570            /* if the program operation is completed, disable the OPTPG Bit */
;;;571            FLASH->CR &= CR_OPTPG_Reset;
000418  4841              LDR      r0,|L1.1312|
00041a  6900              LDR      r0,[r0,#0x10]
00041c  f64171ef          MOV      r1,#0x1fef
000420  4008              ANDS     r0,r0,r1
000422  493f              LDR      r1,|L1.1312|
000424  6108              STR      r0,[r1,#0x10]
000426  e008              B        |L1.1082|
                  |L1.1064|
;;;572          }
;;;573        }
;;;574        else 
;;;575        {
;;;576          if(status != FLASH_BUSY)
000428  2c01              CMP      r4,#1
00042a  d006              BEQ      |L1.1082|
;;;577          {
;;;578            /* Disable the OPTER Bit */
;;;579            FLASH->CR &= CR_OPTER_Reset;
00042c  483c              LDR      r0,|L1.1312|
00042e  6900              LDR      r0,[r0,#0x10]
000430  f64171df          MOV      r1,#0x1fdf
000434  4008              ANDS     r0,r0,r1
000436  493a              LDR      r1,|L1.1312|
000438  6108              STR      r0,[r1,#0x10]
                  |L1.1082|
;;;580          }
;;;581        }
;;;582      }
;;;583      /* Return the protection operation Status */
;;;584      return status;      
00043a  4620              MOV      r0,r4
;;;585    }
00043c  bd70              POP      {r4-r6,pc}
;;;586    
                          ENDP

                  FLASH_UserOptionByteConfig PROC
;;;605      */
;;;606    FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
00043e  e92d41f0          PUSH     {r4-r8,lr}
;;;607    {
000442  4607              MOV      r7,r0
000444  460d              MOV      r5,r1
000446  4616              MOV      r6,r2
;;;608      FLASH_Status status = FLASH_COMPLETE; 
000448  2404              MOVS     r4,#4
;;;609      /* Check the parameters */
;;;610      assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;611      assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;612      assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;613      /* Authorize the small information block programming */
;;;614      FLASH->OPTKEYR = FLASH_KEY1;
00044a  4836              LDR      r0,|L1.1316|
00044c  4934              LDR      r1,|L1.1312|
00044e  6088              STR      r0,[r1,#8]
;;;615      FLASH->OPTKEYR = FLASH_KEY2;
000450  4835              LDR      r0,|L1.1320|
000452  6088              STR      r0,[r1,#8]
;;;616      
;;;617      /* Wait for last operation to be completed */
;;;618      status = FLASH_WaitForLastOperation(ProgramTimeout);
000454  200f              MOVS     r0,#0xf
000456  f7fffffe          BL       FLASH_WaitForLastOperation
00045a  4604              MOV      r4,r0
;;;619      
;;;620      if(status == FLASH_COMPLETE)
00045c  2c04              CMP      r4,#4
00045e  d11a              BNE      |L1.1174|
;;;621      {  
;;;622        /* Enable the Option Bytes Programming operation */
;;;623        FLASH->CR |= CR_OPTPG_Set; 
000460  482f              LDR      r0,|L1.1312|
000462  6900              LDR      r0,[r0,#0x10]
000464  f0400010          ORR      r0,r0,#0x10
000468  492d              LDR      r1,|L1.1312|
00046a  6108              STR      r0,[r1,#0x10]
;;;624               
;;;625        OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (uint16_t)0xF8; 
00046c  ea470005          ORR      r0,r7,r5
000470  4330              ORRS     r0,r0,r6
000472  f04000f8          ORR      r0,r0,#0xf8
000476  492d              LDR      r1,|L1.1324|
000478  8008              STRH     r0,[r1,#0]
;;;626      
;;;627        /* Wait for last operation to be completed */
;;;628        status = FLASH_WaitForLastOperation(ProgramTimeout);
00047a  f04f000f          MOV      r0,#0xf
00047e  f7fffffe          BL       FLASH_WaitForLastOperation
000482  4604              MOV      r4,r0
;;;629        if(status != FLASH_BUSY)
000484  2c01              CMP      r4,#1
000486  d006              BEQ      |L1.1174|
;;;630        {
;;;631          /* if the program operation is completed, disable the OPTPG Bit */
;;;632          FLASH->CR &= CR_OPTPG_Reset;
000488  4825              LDR      r0,|L1.1312|
00048a  6900              LDR      r0,[r0,#0x10]
00048c  f64171ef          MOV      r1,#0x1fef
000490  4008              ANDS     r0,r0,r1
000492  4923              LDR      r1,|L1.1312|
000494  6108              STR      r0,[r1,#0x10]
                  |L1.1174|
;;;633        }
;;;634      }    
;;;635      /* Return the Option Byte program Status */
;;;636      return status;
000496  4620              MOV      r0,r4
;;;637    }
000498  e8bd81f0          POP      {r4-r8,pc}
;;;638    
                          ENDP

                  FLASH_GetUserOptionByte PROC
;;;644      */
;;;645    uint32_t FLASH_GetUserOptionByte(void)
00049c  4820              LDR      r0,|L1.1312|
;;;646    {
;;;647      /* Return the User Option Byte */
;;;648      return (uint32_t)(FLASH->OBR >> 2);
00049e  69c0              LDR      r0,[r0,#0x1c]
0004a0  0880              LSRS     r0,r0,#2
;;;649    }
0004a2  4770              BX       lr
;;;650    
                          ENDP

                  FLASH_GetWriteProtectionOptionByte PROC
;;;655      */
;;;656    uint32_t FLASH_GetWriteProtectionOptionByte(void)
0004a4  481e              LDR      r0,|L1.1312|
;;;657    {
;;;658      /* Return the Falsh write protection Register value */
;;;659      return (uint32_t)(FLASH->WRPR);
0004a6  6a00              LDR      r0,[r0,#0x20]
;;;660    }
0004a8  4770              BX       lr
;;;661    
                          ENDP

                  FLASH_GetReadOutProtectionStatus PROC
;;;667      */
;;;668    FlagStatus FLASH_GetReadOutProtectionStatus(void)
0004aa  2000              MOVS     r0,#0
;;;669    {
;;;670      FlagStatus readoutstatus = RESET;
;;;671      if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
0004ac  491c              LDR      r1,|L1.1312|
0004ae  69c9              LDR      r1,[r1,#0x1c]
0004b0  f0110f02          TST      r1,#2
0004b4  d001              BEQ      |L1.1210|
;;;672      {
;;;673        readoutstatus = SET;
0004b6  2001              MOVS     r0,#1
0004b8  e000              B        |L1.1212|
                  |L1.1210|
;;;674      }
;;;675      else
;;;676      {
;;;677        readoutstatus = RESET;
0004ba  2000              MOVS     r0,#0
                  |L1.1212|
;;;678      }
;;;679      return readoutstatus;
;;;680    }
0004bc  4770              BX       lr
;;;681    
                          ENDP

                  FLASH_GetPrefetchBufferStatus PROC
;;;686      */
;;;687    FlagStatus FLASH_GetPrefetchBufferStatus(void)
0004be  2000              MOVS     r0,#0
;;;688    {
;;;689      FlagStatus bitstatus = RESET;
;;;690      
;;;691      if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
0004c0  4917              LDR      r1,|L1.1312|
0004c2  6809              LDR      r1,[r1,#0]
0004c4  f0110f20          TST      r1,#0x20
0004c8  d001              BEQ      |L1.1230|
;;;692      {
;;;693        bitstatus = SET;
0004ca  2001              MOVS     r0,#1
0004cc  e000              B        |L1.1232|
                  |L1.1230|
;;;694      }
;;;695      else
;;;696      {
;;;697        bitstatus = RESET;
0004ce  2000              MOVS     r0,#0
                  |L1.1232|
;;;698      }
;;;699      /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;700      return bitstatus; 
;;;701    }
0004d0  4770              BX       lr
;;;702    
                          ENDP

                  FLASH_ITConfig PROC
;;;713      */
;;;714    void FLASH_ITConfig(uint16_t FLASH_IT, FunctionalState NewState)
0004d2  b129              CBZ      r1,|L1.1248|
;;;715    {
;;;716      /* Check the parameters */
;;;717      assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;718      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;719      if(NewState != DISABLE)
;;;720      {
;;;721        /* Enable the interrupt sources */
;;;722        FLASH->CR |= FLASH_IT;
0004d4  4a12              LDR      r2,|L1.1312|
0004d6  6912              LDR      r2,[r2,#0x10]
0004d8  4302              ORRS     r2,r2,r0
0004da  4b11              LDR      r3,|L1.1312|
0004dc  611a              STR      r2,[r3,#0x10]
0004de  e004              B        |L1.1258|
                  |L1.1248|
;;;723      }
;;;724      else
;;;725      {
;;;726        /* Disable the interrupt sources */
;;;727        FLASH->CR &= ~(uint32_t)FLASH_IT;
0004e0  4a0f              LDR      r2,|L1.1312|
0004e2  6912              LDR      r2,[r2,#0x10]
0004e4  4382              BICS     r2,r2,r0
0004e6  4b0e              LDR      r3,|L1.1312|
0004e8  611a              STR      r2,[r3,#0x10]
                  |L1.1258|
;;;728      }
;;;729    }
0004ea  4770              BX       lr
;;;730    
                          ENDP

                  FLASH_GetFlagStatus PROC
;;;741      */
;;;742    FlagStatus FLASH_GetFlagStatus(uint16_t FLASH_FLAG)
0004ec  4601              MOV      r1,r0
;;;743    {
;;;744      FlagStatus bitstatus = RESET;
0004ee  2000              MOVS     r0,#0
;;;745      /* Check the parameters */
;;;746      assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;747      if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
0004f0  2901              CMP      r1,#1
0004f2  d108              BNE      |L1.1286|
;;;748      {
;;;749        if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
0004f4  4a0a              LDR      r2,|L1.1312|
0004f6  69d2              LDR      r2,[r2,#0x1c]
0004f8  f0120f01          TST      r2,#1
0004fc  d001              BEQ      |L1.1282|
;;;750        {
;;;751          bitstatus = SET;
0004fe  2001              MOVS     r0,#1
000500  e008              B        |L1.1300|
                  |L1.1282|
;;;752        }
;;;753        else
;;;754        {
;;;755          bitstatus = RESET;
000502  2000              MOVS     r0,#0
000504  e006              B        |L1.1300|
                  |L1.1286|
;;;756        }
;;;757      }
;;;758      else
;;;759      {
;;;760       if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
000506  4a06              LDR      r2,|L1.1312|
000508  68d2              LDR      r2,[r2,#0xc]
00050a  420a              TST      r2,r1
00050c  d001              BEQ      |L1.1298|
;;;761        {
;;;762          bitstatus = SET;
00050e  2001              MOVS     r0,#1
000510  e000              B        |L1.1300|
                  |L1.1298|
;;;763        }
;;;764        else
;;;765        {
;;;766          bitstatus = RESET;
000512  2000              MOVS     r0,#0
                  |L1.1300|
;;;767        }
;;;768      }
;;;769      /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;770      return bitstatus;
;;;771    }
000514  4770              BX       lr
;;;772    
                          ENDP

                  FLASH_ClearFlag PROC
;;;782      */
;;;783    void FLASH_ClearFlag(uint16_t FLASH_FLAG)
000516  4902              LDR      r1,|L1.1312|
;;;784    {
;;;785      /* Check the parameters */
;;;786      assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;787      
;;;788      /* Clear the flags */
;;;789      FLASH->SR = FLASH_FLAG;
000518  60c8              STR      r0,[r1,#0xc]
;;;790    }
00051a  4770              BX       lr
;;;791    
                          ENDP

                  |L1.1308|
                          DCD      0x1ffff800
                  |L1.1312|
                          DCD      0x40022000
                  |L1.1316|
                          DCD      0x45670123
                  |L1.1320|
                          DCD      0xcdef89ab
                  |L1.1324|
                          DCD      0x1ffff802
