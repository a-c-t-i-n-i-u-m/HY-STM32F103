; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\obj\stm32f10x_tim.o --depend=.\obj\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\stm32f10x_tim.crf FWlib\SRC\stm32f10x_tim.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;187      */
;;;188    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;189    {
000002  4604              MOV      r4,r0
;;;190      /* Check the parameters */
;;;191      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;192     
;;;193      switch (*(uint32_t*)&TIMx)
000004  49fb              LDR      r1,|L1.1012|
000006  1a60              SUBS     r0,r4,r1
000008  428c              CMP      r4,r1
00000a  d045              BEQ      |L1.152|
00000c  dc0c              BGT      |L1.40|
00000e  f1b44f80          CMP      r4,#0x40000000
000012  d01d              BEQ      |L1.80|
000014  48f8              LDR      r0,|L1.1016|
000016  1820              ADDS     r0,r4,r0
000018  d023              BEQ      |L1.98|
00001a  f5b06f80          CMP      r0,#0x400
00001e  d029              BEQ      |L1.116|
000020  f5b06f00          CMP      r0,#0x800
000024  d154              BNE      |L1.208|
000026  e02e              B        |L1.134|
                  |L1.40|
000028  f5b06f80          CMP      r0,#0x400
00002c  d03d              BEQ      |L1.170|
00002e  f5b03f8e          CMP      r0,#0x11c00
000032  d003              BEQ      |L1.60|
000034  f5b03f92          CMP      r0,#0x12400
000038  d14a              BNE      |L1.208|
00003a  e03f              B        |L1.188|
                  |L1.60|
;;;194      {
;;;195        case TIM1_BASE:
;;;196          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  02c8              LSLS     r0,r1,#11
000040  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;197          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000044  2100              MOVS     r1,#0
000046  f44f6000          MOV      r0,#0x800
00004a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;198          break; 
00004e  e040              B        |L1.210|
                  |L1.80|
;;;199          
;;;200        case TIM2_BASE:
;;;201          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000050  2101              MOVS     r1,#1
000052  4608              MOV      r0,r1
000054  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;202          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
000058  2100              MOVS     r1,#0
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;203          break;
000060  e037              B        |L1.210|
                  |L1.98|
;;;204     
;;;205        case TIM3_BASE:
;;;206          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
000062  2101              MOVS     r1,#1
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;207          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
00006a  2100              MOVS     r1,#0
00006c  2002              MOVS     r0,#2
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;208          break;
000072  e02e              B        |L1.210|
                  |L1.116|
;;;209     
;;;210        case TIM4_BASE:
;;;211          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000074  2101              MOVS     r1,#1
000076  2004              MOVS     r0,#4
000078  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;212          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00007c  2100              MOVS     r1,#0
00007e  2004              MOVS     r0,#4
000080  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;213          break;
000084  e025              B        |L1.210|
                  |L1.134|
;;;214          
;;;215        case TIM5_BASE:
;;;216          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000086  2101              MOVS     r1,#1
000088  2008              MOVS     r0,#8
00008a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;217          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
00008e  2100              MOVS     r1,#0
000090  2008              MOVS     r0,#8
000092  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;218          break;
000096  e01c              B        |L1.210|
                  |L1.152|
;;;219          
;;;220        case TIM6_BASE:
;;;221          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000098  2101              MOVS     r1,#1
00009a  2010              MOVS     r0,#0x10
00009c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;222          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
0000a0  2100              MOVS     r1,#0
0000a2  2010              MOVS     r0,#0x10
0000a4  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;223          break;
0000a8  e013              B        |L1.210|
                  |L1.170|
;;;224          
;;;225        case TIM7_BASE:
;;;226          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
0000aa  2101              MOVS     r1,#1
0000ac  2020              MOVS     r0,#0x20
0000ae  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;227          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000b2  2100              MOVS     r1,#0
0000b4  2020              MOVS     r0,#0x20
0000b6  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;228          break;
0000ba  e00a              B        |L1.210|
                  |L1.188|
;;;229          
;;;230        case TIM8_BASE:
;;;231          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000bc  2101              MOVS     r1,#1
0000be  0348              LSLS     r0,r1,#13
0000c0  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;232          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
0000c4  2100              MOVS     r1,#0
0000c6  f44f5000          MOV      r0,#0x2000
0000ca  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;233          break; 
0000ce  e000              B        |L1.210|
                  |L1.208|
;;;234          
;;;235        default:
;;;236          break;
0000d0  bf00              NOP      
                  |L1.210|
0000d2  bf00              NOP                            ;198
;;;237      }
;;;238    }
0000d4  bd10              POP      {r4,pc}
;;;239    
                          ENDP

                  TIM_TimeBaseInit PROC
;;;249      */
;;;250    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
0000d6  8802              LDRH     r2,[r0,#0]
;;;251    {
;;;252      /* Check the parameters */
;;;253      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;254      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;255      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;256      /* Select the Counter Mode and set the clock division */
;;;257      TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
0000d8  f002028f          AND      r2,r2,#0x8f
0000dc  8002              STRH     r2,[r0,#0]
;;;258      TIMx->CR1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision |
0000de  88ca              LDRH     r2,[r1,#6]
0000e0  884b              LDRH     r3,[r1,#2]
0000e2  431a              ORRS     r2,r2,r3
0000e4  8803              LDRH     r3,[r0,#0]
0000e6  431a              ORRS     r2,r2,r3
0000e8  8002              STRH     r2,[r0,#0]
;;;259                    TIM_TimeBaseInitStruct->TIM_CounterMode;
;;;260      
;;;261      /* Set the Autoreload value */
;;;262      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
0000ea  888a              LDRH     r2,[r1,#4]
0000ec  8582              STRH     r2,[r0,#0x2c]
;;;263     
;;;264      /* Set the Prescaler value */
;;;265      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
0000ee  880a              LDRH     r2,[r1,#0]
0000f0  8502              STRH     r2,[r0,#0x28]
;;;266        
;;;267      if (((*(uint32_t*)&TIMx) == TIM1_BASE) || ((*(uint32_t*)&TIMx) == TIM8_BASE))  
0000f2  4ac2              LDR      r2,|L1.1020|
0000f4  4290              CMP      r0,r2
0000f6  d002              BEQ      |L1.254|
0000f8  4ac1              LDR      r2,|L1.1024|
0000fa  4290              CMP      r0,r2
0000fc  d101              BNE      |L1.258|
                  |L1.254|
;;;268      {
;;;269        /* Set the Repetition Counter value */
;;;270        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
0000fe  7a0a              LDRB     r2,[r1,#8]
000100  8602              STRH     r2,[r0,#0x30]
                  |L1.258|
;;;271      }
;;;272    
;;;273      /* Generate an update event to reload the Prescaler value immediatly */
;;;274      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
000102  2201              MOVS     r2,#1
000104  8282              STRH     r2,[r0,#0x14]
;;;275    }
000106  4770              BX       lr
;;;276    
                          ENDP

                  TIM_OC1Init PROC
;;;286      */
;;;287    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000108  b570              PUSH     {r4-r6,lr}
;;;288    {
;;;289      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
00010a  2400              MOVS     r4,#0
00010c  2200              MOVS     r2,#0
00010e  2300              MOVS     r3,#0
;;;290       
;;;291      /* Check the parameters */
;;;292      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;293      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;294      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;295      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;296      /* Disable the Channel 1: Reset the CC1E Bit */
;;;297      TIMx->CCER &= CCER_CC1E_Reset;
000110  8c05              LDRH     r5,[r0,#0x20]
000112  f64f76fe          MOV      r6,#0xfffe
000116  4035              ANDS     r5,r5,r6
000118  8405              STRH     r5,[r0,#0x20]
;;;298      
;;;299      /* Get the TIMx CCER register value */
;;;300      tmpccer = TIMx->CCER;
00011a  8c02              LDRH     r2,[r0,#0x20]
;;;301      /* Get the TIMx CR2 register value */
;;;302      tmpcr2 =  TIMx->CR2;
00011c  8883              LDRH     r3,[r0,#4]
;;;303      
;;;304      /* Get the TIMx CCMR1 register value */
;;;305      tmpccmrx = TIMx->CCMR1;
00011e  8b04              LDRH     r4,[r0,#0x18]
;;;306        
;;;307      /* Reset the Output Compare Mode Bits */
;;;308      tmpccmrx &= CCMR_OC13M_Mask;
000120  f64f758f          MOV      r5,#0xff8f
000124  402c              ANDS     r4,r4,r5
;;;309      
;;;310      /* Select the Output Compare Mode */
;;;311      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000126  880d              LDRH     r5,[r1,#0]
000128  432c              ORRS     r4,r4,r5
;;;312      
;;;313      /* Reset the Output Polarity level */
;;;314      tmpccer &= CCER_CC1P_Reset;
00012a  1e75              SUBS     r5,r6,#1
00012c  402a              ANDS     r2,r2,r5
;;;315      /* Set the Output Compare Polarity */
;;;316      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00012e  890d              LDRH     r5,[r1,#8]
000130  432a              ORRS     r2,r2,r5
;;;317      
;;;318      /* Set the Output State */
;;;319      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000132  884d              LDRH     r5,[r1,#2]
000134  432a              ORRS     r2,r2,r5
;;;320      
;;;321      /* Set the Capture Compare Register value */
;;;322      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
000136  88cd              LDRH     r5,[r1,#6]
000138  8685              STRH     r5,[r0,#0x34]
;;;323      
;;;324      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
00013a  4db0              LDR      r5,|L1.1020|
00013c  42a8              CMP      r0,r5
00013e  d002              BEQ      |L1.326|
000140  4daf              LDR      r5,|L1.1024|
000142  42a8              CMP      r0,r5
000144  d113              BNE      |L1.366|
                  |L1.326|
;;;325      {
;;;326        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;327        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;328        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;329        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;330        
;;;331        /* Reset the Output N Polarity level */
;;;332        tmpccer &= CCER_CC1NP_Reset;
000146  f64f75f7          MOV      r5,#0xfff7
00014a  402a              ANDS     r2,r2,r5
;;;333        /* Set the Output N Polarity */
;;;334        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
00014c  894d              LDRH     r5,[r1,#0xa]
00014e  432a              ORRS     r2,r2,r5
;;;335        /* Reset the Output N State */
;;;336        tmpccer &= CCER_CC1NE_Reset;
000150  f64f75fb          MOV      r5,#0xfffb
000154  402a              ANDS     r2,r2,r5
;;;337        
;;;338        /* Set the Output N State */
;;;339        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
000156  888d              LDRH     r5,[r1,#4]
000158  432a              ORRS     r2,r2,r5
;;;340        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;341        tmpcr2 &= CR2_OIS1_Reset;
00015a  f64765ff          MOV      r5,#0x7eff
00015e  402b              ANDS     r3,r3,r5
;;;342        tmpcr2 &= CR2_OIS1N_Reset;
000160  f64755ff          MOV      r5,#0x7dff
000164  402b              ANDS     r3,r3,r5
;;;343        /* Set the Output Idle state */
;;;344        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000166  898d              LDRH     r5,[r1,#0xc]
000168  432b              ORRS     r3,r3,r5
;;;345        /* Set the Output N Idle state */
;;;346        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
00016a  89cd              LDRH     r5,[r1,#0xe]
00016c  432b              ORRS     r3,r3,r5
                  |L1.366|
;;;347      }
;;;348      /* Write to TIMx CR2 */
;;;349      TIMx->CR2 = tmpcr2;
00016e  8083              STRH     r3,[r0,#4]
;;;350      
;;;351      /* Write to TIMx CCMR1 */
;;;352      TIMx->CCMR1 = tmpccmrx;
000170  8304              STRH     r4,[r0,#0x18]
;;;353      
;;;354      /* Write to TIMx CCER */
;;;355      TIMx->CCER = tmpccer;
000172  8402              STRH     r2,[r0,#0x20]
;;;356    }
000174  bd70              POP      {r4-r6,pc}
;;;357    
                          ENDP

                  TIM_OC2Init PROC
;;;367      */
;;;368    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000176  b570              PUSH     {r4-r6,lr}
;;;369    {
;;;370      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000178  2400              MOVS     r4,#0
00017a  2200              MOVS     r2,#0
00017c  2300              MOVS     r3,#0
;;;371       
;;;372      /* Check the parameters */
;;;373      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;374      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;375      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;376      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;377      /* Disable the Channel 2: Reset the CC2E Bit */
;;;378      TIMx->CCER &= CCER_CC2E_Reset;
00017e  8c05              LDRH     r5,[r0,#0x20]
000180  f64f76ef          MOV      r6,#0xffef
000184  4035              ANDS     r5,r5,r6
000186  8405              STRH     r5,[r0,#0x20]
;;;379      
;;;380      /* Get the TIMx CCER register value */  
;;;381      tmpccer = TIMx->CCER;
000188  8c02              LDRH     r2,[r0,#0x20]
;;;382      /* Get the TIMx CR2 register value */
;;;383      tmpcr2 =  TIMx->CR2;
00018a  8883              LDRH     r3,[r0,#4]
;;;384      
;;;385      /* Get the TIMx CCMR1 register value */
;;;386      tmpccmrx = TIMx->CCMR1;
00018c  8b04              LDRH     r4,[r0,#0x18]
;;;387        
;;;388      /* Reset the Output Compare Mode Bits */
;;;389      tmpccmrx &= CCMR_OC24M_Mask;
00018e  f64875ff          MOV      r5,#0x8fff
000192  402c              ANDS     r4,r4,r5
;;;390      
;;;391      /* Select the Output Compare Mode */
;;;392      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000194  880d              LDRH     r5,[r1,#0]
000196  062d              LSLS     r5,r5,#24
000198  ea444415          ORR      r4,r4,r5,LSR #16
;;;393      
;;;394      /* Reset the Output Polarity level */
;;;395      tmpccer &= CCER_CC2P_Reset;
00019c  f64f75df          MOV      r5,#0xffdf
0001a0  402a              ANDS     r2,r2,r5
;;;396      /* Set the Output Compare Polarity */
;;;397      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
0001a2  890d              LDRH     r5,[r1,#8]
0001a4  052d              LSLS     r5,r5,#20
0001a6  ea424215          ORR      r2,r2,r5,LSR #16
;;;398      
;;;399      /* Set the Output State */
;;;400      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
0001aa  884d              LDRH     r5,[r1,#2]
0001ac  052d              LSLS     r5,r5,#20
0001ae  ea424215          ORR      r2,r2,r5,LSR #16
;;;401      
;;;402      /* Set the Capture Compare Register value */
;;;403      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
0001b2  88cd              LDRH     r5,[r1,#6]
0001b4  8705              STRH     r5,[r0,#0x38]
;;;404      
;;;405      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
0001b6  4d91              LDR      r5,|L1.1020|
0001b8  42a8              CMP      r0,r5
0001ba  d002              BEQ      |L1.450|
0001bc  4d90              LDR      r5,|L1.1024|
0001be  42a8              CMP      r0,r5
0001c0  d11b              BNE      |L1.506|
                  |L1.450|
;;;406      {
;;;407        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;408        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;409        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;410        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;411        
;;;412        /* Reset the Output N Polarity level */
;;;413        tmpccer &= CCER_CC2NP_Reset;
0001c2  f64f757f          MOV      r5,#0xff7f
0001c6  402a              ANDS     r2,r2,r5
;;;414        /* Set the Output N Polarity */
;;;415        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
0001c8  894d              LDRH     r5,[r1,#0xa]
0001ca  052d              LSLS     r5,r5,#20
0001cc  ea424215          ORR      r2,r2,r5,LSR #16
;;;416        /* Reset the Output N State */
;;;417        tmpccer &= CCER_CC2NE_Reset;
0001d0  f64f75bf          MOV      r5,#0xffbf
0001d4  402a              ANDS     r2,r2,r5
;;;418        
;;;419        /* Set the Output N State */
;;;420        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
0001d6  888d              LDRH     r5,[r1,#4]
0001d8  052d              LSLS     r5,r5,#20
0001da  ea424215          ORR      r2,r2,r5,LSR #16
;;;421        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;422        tmpcr2 &= CR2_OIS2_Reset;
0001de  f64735ff          MOV      r5,#0x7bff
0001e2  402b              ANDS     r3,r3,r5
;;;423        tmpcr2 &= CR2_OIS2N_Reset;
0001e4  f24775ff          MOV      r5,#0x77ff
0001e8  402b              ANDS     r3,r3,r5
;;;424        /* Set the Output Idle state */
;;;425        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
0001ea  898d              LDRH     r5,[r1,#0xc]
0001ec  04ad              LSLS     r5,r5,#18
0001ee  ea434315          ORR      r3,r3,r5,LSR #16
;;;426        /* Set the Output N Idle state */
;;;427        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
0001f2  89cd              LDRH     r5,[r1,#0xe]
0001f4  04ad              LSLS     r5,r5,#18
0001f6  ea434315          ORR      r3,r3,r5,LSR #16
                  |L1.506|
;;;428      }
;;;429      /* Write to TIMx CR2 */
;;;430      TIMx->CR2 = tmpcr2;
0001fa  8083              STRH     r3,[r0,#4]
;;;431      
;;;432      /* Write to TIMx CCMR1 */
;;;433      TIMx->CCMR1 = tmpccmrx;
0001fc  8304              STRH     r4,[r0,#0x18]
;;;434      
;;;435      /* Write to TIMx CCER */
;;;436      TIMx->CCER = tmpccer;
0001fe  8402              STRH     r2,[r0,#0x20]
;;;437    }
000200  bd70              POP      {r4-r6,pc}
;;;438    
                          ENDP

                  TIM_OC3Init PROC
;;;448      */
;;;449    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000202  b570              PUSH     {r4-r6,lr}
;;;450    {
;;;451      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000204  2400              MOVS     r4,#0
000206  2200              MOVS     r2,#0
000208  2300              MOVS     r3,#0
;;;452       
;;;453      /* Check the parameters */
;;;454      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;455      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;456      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;457      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;458      /* Disable the Channel 2: Reset the CC2E Bit */
;;;459      TIMx->CCER &= CCER_CC3E_Reset;
00020a  8c05              LDRH     r5,[r0,#0x20]
00020c  f64f66ff          MOV      r6,#0xfeff
000210  4035              ANDS     r5,r5,r6
000212  8405              STRH     r5,[r0,#0x20]
;;;460      
;;;461      /* Get the TIMx CCER register value */
;;;462      tmpccer = TIMx->CCER;
000214  8c02              LDRH     r2,[r0,#0x20]
;;;463      /* Get the TIMx CR2 register value */
;;;464      tmpcr2 =  TIMx->CR2;
000216  8883              LDRH     r3,[r0,#4]
;;;465      
;;;466      /* Get the TIMx CCMR2 register value */
;;;467      tmpccmrx = TIMx->CCMR2;
000218  8b84              LDRH     r4,[r0,#0x1c]
;;;468        
;;;469      /* Reset the Output Compare Mode Bits */
;;;470      tmpccmrx &= CCMR_OC13M_Mask;
00021a  f64f758f          MOV      r5,#0xff8f
00021e  402c              ANDS     r4,r4,r5
;;;471      
;;;472      /* Select the Output Compare Mode */
;;;473      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000220  880d              LDRH     r5,[r1,#0]
000222  432c              ORRS     r4,r4,r5
;;;474      
;;;475      /* Reset the Output Polarity level */
;;;476      tmpccer &= CCER_CC3P_Reset;
000224  f64f55ff          MOV      r5,#0xfdff
000228  402a              ANDS     r2,r2,r5
;;;477      /* Set the Output Compare Polarity */
;;;478      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
00022a  890d              LDRH     r5,[r1,#8]
00022c  062d              LSLS     r5,r5,#24
00022e  ea424215          ORR      r2,r2,r5,LSR #16
;;;479      
;;;480      /* Set the Output State */
;;;481      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000232  884d              LDRH     r5,[r1,#2]
000234  062d              LSLS     r5,r5,#24
000236  ea424215          ORR      r2,r2,r5,LSR #16
;;;482      
;;;483      /* Set the Capture Compare Register value */
;;;484      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
00023a  88cd              LDRH     r5,[r1,#6]
00023c  8785              STRH     r5,[r0,#0x3c]
;;;485      
;;;486      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
00023e  4d6f              LDR      r5,|L1.1020|
000240  42a8              CMP      r0,r5
000242  d002              BEQ      |L1.586|
000244  4d6e              LDR      r5,|L1.1024|
000246  42a8              CMP      r0,r5
000248  d11b              BNE      |L1.642|
                  |L1.586|
;;;487      {
;;;488        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;489        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;490        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;491        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;492        
;;;493        /* Reset the Output N Polarity level */
;;;494        tmpccer &= CCER_CC3NP_Reset;
00024a  f24f75ff          MOV      r5,#0xf7ff
00024e  402a              ANDS     r2,r2,r5
;;;495        /* Set the Output N Polarity */
;;;496        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000250  894d              LDRH     r5,[r1,#0xa]
000252  062d              LSLS     r5,r5,#24
000254  ea424215          ORR      r2,r2,r5,LSR #16
;;;497        /* Reset the Output N State */
;;;498        tmpccer &= CCER_CC3NE_Reset;
000258  f64f35ff          MOV      r5,#0xfbff
00025c  402a              ANDS     r2,r2,r5
;;;499        
;;;500        /* Set the Output N State */
;;;501        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
00025e  888d              LDRH     r5,[r1,#4]
000260  062d              LSLS     r5,r5,#24
000262  ea424215          ORR      r2,r2,r5,LSR #16
;;;502        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;503        tmpcr2 &= CR2_OIS3_Reset;
000266  f64675ff          MOV      r5,#0x6fff
00026a  402b              ANDS     r3,r3,r5
;;;504        tmpcr2 &= CR2_OIS3N_Reset;
00026c  f64575ff          MOV      r5,#0x5fff
000270  402b              ANDS     r3,r3,r5
;;;505        /* Set the Output Idle state */
;;;506        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000272  898d              LDRH     r5,[r1,#0xc]
000274  052d              LSLS     r5,r5,#20
000276  ea434315          ORR      r3,r3,r5,LSR #16
;;;507        /* Set the Output N Idle state */
;;;508        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
00027a  89cd              LDRH     r5,[r1,#0xe]
00027c  052d              LSLS     r5,r5,#20
00027e  ea434315          ORR      r3,r3,r5,LSR #16
                  |L1.642|
;;;509      }
;;;510      /* Write to TIMx CR2 */
;;;511      TIMx->CR2 = tmpcr2;
000282  8083              STRH     r3,[r0,#4]
;;;512      
;;;513      /* Write to TIMx CCMR2 */
;;;514      TIMx->CCMR2 = tmpccmrx;
000284  8384              STRH     r4,[r0,#0x1c]
;;;515      
;;;516      /* Write to TIMx CCER */
;;;517      TIMx->CCER = tmpccer;
000286  8402              STRH     r2,[r0,#0x20]
;;;518    }
000288  bd70              POP      {r4-r6,pc}
;;;519    
                          ENDP

                  TIM_OC4Init PROC
;;;529      */
;;;530    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
00028a  b570              PUSH     {r4-r6,lr}
;;;531    {
;;;532      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
00028c  2300              MOVS     r3,#0
00028e  2200              MOVS     r2,#0
000290  2400              MOVS     r4,#0
;;;533       
;;;534      /* Check the parameters */
;;;535      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;536      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;537      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;538      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;539      /* Disable the Channel 2: Reset the CC4E Bit */
;;;540      TIMx->CCER &= CCER_CC4E_Reset;
000292  8c05              LDRH     r5,[r0,#0x20]
000294  f64e76ff          MOV      r6,#0xefff
000298  4035              ANDS     r5,r5,r6
00029a  8405              STRH     r5,[r0,#0x20]
;;;541      
;;;542      /* Get the TIMx CCER register value */
;;;543      tmpccer = TIMx->CCER;
00029c  8c02              LDRH     r2,[r0,#0x20]
;;;544      /* Get the TIMx CR2 register value */
;;;545      tmpcr2 =  TIMx->CR2;
00029e  8884              LDRH     r4,[r0,#4]
;;;546      
;;;547      /* Get the TIMx CCMR2 register value */
;;;548      tmpccmrx = TIMx->CCMR2;
0002a0  8b83              LDRH     r3,[r0,#0x1c]
;;;549        
;;;550      /* Reset the Output Compare Mode Bits */
;;;551      tmpccmrx &= CCMR_OC24M_Mask;
0002a2  f64875ff          MOV      r5,#0x8fff
0002a6  402b              ANDS     r3,r3,r5
;;;552      
;;;553      /* Select the Output Compare Mode */
;;;554      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
0002a8  880d              LDRH     r5,[r1,#0]
0002aa  062d              LSLS     r5,r5,#24
0002ac  ea434315          ORR      r3,r3,r5,LSR #16
;;;555      
;;;556      /* Reset the Output Polarity level */
;;;557      tmpccer &= CCER_CC4P_Reset;
0002b0  f64d75ff          MOV      r5,#0xdfff
0002b4  402a              ANDS     r2,r2,r5
;;;558      /* Set the Output Compare Polarity */
;;;559      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
0002b6  890d              LDRH     r5,[r1,#8]
0002b8  072d              LSLS     r5,r5,#28
0002ba  ea424215          ORR      r2,r2,r5,LSR #16
;;;560      
;;;561      /* Set the Output State */
;;;562      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
0002be  884d              LDRH     r5,[r1,#2]
0002c0  072d              LSLS     r5,r5,#28
0002c2  ea424215          ORR      r2,r2,r5,LSR #16
;;;563      
;;;564      /* Set the Capture Compare Register value */
;;;565      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
0002c6  88cd              LDRH     r5,[r1,#6]
0002c8  f8a05040          STRH     r5,[r0,#0x40]
;;;566      
;;;567      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
0002cc  4d4b              LDR      r5,|L1.1020|
0002ce  42a8              CMP      r0,r5
0002d0  d002              BEQ      |L1.728|
0002d2  4d4b              LDR      r5,|L1.1024|
0002d4  42a8              CMP      r0,r5
0002d6  d105              BNE      |L1.740|
                  |L1.728|
;;;568      {
;;;569        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;570        /* Reset the Ouput Compare IDLE State */
;;;571        tmpcr2 &= CR2_OIS4_Reset;
0002d8  f3c4040d          UBFX     r4,r4,#0,#14
;;;572        /* Set the Output Idle state */
;;;573        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
0002dc  898d              LDRH     r5,[r1,#0xc]
0002de  05ad              LSLS     r5,r5,#22
0002e0  ea444415          ORR      r4,r4,r5,LSR #16
                  |L1.740|
;;;574      }
;;;575      /* Write to TIMx CR2 */
;;;576      TIMx->CR2 = tmpcr2;
0002e4  8084              STRH     r4,[r0,#4]
;;;577      
;;;578      /* Write to TIMx CCMR2 */  
;;;579      TIMx->CCMR2 = tmpccmrx;
0002e6  8383              STRH     r3,[r0,#0x1c]
;;;580      
;;;581      /* Write to TIMx CCER */
;;;582      TIMx->CCER = tmpccer;
0002e8  8402              STRH     r2,[r0,#0x20]
;;;583    }
0002ea  bd70              POP      {r4-r6,pc}
;;;584    
                          ENDP

                  TIM_SetIC4Prescaler PROC
;;;2429     */
;;;2430   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
0002ec  8b82              LDRH     r2,[r0,#0x1c]
;;;2431   {  
;;;2432     /* Check the parameters */
;;;2433     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2434     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2435     /* Reset the IC4PSC Bits */
;;;2436     TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
0002ee  f24f33ff          MOV      r3,#0xf3ff
0002f2  401a              ANDS     r2,r2,r3
0002f4  8382              STRH     r2,[r0,#0x1c]
;;;2437     /* Set the IC4PSC value */
;;;2438     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
0002f6  8b82              LDRH     r2,[r0,#0x1c]
0002f8  060b              LSLS     r3,r1,#24
0002fa  ea424213          ORR      r2,r2,r3,LSR #16
0002fe  8382              STRH     r2,[r0,#0x1c]
;;;2439   }
000300  4770              BX       lr
;;;2440   
                          ENDP

                  TI4_Config PROC
;;;2815     */
;;;2816   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000302  b5f0              PUSH     {r4-r7,lr}
;;;2817                          uint16_t TIM_ICFilter)
;;;2818   {
000304  460c              MOV      r4,r1
000306  4615              MOV      r5,r2
;;;2819     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000308  2100              MOVS     r1,#0
00030a  2200              MOVS     r2,#0
00030c  2600              MOVS     r6,#0
;;;2820     /* Disable the Channel 4: Reset the CC4E Bit */
;;;2821     TIMx->CCER &= CCER_CC4E_Reset;
00030e  8c07              LDRH     r7,[r0,#0x20]
000310  f64e7cff          MOV      r12,#0xefff
000314  ea07070c          AND      r7,r7,r12
000318  8407              STRH     r7,[r0,#0x20]
;;;2822     tmpccmr2 = TIMx->CCMR2;
00031a  8b81              LDRH     r1,[r0,#0x1c]
;;;2823     tmpccer = TIMx->CCER;
00031c  8c02              LDRH     r2,[r0,#0x20]
;;;2824     tmp = (uint16_t)(TIM_ICPolarity << 12);
00031e  0727              LSLS     r7,r4,#28
000320  0c3e              LSRS     r6,r7,#16
;;;2825     /* Select the Input and set the filter */
;;;2826     tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000322  f64047ff          MOV      r7,#0xcff
000326  4039              ANDS     r1,r1,r7
;;;2827     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8) | (uint16_t)(TIM_ICFilter << 12);
000328  062f              LSLS     r7,r5,#24
00032a  0c3f              LSRS     r7,r7,#16
00032c  ea4f7c03          LSL      r12,r3,#28
000330  ea47471c          ORR      r7,r7,r12,LSR #16
000334  4339              ORRS     r1,r1,r7
;;;2828     /* Select the Polarity and set the CC4E Bit */
;;;2829     tmpccer &= CCER_CC4P_Reset;
000336  f64d77ff          MOV      r7,#0xdfff
00033a  403a              ANDS     r2,r2,r7
;;;2830     tmpccer |= tmp | CCER_CC4E_Set;
00033c  f4465780          ORR      r7,r6,#0x1000
000340  433a              ORRS     r2,r2,r7
;;;2831     /* Write to TIMx CCMR2 and CCER registers */
;;;2832     TIMx->CCMR2 = tmpccmr2;
000342  8381              STRH     r1,[r0,#0x1c]
;;;2833     TIMx->CCER = tmpccer ;
000344  8402              STRH     r2,[r0,#0x20]
;;;2834   }
000346  bdf0              POP      {r4-r7,pc}
;;;2835   
                          ENDP

                  TIM_SetIC3Prescaler PROC
;;;2405     */
;;;2406   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000348  8b82              LDRH     r2,[r0,#0x1c]
;;;2407   {
;;;2408     /* Check the parameters */
;;;2409     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2410     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2411     /* Reset the IC3PSC Bits */
;;;2412     TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
00034a  f64f73f3          MOV      r3,#0xfff3
00034e  401a              ANDS     r2,r2,r3
000350  8382              STRH     r2,[r0,#0x1c]
;;;2413     /* Set the IC3PSC value */
;;;2414     TIMx->CCMR2 |= TIM_ICPSC;
000352  8b82              LDRH     r2,[r0,#0x1c]
000354  430a              ORRS     r2,r2,r1
000356  8382              STRH     r2,[r0,#0x1c]
;;;2415   }
000358  4770              BX       lr
;;;2416   
                          ENDP

                  TI3_Config PROC
;;;2775     */
;;;2776   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
00035a  b5f0              PUSH     {r4-r7,lr}
;;;2777                          uint16_t TIM_ICFilter)
;;;2778   {
00035c  460c              MOV      r4,r1
00035e  4615              MOV      r5,r2
;;;2779     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000360  2100              MOVS     r1,#0
000362  2200              MOVS     r2,#0
000364  2600              MOVS     r6,#0
;;;2780     /* Disable the Channel 3: Reset the CC3E Bit */
;;;2781     TIMx->CCER &= CCER_CC3E_Reset;
000366  8c07              LDRH     r7,[r0,#0x20]
000368  f64f6cff          MOV      r12,#0xfeff
00036c  ea07070c          AND      r7,r7,r12
000370  8407              STRH     r7,[r0,#0x20]
;;;2782     tmpccmr2 = TIMx->CCMR2;
000372  8b81              LDRH     r1,[r0,#0x1c]
;;;2783     tmpccer = TIMx->CCER;
000374  8c02              LDRH     r2,[r0,#0x20]
;;;2784     tmp = (uint16_t)(TIM_ICPolarity << 8);
000376  0627              LSLS     r7,r4,#24
000378  0c3e              LSRS     r6,r7,#16
;;;2785     /* Select the Input and set the filter */
;;;2786     tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
00037a  f64f770c          MOV      r7,#0xff0c
00037e  4039              ANDS     r1,r1,r7
;;;2787     tmpccmr2 |= TIM_ICSelection | (uint16_t)(TIM_ICFilter << 4);
000380  051f              LSLS     r7,r3,#20
000382  ea454717          ORR      r7,r5,r7,LSR #16
000386  4339              ORRS     r1,r1,r7
;;;2788     /* Select the Polarity and set the CC3E Bit */
;;;2789     tmpccer &= CCER_CC3P_Reset;
000388  f64f57ff          MOV      r7,#0xfdff
00038c  403a              ANDS     r2,r2,r7
;;;2790     tmpccer |= tmp | CCER_CC3E_Set;
00038e  f4467780          ORR      r7,r6,#0x100
000392  433a              ORRS     r2,r2,r7
;;;2791     /* Write to TIMx CCMR2 and CCER registers */
;;;2792     TIMx->CCMR2 = tmpccmr2;
000394  8381              STRH     r1,[r0,#0x1c]
;;;2793     TIMx->CCER = tmpccer;
000396  8402              STRH     r2,[r0,#0x20]
;;;2794   }
000398  bdf0              POP      {r4-r7,pc}
;;;2795   
                          ENDP

                  TIM_SetIC2Prescaler PROC
;;;2381     */
;;;2382   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
00039a  8b02              LDRH     r2,[r0,#0x18]
;;;2383   {
;;;2384     /* Check the parameters */
;;;2385     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2386     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2387     /* Reset the IC2PSC Bits */
;;;2388     TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
00039c  f24f33ff          MOV      r3,#0xf3ff
0003a0  401a              ANDS     r2,r2,r3
0003a2  8302              STRH     r2,[r0,#0x18]
;;;2389     /* Set the IC2PSC value */
;;;2390     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
0003a4  8b02              LDRH     r2,[r0,#0x18]
0003a6  060b              LSLS     r3,r1,#24
0003a8  ea424213          ORR      r2,r2,r3,LSR #16
0003ac  8302              STRH     r2,[r0,#0x18]
;;;2391   }
0003ae  4770              BX       lr
;;;2392   
                          ENDP

                  TI2_Config PROC
;;;2734     */
;;;2735   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
0003b0  b5f0              PUSH     {r4-r7,lr}
;;;2736                          uint16_t TIM_ICFilter)
;;;2737   {
0003b2  460c              MOV      r4,r1
0003b4  4615              MOV      r5,r2
;;;2738     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
0003b6  2100              MOVS     r1,#0
0003b8  2200              MOVS     r2,#0
0003ba  2600              MOVS     r6,#0
;;;2739     /* Disable the Channel 2: Reset the CC2E Bit */
;;;2740     TIMx->CCER &= CCER_CC2E_Reset;
0003bc  8c07              LDRH     r7,[r0,#0x20]
0003be  f64f7cef          MOV      r12,#0xffef
0003c2  ea07070c          AND      r7,r7,r12
0003c6  8407              STRH     r7,[r0,#0x20]
;;;2741     tmpccmr1 = TIMx->CCMR1;
0003c8  8b01              LDRH     r1,[r0,#0x18]
;;;2742     tmpccer = TIMx->CCER;
0003ca  8c02              LDRH     r2,[r0,#0x20]
;;;2743     tmp = (uint16_t)(TIM_ICPolarity << 4);
0003cc  0527              LSLS     r7,r4,#20
0003ce  0c3e              LSRS     r6,r7,#16
;;;2744     /* Select the Input and set the filter */
;;;2745     tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
0003d0  f64047ff          MOV      r7,#0xcff
0003d4  4039              ANDS     r1,r1,r7
;;;2746     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
0003d6  071f              LSLS     r7,r3,#28
0003d8  ea414117          ORR      r1,r1,r7,LSR #16
;;;2747     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
0003dc  062f              LSLS     r7,r5,#24
0003de  ea414117          ORR      r1,r1,r7,LSR #16
;;;2748     /* Select the Polarity and set the CC2E Bit */
;;;2749     tmpccer &= CCER_CC2P_Reset;
0003e2  f64f77df          MOV      r7,#0xffdf
0003e6  403a              ANDS     r2,r2,r7
;;;2750     tmpccer |=  tmp | CCER_CC2E_Set;
0003e8  f0460710          ORR      r7,r6,#0x10
0003ec  433a              ORRS     r2,r2,r7
;;;2751     /* Write to TIMx CCMR1 and CCER registers */
;;;2752     TIMx->CCMR1 = tmpccmr1 ;
0003ee  8301              STRH     r1,[r0,#0x18]
;;;2753     TIMx->CCER = tmpccer;
0003f0  8402              STRH     r2,[r0,#0x20]
;;;2754   }
0003f2  bdf0              POP      {r4-r7,pc}
                  |L1.1012|
                          DCD      0x40001000
                  |L1.1016|
                          DCD      0xbffffc00
                  |L1.1020|
                          DCD      0x40012c00
                  |L1.1024|
                          DCD      0x40013400
                          ENDP

                  TIM_SetIC1Prescaler PROC
;;;2357     */
;;;2358   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000404  8b02              LDRH     r2,[r0,#0x18]
;;;2359   {
;;;2360     /* Check the parameters */
;;;2361     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2362     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2363     /* Reset the IC1PSC Bits */
;;;2364     TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
000406  f64f73f3          MOV      r3,#0xfff3
00040a  401a              ANDS     r2,r2,r3
00040c  8302              STRH     r2,[r0,#0x18]
;;;2365     /* Set the IC1PSC value */
;;;2366     TIMx->CCMR1 |= TIM_ICPSC;
00040e  8b02              LDRH     r2,[r0,#0x18]
000410  430a              ORRS     r2,r2,r1
000412  8302              STRH     r2,[r0,#0x18]
;;;2367   }
000414  4770              BX       lr
;;;2368   
                          ENDP

                  TI1_Config PROC
;;;2695     */
;;;2696   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000416  b5f0              PUSH     {r4-r7,lr}
;;;2697                          uint16_t TIM_ICFilter)
;;;2698   {
000418  460c              MOV      r4,r1
00041a  4615              MOV      r5,r2
;;;2699     uint16_t tmpccmr1 = 0, tmpccer = 0;
00041c  2100              MOVS     r1,#0
00041e  2200              MOVS     r2,#0
;;;2700     /* Disable the Channel 1: Reset the CC1E Bit */
;;;2701     TIMx->CCER &= CCER_CC1E_Reset;
000420  8c06              LDRH     r6,[r0,#0x20]
000422  f64f77fe          MOV      r7,#0xfffe
000426  403e              ANDS     r6,r6,r7
000428  8406              STRH     r6,[r0,#0x20]
;;;2702     tmpccmr1 = TIMx->CCMR1;
00042a  8b01              LDRH     r1,[r0,#0x18]
;;;2703     tmpccer = TIMx->CCER;
00042c  8c02              LDRH     r2,[r0,#0x20]
;;;2704     /* Select the Input and set the filter */
;;;2705     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
00042e  f64f760c          MOV      r6,#0xff0c
000432  4031              ANDS     r1,r1,r6
;;;2706     tmpccmr1 |= TIM_ICSelection | (uint16_t)(TIM_ICFilter << 4);
000434  051e              LSLS     r6,r3,#20
000436  ea454616          ORR      r6,r5,r6,LSR #16
00043a  4331              ORRS     r1,r1,r6
;;;2707     /* Select the Polarity and set the CC1E Bit */
;;;2708     tmpccer &= CCER_CC1P_Reset;
00043c  1e7e              SUBS     r6,r7,#1
00043e  4032              ANDS     r2,r2,r6
;;;2709     tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
000440  f0440601          ORR      r6,r4,#1
000444  4332              ORRS     r2,r2,r6
;;;2710     /* Write to TIMx CCMR1 and CCER registers */
;;;2711     TIMx->CCMR1 = tmpccmr1;
000446  8301              STRH     r1,[r0,#0x18]
;;;2712     TIMx->CCER = tmpccer;
000448  8402              STRH     r2,[r0,#0x20]
;;;2713   }
00044a  bdf0              POP      {r4-r7,pc}
;;;2714   
                          ENDP

                  TIM_ICInit PROC
;;;594      */
;;;595    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
00044c  b570              PUSH     {r4-r6,lr}
;;;596    {
00044e  4605              MOV      r5,r0
000450  460c              MOV      r4,r1
;;;597      /* Check the parameters */
;;;598      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;599      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
;;;600      assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;601      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;602      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;603      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;604      
;;;605      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000452  8820              LDRH     r0,[r4,#0]
000454  b950              CBNZ     r0,|L1.1132|
;;;606      {
;;;607        /* TI1 Configuration */
;;;608        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000456  8923              LDRH     r3,[r4,#8]
000458  88a2              LDRH     r2,[r4,#4]
00045a  8861              LDRH     r1,[r4,#2]
00045c  4628              MOV      r0,r5
00045e  f7fffffe          BL       TI1_Config
;;;609                   TIM_ICInitStruct->TIM_ICSelection,
;;;610                   TIM_ICInitStruct->TIM_ICFilter);
;;;611        /* Set the Input Capture Prescaler value */
;;;612        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000462  88e1              LDRH     r1,[r4,#6]
000464  4628              MOV      r0,r5
000466  f7fffffe          BL       TIM_SetIC1Prescaler
00046a  e025              B        |L1.1208|
                  |L1.1132|
;;;613      }
;;;614      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
00046c  8820              LDRH     r0,[r4,#0]
00046e  2804              CMP      r0,#4
000470  d10a              BNE      |L1.1160|
;;;615      {
;;;616        /* TI2 Configuration */
;;;617        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000472  8923              LDRH     r3,[r4,#8]
000474  88a2              LDRH     r2,[r4,#4]
000476  8861              LDRH     r1,[r4,#2]
000478  4628              MOV      r0,r5
00047a  f7fffffe          BL       TI2_Config
;;;618                   TIM_ICInitStruct->TIM_ICSelection,
;;;619                   TIM_ICInitStruct->TIM_ICFilter);
;;;620        /* Set the Input Capture Prescaler value */
;;;621        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00047e  88e1              LDRH     r1,[r4,#6]
000480  4628              MOV      r0,r5
000482  f7fffffe          BL       TIM_SetIC2Prescaler
000486  e017              B        |L1.1208|
                  |L1.1160|
;;;622      }
;;;623      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000488  8820              LDRH     r0,[r4,#0]
00048a  2808              CMP      r0,#8
00048c  d10a              BNE      |L1.1188|
;;;624      {
;;;625        /* TI3 Configuration */
;;;626        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
00048e  8923              LDRH     r3,[r4,#8]
000490  88a2              LDRH     r2,[r4,#4]
000492  8861              LDRH     r1,[r4,#2]
000494  4628              MOV      r0,r5
000496  f7fffffe          BL       TI3_Config
;;;627                   TIM_ICInitStruct->TIM_ICSelection,
;;;628                   TIM_ICInitStruct->TIM_ICFilter);
;;;629        /* Set the Input Capture Prescaler value */
;;;630        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00049a  88e1              LDRH     r1,[r4,#6]
00049c  4628              MOV      r0,r5
00049e  f7fffffe          BL       TIM_SetIC3Prescaler
0004a2  e009              B        |L1.1208|
                  |L1.1188|
;;;631      }
;;;632      else
;;;633      {
;;;634        /* TI4 Configuration */
;;;635        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
0004a4  8923              LDRH     r3,[r4,#8]
0004a6  88a2              LDRH     r2,[r4,#4]
0004a8  8861              LDRH     r1,[r4,#2]
0004aa  4628              MOV      r0,r5
0004ac  f7fffffe          BL       TI4_Config
;;;636                   TIM_ICInitStruct->TIM_ICSelection,
;;;637                   TIM_ICInitStruct->TIM_ICFilter);
;;;638        /* Set the Input Capture Prescaler value */
;;;639        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0004b0  88e1              LDRH     r1,[r4,#6]
0004b2  4628              MOV      r0,r5
0004b4  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L1.1208|
;;;640      }
;;;641    }
0004b8  bd70              POP      {r4-r6,pc}
;;;642    
                          ENDP

                  TIM_PWMIConfig PROC
;;;653      */
;;;654    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
0004ba  e92d41f0          PUSH     {r4-r8,lr}
;;;655    {
0004be  4605              MOV      r5,r0
0004c0  460c              MOV      r4,r1
;;;656      uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
0004c2  2600              MOVS     r6,#0
;;;657      uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
0004c4  2701              MOVS     r7,#1
;;;658      /* Check the parameters */
;;;659      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;660      /* Select the Opposite Input Polarity */
;;;661      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
0004c6  8860              LDRH     r0,[r4,#2]
0004c8  b908              CBNZ     r0,|L1.1230|
;;;662      {
;;;663        icoppositepolarity = TIM_ICPolarity_Falling;
0004ca  2602              MOVS     r6,#2
0004cc  e000              B        |L1.1232|
                  |L1.1230|
;;;664      }
;;;665      else
;;;666      {
;;;667        icoppositepolarity = TIM_ICPolarity_Rising;
0004ce  2600              MOVS     r6,#0
                  |L1.1232|
;;;668      }
;;;669      /* Select the Opposite Input */
;;;670      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
0004d0  88a0              LDRH     r0,[r4,#4]
0004d2  2801              CMP      r0,#1
0004d4  d101              BNE      |L1.1242|
;;;671      {
;;;672        icoppositeselection = TIM_ICSelection_IndirectTI;
0004d6  2702              MOVS     r7,#2
0004d8  e000              B        |L1.1244|
                  |L1.1242|
;;;673      }
;;;674      else
;;;675      {
;;;676        icoppositeselection = TIM_ICSelection_DirectTI;
0004da  2701              MOVS     r7,#1
                  |L1.1244|
;;;677      }
;;;678      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
0004dc  8820              LDRH     r0,[r4,#0]
0004de  b9a0              CBNZ     r0,|L1.1290|
;;;679      {
;;;680        /* TI1 Configuration */
;;;681        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
0004e0  8923              LDRH     r3,[r4,#8]
0004e2  88a2              LDRH     r2,[r4,#4]
0004e4  8861              LDRH     r1,[r4,#2]
0004e6  4628              MOV      r0,r5
0004e8  f7fffffe          BL       TI1_Config
;;;682                   TIM_ICInitStruct->TIM_ICFilter);
;;;683        /* Set the Input Capture Prescaler value */
;;;684        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0004ec  88e1              LDRH     r1,[r4,#6]
0004ee  4628              MOV      r0,r5
0004f0  f7fffffe          BL       TIM_SetIC1Prescaler
;;;685        /* TI2 Configuration */
;;;686        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
0004f4  8923              LDRH     r3,[r4,#8]
0004f6  463a              MOV      r2,r7
0004f8  4631              MOV      r1,r6
0004fa  4628              MOV      r0,r5
0004fc  f7fffffe          BL       TI2_Config
;;;687        /* Set the Input Capture Prescaler value */
;;;688        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000500  88e1              LDRH     r1,[r4,#6]
000502  4628              MOV      r0,r5
000504  f7fffffe          BL       TIM_SetIC2Prescaler
000508  e013              B        |L1.1330|
                  |L1.1290|
;;;689      }
;;;690      else
;;;691      { 
;;;692        /* TI2 Configuration */
;;;693        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
00050a  8923              LDRH     r3,[r4,#8]
00050c  88a2              LDRH     r2,[r4,#4]
00050e  8861              LDRH     r1,[r4,#2]
000510  4628              MOV      r0,r5
000512  f7fffffe          BL       TI2_Config
;;;694                   TIM_ICInitStruct->TIM_ICFilter);
;;;695        /* Set the Input Capture Prescaler value */
;;;696        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000516  88e1              LDRH     r1,[r4,#6]
000518  4628              MOV      r0,r5
00051a  f7fffffe          BL       TIM_SetIC2Prescaler
;;;697        /* TI1 Configuration */
;;;698        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00051e  8923              LDRH     r3,[r4,#8]
000520  463a              MOV      r2,r7
000522  4631              MOV      r1,r6
000524  4628              MOV      r0,r5
000526  f7fffffe          BL       TI1_Config
;;;699        /* Set the Input Capture Prescaler value */
;;;700        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00052a  88e1              LDRH     r1,[r4,#6]
00052c  4628              MOV      r0,r5
00052e  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L1.1330|
;;;701      }
;;;702    }
000532  e8bd81f0          POP      {r4-r8,pc}
;;;703    
                          ENDP

                  TIM_BDTRConfig PROC
;;;712      */
;;;713    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000536  880a              LDRH     r2,[r1,#0]
;;;714    {
;;;715      /* Check the parameters */
;;;716      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;717      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;718      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;719      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;720      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;721      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;722      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;723      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;724         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;725      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000538  884b              LDRH     r3,[r1,#2]
00053a  431a              ORRS     r2,r2,r3
00053c  888b              LDRH     r3,[r1,#4]
00053e  431a              ORRS     r2,r2,r3
000540  88cb              LDRH     r3,[r1,#6]
000542  431a              ORRS     r2,r2,r3
000544  890b              LDRH     r3,[r1,#8]
000546  431a              ORRS     r2,r2,r3
000548  894b              LDRH     r3,[r1,#0xa]
00054a  431a              ORRS     r2,r2,r3
00054c  898b              LDRH     r3,[r1,#0xc]
00054e  431a              ORRS     r2,r2,r3
000550  f8a02044          STRH     r2,[r0,#0x44]
;;;726                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;727                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;728                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;729    }
000554  4770              BX       lr
;;;730    
                          ENDP

                  TIM_TimeBaseStructInit PROC
;;;736      */
;;;737    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000556  f64f71ff          MOV      r1,#0xffff
;;;738    {
;;;739      /* Set the default configuration */
;;;740      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
00055a  8081              STRH     r1,[r0,#4]
;;;741      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
00055c  2100              MOVS     r1,#0
00055e  8001              STRH     r1,[r0,#0]
;;;742      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
000560  80c1              STRH     r1,[r0,#6]
;;;743      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
000562  8041              STRH     r1,[r0,#2]
;;;744      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
000564  7201              STRB     r1,[r0,#8]
;;;745    }
000566  4770              BX       lr
;;;746    
                          ENDP

                  TIM_OCStructInit PROC
;;;752      */
;;;753    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000568  2100              MOVS     r1,#0
;;;754    {
;;;755      /* Set the default configuration */
;;;756      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
00056a  8001              STRH     r1,[r0,#0]
;;;757      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
00056c  8041              STRH     r1,[r0,#2]
;;;758      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
00056e  8081              STRH     r1,[r0,#4]
;;;759      TIM_OCInitStruct->TIM_Pulse = 0x0000;
000570  80c1              STRH     r1,[r0,#6]
;;;760      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
000572  8101              STRH     r1,[r0,#8]
;;;761      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
000574  8141              STRH     r1,[r0,#0xa]
;;;762      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
000576  8181              STRH     r1,[r0,#0xc]
;;;763      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000578  81c1              STRH     r1,[r0,#0xe]
;;;764    }
00057a  4770              BX       lr
;;;765    
                          ENDP

                  TIM_ICStructInit PROC
;;;771      */
;;;772    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
00057c  2100              MOVS     r1,#0
;;;773    {
;;;774      /* Set the default configuration */
;;;775      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
00057e  8001              STRH     r1,[r0,#0]
;;;776      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000580  8041              STRH     r1,[r0,#2]
;;;777      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000582  2101              MOVS     r1,#1
000584  8081              STRH     r1,[r0,#4]
;;;778      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
000586  2100              MOVS     r1,#0
000588  80c1              STRH     r1,[r0,#6]
;;;779      TIM_ICInitStruct->TIM_ICFilter = 0x00;
00058a  8101              STRH     r1,[r0,#8]
;;;780    }
00058c  4770              BX       lr
;;;781    
                          ENDP

                  TIM_BDTRStructInit PROC
;;;787      */
;;;788    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
00058e  2100              MOVS     r1,#0
;;;789    {
;;;790      /* Set the default configuration */
;;;791      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000590  8001              STRH     r1,[r0,#0]
;;;792      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000592  8041              STRH     r1,[r0,#2]
;;;793      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000594  8081              STRH     r1,[r0,#4]
;;;794      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000596  80c1              STRH     r1,[r0,#6]
;;;795      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
000598  8101              STRH     r1,[r0,#8]
;;;796      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00059a  8141              STRH     r1,[r0,#0xa]
;;;797      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00059c  8181              STRH     r1,[r0,#0xc]
;;;798    }
00059e  4770              BX       lr
;;;799    
                          ENDP

                  TIM_Cmd PROC
;;;806      */
;;;807    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
0005a0  b121              CBZ      r1,|L1.1452|
;;;808    {
;;;809      /* Check the parameters */
;;;810      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;811      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;812      
;;;813      if (NewState != DISABLE)
;;;814      {
;;;815        /* Enable the TIM Counter */
;;;816        TIMx->CR1 |= CR1_CEN_Set;
0005a2  8802              LDRH     r2,[r0,#0]
0005a4  f0420201          ORR      r2,r2,#1
0005a8  8002              STRH     r2,[r0,#0]
0005aa  e004              B        |L1.1462|
                  |L1.1452|
;;;817      }
;;;818      else
;;;819      {
;;;820        /* Disable the TIM Counter */
;;;821        TIMx->CR1 &= CR1_CEN_Reset;
0005ac  8802              LDRH     r2,[r0,#0]
0005ae  f24033fe          MOV      r3,#0x3fe
0005b2  401a              ANDS     r2,r2,r3
0005b4  8002              STRH     r2,[r0,#0]
                  |L1.1462|
;;;822      }
;;;823    }
0005b6  4770              BX       lr
;;;824    
                          ENDP

                  TIM_CtrlPWMOutputs PROC
;;;831      */
;;;832    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
0005b8  b131              CBZ      r1,|L1.1480|
;;;833    {
;;;834      /* Check the parameters */
;;;835      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;836      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;837      if (NewState != DISABLE)
;;;838      {
;;;839        /* Enable the TIM Main Output */
;;;840        TIMx->BDTR |= BDTR_MOE_Set;
0005ba  f8b02044          LDRH     r2,[r0,#0x44]
0005be  f4424200          ORR      r2,r2,#0x8000
0005c2  f8a02044          STRH     r2,[r0,#0x44]
0005c6  e005              B        |L1.1492|
                  |L1.1480|
;;;841      }
;;;842      else
;;;843      {
;;;844        /* Disable the TIM Main Output */
;;;845        TIMx->BDTR &= BDTR_MOE_Reset;
0005c8  f8b02044          LDRH     r2,[r0,#0x44]
0005cc  f3c2020e          UBFX     r2,r2,#0,#15
0005d0  f8a02044          STRH     r2,[r0,#0x44]
                  |L1.1492|
;;;846      }  
;;;847    }
0005d4  4770              BX       lr
;;;848    
                          ENDP

                  TIM_ITConfig PROC
;;;866      */
;;;867    void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
0005d6  b510              PUSH     {r4,lr}
;;;868    {  
;;;869      /* Check the parameters */
;;;870      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;871      assert_param(IS_TIM_IT(TIM_IT));
;;;872      assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
;;;873      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;874      
;;;875      if (NewState != DISABLE)
0005d8  b11a              CBZ      r2,|L1.1506|
;;;876      {
;;;877        /* Enable the Interrupt sources */
;;;878        TIMx->DIER |= TIM_IT;
0005da  8983              LDRH     r3,[r0,#0xc]
0005dc  430b              ORRS     r3,r3,r1
0005de  8183              STRH     r3,[r0,#0xc]
0005e0  e004              B        |L1.1516|
                  |L1.1506|
;;;879      }
;;;880      else
;;;881      {
;;;882        /* Disable the Interrupt sources */
;;;883        TIMx->DIER &= (uint16_t)~TIM_IT;
0005e2  8983              LDRH     r3,[r0,#0xc]
0005e4  43cc              MVNS     r4,r1
0005e6  b2a4              UXTH     r4,r4
0005e8  4023              ANDS     r3,r3,r4
0005ea  8183              STRH     r3,[r0,#0xc]
                  |L1.1516|
;;;884      }
;;;885    }
0005ec  bd10              POP      {r4,pc}
;;;886    
                          ENDP

                  TIM_GenerateEvent PROC
;;;899      */
;;;900    void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
0005ee  8281              STRH     r1,[r0,#0x14]
;;;901    { 
;;;902      /* Check the parameters */
;;;903      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;904      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;905      assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
;;;906      /* Set the event sources */
;;;907      TIMx->EGR = TIM_EventSource;
;;;908    }
0005f0  4770              BX       lr
;;;909    
                          ENDP

                  TIM_DMAConfig PROC
;;;927      */
;;;928    void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
0005f2  ea410302          ORR      r3,r1,r2
;;;929    {
;;;930      /* Check the parameters */
;;;931      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;932      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;933      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;934      /* Set the DMA Base and the DMA Burst Length */
;;;935      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
0005f6  f8a03048          STRH     r3,[r0,#0x48]
;;;936    }
0005fa  4770              BX       lr
;;;937    
                          ENDP

                  TIM_DMACmd PROC
;;;953      */
;;;954    void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
0005fc  b510              PUSH     {r4,lr}
;;;955    { 
;;;956      /* Check the parameters */
;;;957      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;958      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;959      assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
;;;960      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;961      
;;;962      if (NewState != DISABLE)
0005fe  b11a              CBZ      r2,|L1.1544|
;;;963      {
;;;964        /* Enable the DMA sources */
;;;965        TIMx->DIER |= TIM_DMASource; 
000600  8983              LDRH     r3,[r0,#0xc]
000602  430b              ORRS     r3,r3,r1
000604  8183              STRH     r3,[r0,#0xc]
000606  e004              B        |L1.1554|
                  |L1.1544|
;;;966      }
;;;967      else
;;;968      {
;;;969        /* Disable the DMA sources */
;;;970        TIMx->DIER &= (uint16_t)~TIM_DMASource;
000608  8983              LDRH     r3,[r0,#0xc]
00060a  43cc              MVNS     r4,r1
00060c  b2a4              UXTH     r4,r4
00060e  4023              ANDS     r3,r3,r4
000610  8183              STRH     r3,[r0,#0xc]
                  |L1.1554|
;;;971      }
;;;972    }
000612  bd10              POP      {r4,pc}
;;;973    
                          ENDP

                  TIM_InternalClockConfig PROC
;;;979      */
;;;980    void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000614  8901              LDRH     r1,[r0,#8]
;;;981    {
;;;982      /* Check the parameters */
;;;983      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;984      /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;985      TIMx->SMCR &=  SMCR_SMS_Mask;
000616  f64f72f8          MOV      r2,#0xfff8
00061a  4011              ANDS     r1,r1,r2
00061c  8101              STRH     r1,[r0,#8]
;;;986    }
00061e  4770              BX       lr
;;;987    
                          ENDP

                  TIM_SelectInputTrigger PROC
;;;1228     */
;;;1229   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000620  460a              MOV      r2,r1
;;;1230   {
;;;1231     uint16_t tmpsmcr = 0;
000622  2100              MOVS     r1,#0
;;;1232     /* Check the parameters */
;;;1233     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1234     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1235     /* Get the TIMx SMCR register value */
;;;1236     tmpsmcr = TIMx->SMCR;
000624  8901              LDRH     r1,[r0,#8]
;;;1237     /* Reset the TS Bits */
;;;1238     tmpsmcr &= SMCR_TS_Mask;
000626  f64f738f          MOV      r3,#0xff8f
00062a  4019              ANDS     r1,r1,r3
;;;1239     /* Set the Input Trigger source */
;;;1240     tmpsmcr |= TIM_InputTriggerSource;
00062c  4311              ORRS     r1,r1,r2
;;;1241     /* Write to TIMx SMCR */
;;;1242     TIMx->SMCR = tmpsmcr;
00062e  8101              STRH     r1,[r0,#8]
;;;1243   }
000630  4770              BX       lr
;;;1244   
                          ENDP

                  TIM_ITRxExternalClockConfig PROC
;;;999      */
;;;1000   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000632  b530              PUSH     {r4,r5,lr}
;;;1001   {
000634  4604              MOV      r4,r0
000636  460d              MOV      r5,r1
;;;1002     /* Check the parameters */
;;;1003     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1004     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1005     /* Select the Internal Trigger */
;;;1006     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000638  4629              MOV      r1,r5
00063a  4620              MOV      r0,r4
00063c  f7fffffe          BL       TIM_SelectInputTrigger
;;;1007     /* Select the External clock mode1 */
;;;1008     TIMx->SMCR |= TIM_SlaveMode_External1;
000640  8920              LDRH     r0,[r4,#8]
000642  f0400007          ORR      r0,r0,#7
000646  8120              STRH     r0,[r4,#8]
;;;1009   }
000648  bd30              POP      {r4,r5,pc}
;;;1010   
                          ENDP

                  TIM_TIxExternalClockConfig PROC
;;;1027     */
;;;1028   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
00064a  e92d41f0          PUSH     {r4-r8,lr}
;;;1029                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;1030   {
00064e  4604              MOV      r4,r0
000650  460d              MOV      r5,r1
000652  4616              MOV      r6,r2
000654  461f              MOV      r7,r3
;;;1031     /* Check the parameters */
;;;1032     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1033     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1034     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1035     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1036     /* Configure the Timer Input Clock Source */
;;;1037     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
000656  2d60              CMP      r5,#0x60
000658  d106              BNE      |L1.1640|
;;;1038     {
;;;1039       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00065a  463b              MOV      r3,r7
00065c  2201              MOVS     r2,#1
00065e  4631              MOV      r1,r6
000660  4620              MOV      r0,r4
000662  f7fffffe          BL       TI2_Config
000666  e005              B        |L1.1652|
                  |L1.1640|
;;;1040     }
;;;1041     else
;;;1042     {
;;;1043       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000668  463b              MOV      r3,r7
00066a  2201              MOVS     r2,#1
00066c  4631              MOV      r1,r6
00066e  4620              MOV      r0,r4
000670  f7fffffe          BL       TI1_Config
                  |L1.1652|
;;;1044     }
;;;1045     /* Select the Trigger source */
;;;1046     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
000674  4629              MOV      r1,r5
000676  4620              MOV      r0,r4
000678  f7fffffe          BL       TIM_SelectInputTrigger
;;;1047     /* Select the External clock mode1 */
;;;1048     TIMx->SMCR |= TIM_SlaveMode_External1;
00067c  8920              LDRH     r0,[r4,#8]
00067e  f0400007          ORR      r0,r0,#7
000682  8120              STRH     r0,[r4,#8]
;;;1049   }
000684  e8bd81f0          POP      {r4-r8,pc}
;;;1050   
                          ENDP

                  TIM_ETRConfig PROC
;;;1143     */
;;;1144   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000688  b570              PUSH     {r4-r6,lr}
;;;1145                      uint16_t ExtTRGFilter)
;;;1146   {
00068a  460c              MOV      r4,r1
;;;1147     uint16_t tmpsmcr = 0;
00068c  2100              MOVS     r1,#0
;;;1148     /* Check the parameters */
;;;1149     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1150     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1151     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1152     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1153     tmpsmcr = TIMx->SMCR;
00068e  8901              LDRH     r1,[r0,#8]
;;;1154     /* Reset the ETR Bits */
;;;1155     tmpsmcr &= SMCR_ETR_Mask;
000690  b2c9              UXTB     r1,r1
;;;1156     /* Set the Prescaler, the Filter value and the Polarity */
;;;1157     tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << 8);
000692  ea440502          ORR      r5,r4,r2
000696  061e              LSLS     r6,r3,#24
000698  ea454516          ORR      r5,r5,r6,LSR #16
00069c  4329              ORRS     r1,r1,r5
;;;1158     /* Write to TIMx SMCR */
;;;1159     TIMx->SMCR = tmpsmcr;
00069e  8101              STRH     r1,[r0,#8]
;;;1160   }
0006a0  bd70              POP      {r4-r6,pc}
;;;1161   
                          ENDP

                  TIM_ETRClockMode1Config PROC
;;;1068     */
;;;1069   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
0006a2  e92d41f0          PUSH     {r4-r8,lr}
;;;1070                                uint16_t ExtTRGFilter)
;;;1071   {
0006a6  4605              MOV      r5,r0
0006a8  460e              MOV      r6,r1
0006aa  4617              MOV      r7,r2
0006ac  4698              MOV      r8,r3
;;;1072     uint16_t tmpsmcr = 0;
0006ae  2400              MOVS     r4,#0
;;;1073     /* Check the parameters */
;;;1074     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1075     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1076     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1077     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1078     /* Configure the ETR Clock source */
;;;1079     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
0006b0  4643              MOV      r3,r8
0006b2  463a              MOV      r2,r7
0006b4  4631              MOV      r1,r6
0006b6  4628              MOV      r0,r5
0006b8  f7fffffe          BL       TIM_ETRConfig
;;;1080     
;;;1081     /* Get the TIMx SMCR register value */
;;;1082     tmpsmcr = TIMx->SMCR;
0006bc  892c              LDRH     r4,[r5,#8]
;;;1083     /* Reset the SMS Bits */
;;;1084     tmpsmcr &= SMCR_SMS_Mask;
0006be  f64f71f8          MOV      r1,#0xfff8
0006c2  400c              ANDS     r4,r4,r1
;;;1085     /* Select the External clock mode1 */
;;;1086     tmpsmcr |= TIM_SlaveMode_External1;
0006c4  f0440407          ORR      r4,r4,#7
;;;1087     /* Select the Trigger selection : ETRF */
;;;1088     tmpsmcr &= SMCR_TS_Mask;
0006c8  f64f718f          MOV      r1,#0xff8f
0006cc  400c              ANDS     r4,r4,r1
;;;1089     tmpsmcr |= TIM_TS_ETRF;
0006ce  f0440470          ORR      r4,r4,#0x70
;;;1090     /* Write to TIMx SMCR */
;;;1091     TIMx->SMCR = tmpsmcr;
0006d2  812c              STRH     r4,[r5,#8]
;;;1092   }
0006d4  e8bd81f0          POP      {r4-r8,pc}
;;;1093   
                          ENDP

                  TIM_ETRClockMode2Config PROC
;;;1111     */
;;;1112   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
0006d8  b5f0              PUSH     {r4-r7,lr}
;;;1113                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;1114   {
0006da  4604              MOV      r4,r0
0006dc  460d              MOV      r5,r1
0006de  4616              MOV      r6,r2
0006e0  461f              MOV      r7,r3
;;;1115     /* Check the parameters */
;;;1116     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1117     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1118     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1119     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1120     /* Configure the ETR Clock source */
;;;1121     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
0006e2  463b              MOV      r3,r7
0006e4  4632              MOV      r2,r6
0006e6  4629              MOV      r1,r5
0006e8  4620              MOV      r0,r4
0006ea  f7fffffe          BL       TIM_ETRConfig
;;;1122     /* Enable the External clock mode2 */
;;;1123     TIMx->SMCR |= SMCR_ECE_Set;
0006ee  8920              LDRH     r0,[r4,#8]
0006f0  f4404080          ORR      r0,r0,#0x4000
0006f4  8120              STRH     r0,[r4,#8]
;;;1124   }
0006f6  bdf0              POP      {r4-r7,pc}
;;;1125   
                          ENDP

                  TIM_PrescalerConfig PROC
;;;1173     */
;;;1174   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
0006f8  8501              STRH     r1,[r0,#0x28]
;;;1175   {
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1178     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1179     /* Set the Prescaler value */
;;;1180     TIMx->PSC = Prescaler;
;;;1181     /* Set or reset the UG Bit */
;;;1182     TIMx->EGR = TIM_PSCReloadMode;
0006fa  8282              STRH     r2,[r0,#0x14]
;;;1183   }
0006fc  4770              BX       lr
;;;1184   
                          ENDP

                  TIM_CounterModeConfig PROC
;;;1197     */
;;;1198   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
0006fe  460a              MOV      r2,r1
;;;1199   {
;;;1200     uint16_t tmpcr1 = 0;
000700  2100              MOVS     r1,#0
;;;1201     /* Check the parameters */
;;;1202     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1203     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1204     tmpcr1 = TIMx->CR1;
000702  8801              LDRH     r1,[r0,#0]
;;;1205     /* Reset the CMS and DIR Bits */
;;;1206     tmpcr1 &= CR1_CounterMode_Mask;
000704  f240338f          MOV      r3,#0x38f
000708  4019              ANDS     r1,r1,r3
;;;1207     /* Set the Counter Mode */
;;;1208     tmpcr1 |= TIM_CounterMode;
00070a  4311              ORRS     r1,r1,r2
;;;1209     /* Write to TIMx CR1 register */
;;;1210     TIMx->CR1 = tmpcr1;
00070c  8001              STRH     r1,[r0,#0]
;;;1211   }
00070e  4770              BX       lr
;;;1212   
                          ENDP

                  TIM_EncoderInterfaceConfig PROC
;;;1266     */
;;;1267   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000710  b5f0              PUSH     {r4-r7,lr}
;;;1268                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;1269   {
000712  460c              MOV      r4,r1
000714  4615              MOV      r5,r2
000716  461e              MOV      r6,r3
;;;1270     uint16_t tmpsmcr = 0;
000718  2100              MOVS     r1,#0
;;;1271     uint16_t tmpccmr1 = 0;
00071a  2200              MOVS     r2,#0
;;;1272     uint16_t tmpccer = 0;
00071c  2300              MOVS     r3,#0
;;;1273       
;;;1274     /* Check the parameters */
;;;1275     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1276     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1277     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1278     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1279     /* Get the TIMx SMCR register value */
;;;1280     tmpsmcr = TIMx->SMCR;
00071e  8901              LDRH     r1,[r0,#8]
;;;1281     /* Get the TIMx CCMR1 register value */
;;;1282     tmpccmr1 = TIMx->CCMR1;
000720  8b02              LDRH     r2,[r0,#0x18]
;;;1283     /* Get the TIMx CCER register value */
;;;1284     tmpccer = TIMx->CCER;
000722  8c03              LDRH     r3,[r0,#0x20]
;;;1285     /* Set the encoder Mode */
;;;1286     tmpsmcr &= SMCR_SMS_Mask;
000724  f64f77f8          MOV      r7,#0xfff8
000728  4039              ANDS     r1,r1,r7
;;;1287     tmpsmcr |= TIM_EncoderMode;
00072a  4321              ORRS     r1,r1,r4
;;;1288     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1289     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
00072c  f64f47fc          MOV      r7,#0xfcfc
000730  403a              ANDS     r2,r2,r7
;;;1290     tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
000732  f2401701          MOV      r7,#0x101
000736  433a              ORRS     r2,r2,r7
;;;1291     /* Set the TI1 and the TI2 Polarities */
;;;1292     tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
000738  f64f77dd          MOV      r7,#0xffdd
00073c  403b              ANDS     r3,r3,r7
;;;1293     tmpccer |= (TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << 4));
00073e  0537              LSLS     r7,r6,#20
000740  ea454717          ORR      r7,r5,r7,LSR #16
000744  433b              ORRS     r3,r3,r7
;;;1294     /* Write to TIMx SMCR */
;;;1295     TIMx->SMCR = tmpsmcr;
000746  8101              STRH     r1,[r0,#8]
;;;1296     /* Write to TIMx CCMR1 */
;;;1297     TIMx->CCMR1 = tmpccmr1;
000748  8302              STRH     r2,[r0,#0x18]
;;;1298     /* Write to TIMx CCER */
;;;1299     TIMx->CCER = tmpccer;
00074a  8403              STRH     r3,[r0,#0x20]
;;;1300   }
00074c  bdf0              POP      {r4-r7,pc}
;;;1301   
                          ENDP

                  TIM_ForcedOC1Config PROC
;;;1313     */
;;;1314   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
00074e  460a              MOV      r2,r1
;;;1315   {
;;;1316     uint16_t tmpccmr1 = 0;
000750  2100              MOVS     r1,#0
;;;1317     /* Check the parameters */
;;;1318     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1319     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1320     tmpccmr1 = TIMx->CCMR1;
000752  8b01              LDRH     r1,[r0,#0x18]
;;;1321     /* Reset the OC1M Bits */
;;;1322     tmpccmr1 &= CCMR_OC13M_Mask;
000754  f64f738f          MOV      r3,#0xff8f
000758  4019              ANDS     r1,r1,r3
;;;1323     /* Configure The Forced output Mode */
;;;1324     tmpccmr1 |= TIM_ForcedAction;
00075a  4311              ORRS     r1,r1,r2
;;;1325     /* Write to TIMx CCMR1 register */
;;;1326     TIMx->CCMR1 = tmpccmr1;
00075c  8301              STRH     r1,[r0,#0x18]
;;;1327   }
00075e  4770              BX       lr
;;;1328   
                          ENDP

                  TIM_ForcedOC2Config PROC
;;;1340     */
;;;1341   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000760  460a              MOV      r2,r1
;;;1342   {
;;;1343     uint16_t tmpccmr1 = 0;
000762  2100              MOVS     r1,#0
;;;1344     /* Check the parameters */
;;;1345     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1346     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1347     tmpccmr1 = TIMx->CCMR1;
000764  8b01              LDRH     r1,[r0,#0x18]
;;;1348     /* Reset the OC2M Bits */
;;;1349     tmpccmr1 &= CCMR_OC24M_Mask;
000766  f64873ff          MOV      r3,#0x8fff
00076a  4019              ANDS     r1,r1,r3
;;;1350     /* Configure The Forced output Mode */
;;;1351     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
00076c  0613              LSLS     r3,r2,#24
00076e  ea414113          ORR      r1,r1,r3,LSR #16
;;;1352     /* Write to TIMx CCMR1 register */
;;;1353     TIMx->CCMR1 = tmpccmr1;
000772  8301              STRH     r1,[r0,#0x18]
;;;1354   }
000774  4770              BX       lr
;;;1355   
                          ENDP

                  TIM_ForcedOC3Config PROC
;;;1367     */
;;;1368   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000776  460a              MOV      r2,r1
;;;1369   {
;;;1370     uint16_t tmpccmr2 = 0;
000778  2100              MOVS     r1,#0
;;;1371     /* Check the parameters */
;;;1372     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1373     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1374     tmpccmr2 = TIMx->CCMR2;
00077a  8b81              LDRH     r1,[r0,#0x1c]
;;;1375     /* Reset the OC1M Bits */
;;;1376     tmpccmr2 &= CCMR_OC13M_Mask;
00077c  f64f738f          MOV      r3,#0xff8f
000780  4019              ANDS     r1,r1,r3
;;;1377     /* Configure The Forced output Mode */
;;;1378     tmpccmr2 |= TIM_ForcedAction;
000782  4311              ORRS     r1,r1,r2
;;;1379     /* Write to TIMx CCMR2 register */
;;;1380     TIMx->CCMR2 = tmpccmr2;
000784  8381              STRH     r1,[r0,#0x1c]
;;;1381   }
000786  4770              BX       lr
;;;1382   
                          ENDP

                  TIM_ForcedOC4Config PROC
;;;1394     */
;;;1395   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000788  460a              MOV      r2,r1
;;;1396   {
;;;1397     uint16_t tmpccmr2 = 0;
00078a  2100              MOVS     r1,#0
;;;1398     /* Check the parameters */
;;;1399     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1400     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1401     tmpccmr2 = TIMx->CCMR2;
00078c  8b81              LDRH     r1,[r0,#0x1c]
;;;1402     /* Reset the OC2M Bits */
;;;1403     tmpccmr2 &= CCMR_OC24M_Mask;
00078e  f64873ff          MOV      r3,#0x8fff
000792  4019              ANDS     r1,r1,r3
;;;1404     /* Configure The Forced output Mode */
;;;1405     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
000794  0613              LSLS     r3,r2,#24
000796  ea414113          ORR      r1,r1,r3,LSR #16
;;;1406     /* Write to TIMx CCMR2 register */
;;;1407     TIMx->CCMR2 = tmpccmr2;
00079a  8381              STRH     r1,[r0,#0x1c]
;;;1408   }
00079c  4770              BX       lr
;;;1409   
                          ENDP

                  TIM_ARRPreloadConfig PROC
;;;1417     */
;;;1418   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
00079e  b121              CBZ      r1,|L1.1962|
;;;1419   {
;;;1420     /* Check the parameters */
;;;1421     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1422     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1423     if (NewState != DISABLE)
;;;1424     {
;;;1425       /* Set the ARR Preload Bit */
;;;1426       TIMx->CR1 |= CR1_ARPE_Set;
0007a0  8802              LDRH     r2,[r0,#0]
0007a2  f0420280          ORR      r2,r2,#0x80
0007a6  8002              STRH     r2,[r0,#0]
0007a8  e004              B        |L1.1972|
                  |L1.1962|
;;;1427     }
;;;1428     else
;;;1429     {
;;;1430       /* Reset the ARR Preload Bit */
;;;1431       TIMx->CR1 &= CR1_ARPE_Reset;
0007aa  8802              LDRH     r2,[r0,#0]
0007ac  f240337f          MOV      r3,#0x37f
0007b0  401a              ANDS     r2,r2,r3
0007b2  8002              STRH     r2,[r0,#0]
                  |L1.1972|
;;;1432     }
;;;1433   }
0007b4  4770              BX       lr
;;;1434   
                          ENDP

                  TIM_SelectCOM PROC
;;;1441     */
;;;1442   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
0007b6  b121              CBZ      r1,|L1.1986|
;;;1443   {
;;;1444     /* Check the parameters */
;;;1445     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1446     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1447     if (NewState != DISABLE)
;;;1448     {
;;;1449       /* Set the COM Bit */
;;;1450       TIMx->CR2 |= CR2_CCUS_Set;
0007b8  8882              LDRH     r2,[r0,#4]
0007ba  f0420204          ORR      r2,r2,#4
0007be  8082              STRH     r2,[r0,#4]
0007c0  e004              B        |L1.1996|
                  |L1.1986|
;;;1451     }
;;;1452     else
;;;1453     {
;;;1454       /* Reset the COM Bit */
;;;1455       TIMx->CR2 &= CR2_CCUS_Reset;
0007c2  8882              LDRH     r2,[r0,#4]
0007c4  f64f73fb          MOV      r3,#0xfffb
0007c8  401a              ANDS     r2,r2,r3
0007ca  8082              STRH     r2,[r0,#4]
                  |L1.1996|
;;;1456     }
;;;1457   }
0007cc  4770              BX       lr
;;;1458   
                          ENDP

                  TIM_SelectCCDMA PROC
;;;1466     */
;;;1467   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
0007ce  b121              CBZ      r1,|L1.2010|
;;;1468   {
;;;1469     /* Check the parameters */
;;;1470     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1471     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1472     if (NewState != DISABLE)
;;;1473     {
;;;1474       /* Set the CCDS Bit */
;;;1475       TIMx->CR2 |= CR2_CCDS_Set;
0007d0  8882              LDRH     r2,[r0,#4]
0007d2  f0420208          ORR      r2,r2,#8
0007d6  8082              STRH     r2,[r0,#4]
0007d8  e004              B        |L1.2020|
                  |L1.2010|
;;;1476     }
;;;1477     else
;;;1478     {
;;;1479       /* Reset the CCDS Bit */
;;;1480       TIMx->CR2 &= CR2_CCDS_Reset;
0007da  8882              LDRH     r2,[r0,#4]
0007dc  f64f73f7          MOV      r3,#0xfff7
0007e0  401a              ANDS     r2,r2,r3
0007e2  8082              STRH     r2,[r0,#4]
                  |L1.2020|
;;;1481     }
;;;1482   }
0007e4  4770              BX       lr
;;;1483   
                          ENDP

                  TIM_CCPreloadControl PROC
;;;1491     */
;;;1492   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
0007e6  b121              CBZ      r1,|L1.2034|
;;;1493   { 
;;;1494     /* Check the parameters */
;;;1495     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1496     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1497     if (NewState != DISABLE)
;;;1498     {
;;;1499       /* Set the CCPC Bit */
;;;1500       TIMx->CR2 |= CR2_CCPC_Set;
0007e8  8882              LDRH     r2,[r0,#4]
0007ea  f0420201          ORR      r2,r2,#1
0007ee  8082              STRH     r2,[r0,#4]
0007f0  e004              B        |L1.2044|
                  |L1.2034|
;;;1501     }
;;;1502     else
;;;1503     {
;;;1504       /* Reset the CCPC Bit */
;;;1505       TIMx->CR2 &= CR2_CCPC_Reset;
0007f2  8882              LDRH     r2,[r0,#4]
0007f4  f64f73fe          MOV      r3,#0xfffe
0007f8  401a              ANDS     r2,r2,r3
0007fa  8082              STRH     r2,[r0,#4]
                  |L1.2044|
;;;1506     }
;;;1507   }
0007fc  4770              BX       lr
;;;1508   
                          ENDP

                  TIM_OC1PreloadConfig PROC
;;;1519     */
;;;1520   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
0007fe  460a              MOV      r2,r1
;;;1521   {
;;;1522     uint16_t tmpccmr1 = 0;
000800  2100              MOVS     r1,#0
;;;1523     /* Check the parameters */
;;;1524     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1525     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1526     tmpccmr1 = TIMx->CCMR1;
000802  8b01              LDRH     r1,[r0,#0x18]
;;;1527     /* Reset the OC1PE Bit */
;;;1528     tmpccmr1 &= CCMR_OC13PE_Reset;
000804  f64f73f7          MOV      r3,#0xfff7
000808  4019              ANDS     r1,r1,r3
;;;1529     /* Enable or Disable the Output Compare Preload feature */
;;;1530     tmpccmr1 |= TIM_OCPreload;
00080a  4311              ORRS     r1,r1,r2
;;;1531     /* Write to TIMx CCMR1 register */
;;;1532     TIMx->CCMR1 = tmpccmr1;
00080c  8301              STRH     r1,[r0,#0x18]
;;;1533   }
00080e  4770              BX       lr
;;;1534   
                          ENDP

                  TIM_OC2PreloadConfig PROC
;;;1545     */
;;;1546   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000810  460a              MOV      r2,r1
;;;1547   {
;;;1548     uint16_t tmpccmr1 = 0;
000812  2100              MOVS     r1,#0
;;;1549     /* Check the parameters */
;;;1550     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1551     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1552     tmpccmr1 = TIMx->CCMR1;
000814  8b01              LDRH     r1,[r0,#0x18]
;;;1553     /* Reset the OC2PE Bit */
;;;1554     tmpccmr1 &= CCMR_OC24PE_Reset;
000816  f24f73ff          MOV      r3,#0xf7ff
00081a  4019              ANDS     r1,r1,r3
;;;1555     /* Enable or Disable the Output Compare Preload feature */
;;;1556     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
00081c  0613              LSLS     r3,r2,#24
00081e  ea414113          ORR      r1,r1,r3,LSR #16
;;;1557     /* Write to TIMx CCMR1 register */
;;;1558     TIMx->CCMR1 = tmpccmr1;
000822  8301              STRH     r1,[r0,#0x18]
;;;1559   }
000824  4770              BX       lr
;;;1560   
                          ENDP

                  TIM_OC3PreloadConfig PROC
;;;1571     */
;;;1572   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000826  460a              MOV      r2,r1
;;;1573   {
;;;1574     uint16_t tmpccmr2 = 0;
000828  2100              MOVS     r1,#0
;;;1575     /* Check the parameters */
;;;1576     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1577     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1578     tmpccmr2 = TIMx->CCMR2;
00082a  8b81              LDRH     r1,[r0,#0x1c]
;;;1579     /* Reset the OC3PE Bit */
;;;1580     tmpccmr2 &= CCMR_OC13PE_Reset;
00082c  f64f73f7          MOV      r3,#0xfff7
000830  4019              ANDS     r1,r1,r3
;;;1581     /* Enable or Disable the Output Compare Preload feature */
;;;1582     tmpccmr2 |= TIM_OCPreload;
000832  4311              ORRS     r1,r1,r2
;;;1583     /* Write to TIMx CCMR2 register */
;;;1584     TIMx->CCMR2 = tmpccmr2;
000834  8381              STRH     r1,[r0,#0x1c]
;;;1585   }
000836  4770              BX       lr
;;;1586   
                          ENDP

                  TIM_OC4PreloadConfig PROC
;;;1597     */
;;;1598   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000838  460a              MOV      r2,r1
;;;1599   {
;;;1600     uint16_t tmpccmr2 = 0;
00083a  2100              MOVS     r1,#0
;;;1601     /* Check the parameters */
;;;1602     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1603     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1604     tmpccmr2 = TIMx->CCMR2;
00083c  8b81              LDRH     r1,[r0,#0x1c]
;;;1605     /* Reset the OC4PE Bit */
;;;1606     tmpccmr2 &= CCMR_OC24PE_Reset;
00083e  f24f73ff          MOV      r3,#0xf7ff
000842  4019              ANDS     r1,r1,r3
;;;1607     /* Enable or Disable the Output Compare Preload feature */
;;;1608     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
000844  0613              LSLS     r3,r2,#24
000846  ea414113          ORR      r1,r1,r3,LSR #16
;;;1609     /* Write to TIMx CCMR2 register */
;;;1610     TIMx->CCMR2 = tmpccmr2;
00084a  8381              STRH     r1,[r0,#0x1c]
;;;1611   }
00084c  4770              BX       lr
;;;1612   
                          ENDP

                  TIM_OC1FastConfig PROC
;;;1622     */
;;;1623   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
00084e  460a              MOV      r2,r1
;;;1624   {
;;;1625     uint16_t tmpccmr1 = 0;
000850  2100              MOVS     r1,#0
;;;1626     /* Check the parameters */
;;;1627     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1628     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1629     /* Get the TIMx CCMR1 register value */
;;;1630     tmpccmr1 = TIMx->CCMR1;
000852  8b01              LDRH     r1,[r0,#0x18]
;;;1631     /* Reset the OC1FE Bit */
;;;1632     tmpccmr1 &= CCMR_OC13FE_Reset;
000854  f64f73fb          MOV      r3,#0xfffb
000858  4019              ANDS     r1,r1,r3
;;;1633     /* Enable or Disable the Output Compare Fast Bit */
;;;1634     tmpccmr1 |= TIM_OCFast;
00085a  4311              ORRS     r1,r1,r2
;;;1635     /* Write to TIMx CCMR1 */
;;;1636     TIMx->CCMR1 = tmpccmr1;
00085c  8301              STRH     r1,[r0,#0x18]
;;;1637   }
00085e  4770              BX       lr
;;;1638   
                          ENDP

                  TIM_OC2FastConfig PROC
;;;1648     */
;;;1649   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000860  460a              MOV      r2,r1
;;;1650   {
;;;1651     uint16_t tmpccmr1 = 0;
000862  2100              MOVS     r1,#0
;;;1652     /* Check the parameters */
;;;1653     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1654     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1655     /* Get the TIMx CCMR1 register value */
;;;1656     tmpccmr1 = TIMx->CCMR1;
000864  8b01              LDRH     r1,[r0,#0x18]
;;;1657     /* Reset the OC2FE Bit */
;;;1658     tmpccmr1 &= CCMR_OC24FE_Reset;
000866  f64f33ff          MOV      r3,#0xfbff
00086a  4019              ANDS     r1,r1,r3
;;;1659     /* Enable or Disable the Output Compare Fast Bit */
;;;1660     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
00086c  0613              LSLS     r3,r2,#24
00086e  ea414113          ORR      r1,r1,r3,LSR #16
;;;1661     /* Write to TIMx CCMR1 */
;;;1662     TIMx->CCMR1 = tmpccmr1;
000872  8301              STRH     r1,[r0,#0x18]
;;;1663   }
000874  4770              BX       lr
;;;1664   
                          ENDP

                  TIM_OC3FastConfig PROC
;;;1674     */
;;;1675   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000876  460a              MOV      r2,r1
;;;1676   {
;;;1677     uint16_t tmpccmr2 = 0;
000878  2100              MOVS     r1,#0
;;;1678     /* Check the parameters */
;;;1679     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1680     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1681     /* Get the TIMx CCMR2 register value */
;;;1682     tmpccmr2 = TIMx->CCMR2;
00087a  8b81              LDRH     r1,[r0,#0x1c]
;;;1683     /* Reset the OC3FE Bit */
;;;1684     tmpccmr2 &= CCMR_OC13FE_Reset;
00087c  f64f73fb          MOV      r3,#0xfffb
000880  4019              ANDS     r1,r1,r3
;;;1685     /* Enable or Disable the Output Compare Fast Bit */
;;;1686     tmpccmr2 |= TIM_OCFast;
000882  4311              ORRS     r1,r1,r2
;;;1687     /* Write to TIMx CCMR2 */
;;;1688     TIMx->CCMR2 = tmpccmr2;
000884  8381              STRH     r1,[r0,#0x1c]
;;;1689   }
000886  4770              BX       lr
;;;1690   
                          ENDP

                  TIM_OC4FastConfig PROC
;;;1700     */
;;;1701   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000888  460a              MOV      r2,r1
;;;1702   {
;;;1703     uint16_t tmpccmr2 = 0;
00088a  2100              MOVS     r1,#0
;;;1704     /* Check the parameters */
;;;1705     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1706     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1707     /* Get the TIMx CCMR2 register value */
;;;1708     tmpccmr2 = TIMx->CCMR2;
00088c  8b81              LDRH     r1,[r0,#0x1c]
;;;1709     /* Reset the OC4FE Bit */
;;;1710     tmpccmr2 &= CCMR_OC24FE_Reset;
00088e  f64f33ff          MOV      r3,#0xfbff
000892  4019              ANDS     r1,r1,r3
;;;1711     /* Enable or Disable the Output Compare Fast Bit */
;;;1712     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
000894  0613              LSLS     r3,r2,#24
000896  ea414113          ORR      r1,r1,r3,LSR #16
;;;1713     /* Write to TIMx CCMR2 */
;;;1714     TIMx->CCMR2 = tmpccmr2;
00089a  8381              STRH     r1,[r0,#0x1c]
;;;1715   }
00089c  4770              BX       lr
;;;1716   
                          ENDP

                  TIM_ClearOC1Ref PROC
;;;1726     */
;;;1727   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
00089e  460a              MOV      r2,r1
;;;1728   {
;;;1729     uint16_t tmpccmr1 = 0;
0008a0  2100              MOVS     r1,#0
;;;1730     /* Check the parameters */
;;;1731     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1732     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1733     tmpccmr1 = TIMx->CCMR1;
0008a2  8b01              LDRH     r1,[r0,#0x18]
;;;1734     /* Reset the OC1CE Bit */
;;;1735     tmpccmr1 &= CCMR_OC13CE_Reset;
0008a4  f64f737f          MOV      r3,#0xff7f
0008a8  4019              ANDS     r1,r1,r3
;;;1736     /* Enable or Disable the Output Compare Clear Bit */
;;;1737     tmpccmr1 |= TIM_OCClear;
0008aa  4311              ORRS     r1,r1,r2
;;;1738     /* Write to TIMx CCMR1 register */
;;;1739     TIMx->CCMR1 = tmpccmr1;
0008ac  8301              STRH     r1,[r0,#0x18]
;;;1740   }
0008ae  4770              BX       lr
;;;1741   
                          ENDP

                  TIM_ClearOC2Ref PROC
;;;1751     */
;;;1752   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
0008b0  460a              MOV      r2,r1
;;;1753   {
;;;1754     uint16_t tmpccmr1 = 0;
0008b2  2100              MOVS     r1,#0
;;;1755     /* Check the parameters */
;;;1756     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1757     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1758     tmpccmr1 = TIMx->CCMR1;
0008b4  8b01              LDRH     r1,[r0,#0x18]
;;;1759     /* Reset the OC2CE Bit */
;;;1760     tmpccmr1 &= CCMR_OC24CE_Reset;
0008b6  f3c1010e          UBFX     r1,r1,#0,#15
;;;1761     /* Enable or Disable the Output Compare Clear Bit */
;;;1762     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
0008ba  0613              LSLS     r3,r2,#24
0008bc  ea414113          ORR      r1,r1,r3,LSR #16
;;;1763     /* Write to TIMx CCMR1 register */
;;;1764     TIMx->CCMR1 = tmpccmr1;
0008c0  8301              STRH     r1,[r0,#0x18]
;;;1765   }
0008c2  4770              BX       lr
;;;1766   
                          ENDP

                  TIM_ClearOC3Ref PROC
;;;1776     */
;;;1777   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
0008c4  460a              MOV      r2,r1
;;;1778   {
;;;1779     uint16_t tmpccmr2 = 0;
0008c6  2100              MOVS     r1,#0
;;;1780     /* Check the parameters */
;;;1781     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1782     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1783     tmpccmr2 = TIMx->CCMR2;
0008c8  8b81              LDRH     r1,[r0,#0x1c]
;;;1784     /* Reset the OC3CE Bit */
;;;1785     tmpccmr2 &= CCMR_OC13CE_Reset;
0008ca  f64f737f          MOV      r3,#0xff7f
0008ce  4019              ANDS     r1,r1,r3
;;;1786     /* Enable or Disable the Output Compare Clear Bit */
;;;1787     tmpccmr2 |= TIM_OCClear;
0008d0  4311              ORRS     r1,r1,r2
;;;1788     /* Write to TIMx CCMR2 register */
;;;1789     TIMx->CCMR2 = tmpccmr2;
0008d2  8381              STRH     r1,[r0,#0x1c]
;;;1790   }
0008d4  4770              BX       lr
;;;1791   
                          ENDP

                  TIM_ClearOC4Ref PROC
;;;1801     */
;;;1802   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
0008d6  460a              MOV      r2,r1
;;;1803   {
;;;1804     uint16_t tmpccmr2 = 0;
0008d8  2100              MOVS     r1,#0
;;;1805     /* Check the parameters */
;;;1806     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1807     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1808     tmpccmr2 = TIMx->CCMR2;
0008da  8b81              LDRH     r1,[r0,#0x1c]
;;;1809     /* Reset the OC4CE Bit */
;;;1810     tmpccmr2 &= CCMR_OC24CE_Reset;
0008dc  f3c1010e          UBFX     r1,r1,#0,#15
;;;1811     /* Enable or Disable the Output Compare Clear Bit */
;;;1812     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
0008e0  0613              LSLS     r3,r2,#24
0008e2  ea414113          ORR      r1,r1,r3,LSR #16
;;;1813     /* Write to TIMx CCMR2 register */
;;;1814     TIMx->CCMR2 = tmpccmr2;
0008e6  8381              STRH     r1,[r0,#0x1c]
;;;1815   }
0008e8  4770              BX       lr
;;;1816   
                          ENDP

                  TIM_OC1PolarityConfig PROC
;;;1826     */
;;;1827   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
0008ea  460a              MOV      r2,r1
;;;1828   {
;;;1829     uint16_t tmpccer = 0;
0008ec  2100              MOVS     r1,#0
;;;1830     /* Check the parameters */
;;;1831     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1832     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1833     tmpccer = TIMx->CCER;
0008ee  8c01              LDRH     r1,[r0,#0x20]
;;;1834     /* Set or Reset the CC1P Bit */
;;;1835     tmpccer &= CCER_CC1P_Reset;
0008f0  f64f73fd          MOV      r3,#0xfffd
0008f4  4019              ANDS     r1,r1,r3
;;;1836     tmpccer |= TIM_OCPolarity;
0008f6  4311              ORRS     r1,r1,r2
;;;1837     /* Write to TIMx CCER register */
;;;1838     TIMx->CCER = tmpccer;
0008f8  8401              STRH     r1,[r0,#0x20]
;;;1839   }
0008fa  4770              BX       lr
;;;1840   
                          ENDP

                  TIM_OC1NPolarityConfig PROC
;;;1849     */
;;;1850   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
0008fc  460a              MOV      r2,r1
;;;1851   {
;;;1852     uint16_t tmpccer = 0;
0008fe  2100              MOVS     r1,#0
;;;1853     /* Check the parameters */
;;;1854     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1855     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1856      
;;;1857     tmpccer = TIMx->CCER;
000900  8c01              LDRH     r1,[r0,#0x20]
;;;1858     /* Set or Reset the CC1NP Bit */
;;;1859     tmpccer &= CCER_CC1NP_Reset;
000902  f64f73f7          MOV      r3,#0xfff7
000906  4019              ANDS     r1,r1,r3
;;;1860     tmpccer |= TIM_OCNPolarity;
000908  4311              ORRS     r1,r1,r2
;;;1861     /* Write to TIMx CCER register */
;;;1862     TIMx->CCER = tmpccer;
00090a  8401              STRH     r1,[r0,#0x20]
;;;1863   }
00090c  4770              BX       lr
;;;1864   
                          ENDP

                  TIM_OC2PolarityConfig PROC
;;;1874     */
;;;1875   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
00090e  460a              MOV      r2,r1
;;;1876   {
;;;1877     uint16_t tmpccer = 0;
000910  2100              MOVS     r1,#0
;;;1878     /* Check the parameters */
;;;1879     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1880     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1881     tmpccer = TIMx->CCER;
000912  8c01              LDRH     r1,[r0,#0x20]
;;;1882     /* Set or Reset the CC2P Bit */
;;;1883     tmpccer &= CCER_CC2P_Reset;
000914  f64f73df          MOV      r3,#0xffdf
000918  4019              ANDS     r1,r1,r3
;;;1884     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
00091a  0513              LSLS     r3,r2,#20
00091c  ea414113          ORR      r1,r1,r3,LSR #16
;;;1885     /* Write to TIMx CCER register */
;;;1886     TIMx->CCER = tmpccer;
000920  8401              STRH     r1,[r0,#0x20]
;;;1887   }
000922  4770              BX       lr
;;;1888   
                          ENDP

                  TIM_OC2NPolarityConfig PROC
;;;1897     */
;;;1898   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000924  460a              MOV      r2,r1
;;;1899   {
;;;1900     uint16_t tmpccer = 0;
000926  2100              MOVS     r1,#0
;;;1901     /* Check the parameters */
;;;1902     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1903     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1904     
;;;1905     tmpccer = TIMx->CCER;
000928  8c01              LDRH     r1,[r0,#0x20]
;;;1906     /* Set or Reset the CC2NP Bit */
;;;1907     tmpccer &= CCER_CC2NP_Reset;
00092a  f64f737f          MOV      r3,#0xff7f
00092e  4019              ANDS     r1,r1,r3
;;;1908     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
000930  0513              LSLS     r3,r2,#20
000932  ea414113          ORR      r1,r1,r3,LSR #16
;;;1909     /* Write to TIMx CCER register */
;;;1910     TIMx->CCER = tmpccer;
000936  8401              STRH     r1,[r0,#0x20]
;;;1911   }
000938  4770              BX       lr
;;;1912   
                          ENDP

                  TIM_OC3PolarityConfig PROC
;;;1922     */
;;;1923   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
00093a  460a              MOV      r2,r1
;;;1924   {
;;;1925     uint16_t tmpccer = 0;
00093c  2100              MOVS     r1,#0
;;;1926     /* Check the parameters */
;;;1927     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1928     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1929     tmpccer = TIMx->CCER;
00093e  8c01              LDRH     r1,[r0,#0x20]
;;;1930     /* Set or Reset the CC3P Bit */
;;;1931     tmpccer &= CCER_CC3P_Reset;
000940  f64f53ff          MOV      r3,#0xfdff
000944  4019              ANDS     r1,r1,r3
;;;1932     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
000946  0613              LSLS     r3,r2,#24
000948  ea414113          ORR      r1,r1,r3,LSR #16
;;;1933     /* Write to TIMx CCER register */
;;;1934     TIMx->CCER = tmpccer;
00094c  8401              STRH     r1,[r0,#0x20]
;;;1935   }
00094e  4770              BX       lr
;;;1936   
                          ENDP

                  TIM_OC3NPolarityConfig PROC
;;;1945     */
;;;1946   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000950  460a              MOV      r2,r1
;;;1947   {
;;;1948     uint16_t tmpccer = 0;
000952  2100              MOVS     r1,#0
;;;1949    
;;;1950     /* Check the parameters */
;;;1951     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1952     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1953       
;;;1954     tmpccer = TIMx->CCER;
000954  8c01              LDRH     r1,[r0,#0x20]
;;;1955     /* Set or Reset the CC3NP Bit */
;;;1956     tmpccer &= CCER_CC3NP_Reset;
000956  f24f73ff          MOV      r3,#0xf7ff
00095a  4019              ANDS     r1,r1,r3
;;;1957     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
00095c  0613              LSLS     r3,r2,#24
00095e  ea414113          ORR      r1,r1,r3,LSR #16
;;;1958     /* Write to TIMx CCER register */
;;;1959     TIMx->CCER = tmpccer;
000962  8401              STRH     r1,[r0,#0x20]
;;;1960   }
000964  4770              BX       lr
;;;1961   
                          ENDP

                  TIM_OC4PolarityConfig PROC
;;;1971     */
;;;1972   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000966  460a              MOV      r2,r1
;;;1973   {
;;;1974     uint16_t tmpccer = 0;
000968  2100              MOVS     r1,#0
;;;1975     /* Check the parameters */
;;;1976     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1977     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1978     tmpccer = TIMx->CCER;
00096a  8c01              LDRH     r1,[r0,#0x20]
;;;1979     /* Set or Reset the CC4P Bit */
;;;1980     tmpccer &= CCER_CC4P_Reset;
00096c  f64d73ff          MOV      r3,#0xdfff
000970  4019              ANDS     r1,r1,r3
;;;1981     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
000972  0713              LSLS     r3,r2,#28
000974  ea414113          ORR      r1,r1,r3,LSR #16
;;;1982     /* Write to TIMx CCER register */
;;;1983     TIMx->CCER = tmpccer;
000978  8401              STRH     r1,[r0,#0x20]
;;;1984   }
00097a  4770              BX       lr
;;;1985   
                          ENDP

                  TIM_CCxCmd PROC
;;;1999     */
;;;2000   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
00097c  b510              PUSH     {r4,lr}
;;;2001   {
;;;2002     /* Check the parameters */
;;;2003     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2004     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2005     assert_param(IS_TIM_CCX(TIM_CCx));
;;;2006     /* Reset the CCxE Bit */
;;;2007     TIMx->CCER &= (uint16_t)(~((uint16_t)(CCER_CCE_Set << TIM_Channel)));
00097e  8c04              LDRH     r4,[r0,#0x20]
000980  2301              MOVS     r3,#1
000982  408b              LSLS     r3,r3,r1
000984  43db              MVNS     r3,r3
000986  b29b              UXTH     r3,r3
000988  4023              ANDS     r3,r3,r4
00098a  8403              STRH     r3,[r0,#0x20]
;;;2008     /* Set or reset the CCxE Bit */ 
;;;2009     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
00098c  8c03              LDRH     r3,[r0,#0x20]
00098e  fa02f401          LSL      r4,r2,r1
000992  b2a4              UXTH     r4,r4
000994  4323              ORRS     r3,r3,r4
000996  8403              STRH     r3,[r0,#0x20]
;;;2010   }
000998  bd10              POP      {r4,pc}
;;;2011   
                          ENDP

                  TIM_CCxNCmd PROC
;;;2023     */
;;;2024   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
00099a  b510              PUSH     {r4,lr}
;;;2025   {
;;;2026     /* Check the parameters */
;;;2027     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2028     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2029     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2030     /* Reset the CCxNE Bit */
;;;2031     TIMx->CCER &= (uint16_t)(~((uint16_t)(CCER_CCNE_Set << TIM_Channel)));
00099c  8c04              LDRH     r4,[r0,#0x20]
00099e  2304              MOVS     r3,#4
0009a0  408b              LSLS     r3,r3,r1
0009a2  43db              MVNS     r3,r3
0009a4  b29b              UXTH     r3,r3
0009a6  4023              ANDS     r3,r3,r4
0009a8  8403              STRH     r3,[r0,#0x20]
;;;2032     /* Set or reset the CCxNE Bit */ 
;;;2033     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
0009aa  8c03              LDRH     r3,[r0,#0x20]
0009ac  fa02f401          LSL      r4,r2,r1
0009b0  b2a4              UXTH     r4,r4
0009b2  4323              ORRS     r3,r3,r4
0009b4  8403              STRH     r3,[r0,#0x20]
;;;2034   }
0009b6  bd10              POP      {r4,pc}
;;;2035   
                          ENDP

                  TIM_SelectOCxM PROC
;;;2059     */
;;;2060   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
0009b8  b530              PUSH     {r4,r5,lr}
;;;2061   {
;;;2062     /* Check the parameters */
;;;2063     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2064     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2065     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2066     
;;;2067     /* Disable the Channel: Reset the CCxE Bit */
;;;2068     TIMx->CCER &= (uint16_t)(~((uint16_t)(CCER_CCE_Set << TIM_Channel)));
0009ba  8c04              LDRH     r4,[r0,#0x20]
0009bc  2301              MOVS     r3,#1
0009be  408b              LSLS     r3,r3,r1
0009c0  43db              MVNS     r3,r3
0009c2  b29b              UXTH     r3,r3
0009c4  4023              ANDS     r3,r3,r4
0009c6  8403              STRH     r3,[r0,#0x20]
;;;2069     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
0009c8  b109              CBZ      r1,|L1.2510|
0009ca  2908              CMP      r1,#8
0009cc  d118              BNE      |L1.2560|
                  |L1.2510|
;;;2070     {
;;;2071       /* Reset the OCxM bits in the CCMRx register */
;;;2072       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) &= CCMR_OC13M_Mask;
0009ce  f1000318          ADD      r3,r0,#0x18
0009d2  eb030361          ADD      r3,r3,r1,ASR #1
0009d6  681b              LDR      r3,[r3,#0]
0009d8  f64f748f          MOV      r4,#0xff8f
0009dc  4023              ANDS     r3,r3,r4
0009de  f1000418          ADD      r4,r0,#0x18
0009e2  eb040461          ADD      r4,r4,r1,ASR #1
0009e6  6023              STR      r3,[r4,#0]
;;;2073      
;;;2074       /* Configure the OCxM bits in the CCMRx register */
;;;2075       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) |= TIM_OCMode;
0009e8  f1000318          ADD      r3,r0,#0x18
0009ec  eb030361          ADD      r3,r3,r1,ASR #1
0009f0  681b              LDR      r3,[r3,#0]
0009f2  4313              ORRS     r3,r3,r2
0009f4  f1000418          ADD      r4,r0,#0x18
0009f8  eb040461          ADD      r4,r4,r1,ASR #1
0009fc  6023              STR      r3,[r4,#0]
0009fe  e021              B        |L1.2628|
                  |L1.2560|
;;;2076     }
;;;2077     else
;;;2078     {
;;;2079       /* Reset the OCxM bits in the CCMRx register */
;;;2080       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + ((uint16_t)(TIM_Channel - 4)>> 1))) &= CCMR_OC24M_Mask;
000a00  1f0b              SUBS     r3,r1,#4
000a02  b29c              UXTH     r4,r3
000a04  f1000318          ADD      r3,r0,#0x18
000a08  eb030364          ADD      r3,r3,r4,ASR #1
000a0c  681b              LDR      r3,[r3,#0]
000a0e  f64874ff          MOV      r4,#0x8fff
000a12  4023              ANDS     r3,r3,r4
000a14  1f0c              SUBS     r4,r1,#4
000a16  b2a5              UXTH     r5,r4
000a18  f1000418          ADD      r4,r0,#0x18
000a1c  eb040465          ADD      r4,r4,r5,ASR #1
000a20  6023              STR      r3,[r4,#0]
;;;2081       
;;;2082       /* Configure the OCxM bits in the CCMRx register */
;;;2083       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + ((uint16_t)(TIM_Channel - 4)>> 1))) |= (uint16_t)(TIM_OCMode << 8);
000a22  1f0b              SUBS     r3,r1,#4
000a24  b29c              UXTH     r4,r3
000a26  f1000318          ADD      r3,r0,#0x18
000a2a  eb030364          ADD      r3,r3,r4,ASR #1
000a2e  681b              LDR      r3,[r3,#0]
000a30  0614              LSLS     r4,r2,#24
000a32  ea434314          ORR      r3,r3,r4,LSR #16
000a36  1f0c              SUBS     r4,r1,#4
000a38  b2a5              UXTH     r5,r4
000a3a  f1000418          ADD      r4,r0,#0x18
000a3e  eb040465          ADD      r4,r4,r5,ASR #1
000a42  6023              STR      r3,[r4,#0]
                  |L1.2628|
;;;2084     }
;;;2085   }
000a44  bd30              POP      {r4,r5,pc}
;;;2086   
                          ENDP

                  TIM_UpdateDisableConfig PROC
;;;2093     */
;;;2094   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000a46  b121              CBZ      r1,|L1.2642|
;;;2095   {
;;;2096     /* Check the parameters */
;;;2097     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2098     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2099     if (NewState != DISABLE)
;;;2100     {
;;;2101       /* Set the Update Disable Bit */
;;;2102       TIMx->CR1 |= CR1_UDIS_Set;
000a48  8802              LDRH     r2,[r0,#0]
000a4a  f0420202          ORR      r2,r2,#2
000a4e  8002              STRH     r2,[r0,#0]
000a50  e004              B        |L1.2652|
                  |L1.2642|
;;;2103     }
;;;2104     else
;;;2105     {
;;;2106       /* Reset the Update Disable Bit */
;;;2107       TIMx->CR1 &= CR1_UDIS_Reset;
000a52  8802              LDRH     r2,[r0,#0]
000a54  f24033fd          MOV      r3,#0x3fd
000a58  401a              ANDS     r2,r2,r3
000a5a  8002              STRH     r2,[r0,#0]
                  |L1.2652|
;;;2108     }
;;;2109   }
000a5c  4770              BX       lr
;;;2110   
                          ENDP

                  TIM_UpdateRequestConfig PROC
;;;2119     */
;;;2120   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000a5e  b121              CBZ      r1,|L1.2666|
;;;2121   {
;;;2122     /* Check the parameters */
;;;2123     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2124     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2125     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2126     {
;;;2127       /* Set the URS Bit */
;;;2128       TIMx->CR1 |= CR1_URS_Set;
000a60  8802              LDRH     r2,[r0,#0]
000a62  f0420204          ORR      r2,r2,#4
000a66  8002              STRH     r2,[r0,#0]
000a68  e004              B        |L1.2676|
                  |L1.2666|
;;;2129     }
;;;2130     else
;;;2131     {
;;;2132       /* Reset the URS Bit */
;;;2133       TIMx->CR1 &= CR1_URS_Reset;
000a6a  8802              LDRH     r2,[r0,#0]
000a6c  f24033fb          MOV      r3,#0x3fb
000a70  401a              ANDS     r2,r2,r3
000a72  8002              STRH     r2,[r0,#0]
                  |L1.2676|
;;;2134     }
;;;2135   }
000a74  4770              BX       lr
;;;2136   
                          ENDP

                  TIM_SelectHallSensor PROC
;;;2143     */
;;;2144   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000a76  b121              CBZ      r1,|L1.2690|
;;;2145   {
;;;2146     /* Check the parameters */
;;;2147     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2148     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2149     if (NewState != DISABLE)
;;;2150     {
;;;2151       /* Set the TI1S Bit */
;;;2152       TIMx->CR2 |= CR2_TI1S_Set;
000a78  8882              LDRH     r2,[r0,#4]
000a7a  f0420280          ORR      r2,r2,#0x80
000a7e  8082              STRH     r2,[r0,#4]
000a80  e004              B        |L1.2700|
                  |L1.2690|
;;;2153     }
;;;2154     else
;;;2155     {
;;;2156       /* Reset the TI1S Bit */
;;;2157       TIMx->CR2 &= CR2_TI1S_Reset;
000a82  8882              LDRH     r2,[r0,#4]
000a84  f64f737f          MOV      r3,#0xff7f
000a88  401a              ANDS     r2,r2,r3
000a8a  8082              STRH     r2,[r0,#4]
                  |L1.2700|
;;;2158     }
;;;2159   }
000a8c  4770              BX       lr
;;;2160   
                          ENDP

                  TIM_SelectOnePulseMode PROC
;;;2169     */
;;;2170   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000a8e  8802              LDRH     r2,[r0,#0]
;;;2171   {
;;;2172     /* Check the parameters */
;;;2173     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2174     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2175     /* Reset the OPM Bit */
;;;2176     TIMx->CR1 &= CR1_OPM_Reset;
000a90  f24033f7          MOV      r3,#0x3f7
000a94  401a              ANDS     r2,r2,r3
000a96  8002              STRH     r2,[r0,#0]
;;;2177     /* Configure the OPM Mode */
;;;2178     TIMx->CR1 |= TIM_OPMode;
000a98  8802              LDRH     r2,[r0,#0]
000a9a  430a              ORRS     r2,r2,r1
000a9c  8002              STRH     r2,[r0,#0]
;;;2179   }
000a9e  4770              BX       lr
;;;2180   
                          ENDP

                  TIM_SelectOutputTrigger PROC
;;;2198     */
;;;2199   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000aa0  8882              LDRH     r2,[r0,#4]
;;;2200   {
;;;2201     /* Check the parameters */
;;;2202     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2203     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2204     assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
;;;2205     /* Reset the MMS Bits */
;;;2206     TIMx->CR2 &= CR2_MMS_Mask;
000aa2  f64f738f          MOV      r3,#0xff8f
000aa6  401a              ANDS     r2,r2,r3
000aa8  8082              STRH     r2,[r0,#4]
;;;2207     /* Select the TRGO source */
;;;2208     TIMx->CR2 |=  TIM_TRGOSource;
000aaa  8882              LDRH     r2,[r0,#4]
000aac  430a              ORRS     r2,r2,r1
000aae  8082              STRH     r2,[r0,#4]
;;;2209   }
000ab0  4770              BX       lr
;;;2210   
                          ENDP

                  TIM_SelectSlaveMode PROC
;;;2222     */
;;;2223   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000ab2  8902              LDRH     r2,[r0,#8]
;;;2224   {
;;;2225     /* Check the parameters */
;;;2226     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2227     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2228     /* Reset the SMS Bits */
;;;2229     TIMx->SMCR &= SMCR_SMS_Mask;
000ab4  f64f73f8          MOV      r3,#0xfff8
000ab8  401a              ANDS     r2,r2,r3
000aba  8102              STRH     r2,[r0,#8]
;;;2230     /* Select the Slave Mode */
;;;2231     TIMx->SMCR |= TIM_SlaveMode;
000abc  8902              LDRH     r2,[r0,#8]
000abe  430a              ORRS     r2,r2,r1
000ac0  8102              STRH     r2,[r0,#8]
;;;2232   }
000ac2  4770              BX       lr
;;;2233   
                          ENDP

                  TIM_SelectMasterSlaveMode PROC
;;;2244     */
;;;2245   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000ac4  8902              LDRH     r2,[r0,#8]
;;;2246   {
;;;2247     /* Check the parameters */
;;;2248     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2249     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2250     /* Reset the MSM Bit */
;;;2251     TIMx->SMCR &= SMCR_MSM_Reset;
000ac6  f64f737f          MOV      r3,#0xff7f
000aca  401a              ANDS     r2,r2,r3
000acc  8102              STRH     r2,[r0,#8]
;;;2252     
;;;2253     /* Set or Reset the MSM Bit */
;;;2254     TIMx->SMCR |= TIM_MasterSlaveMode;
000ace  8902              LDRH     r2,[r0,#8]
000ad0  430a              ORRS     r2,r2,r1
000ad2  8102              STRH     r2,[r0,#8]
;;;2255   }
000ad4  4770              BX       lr
;;;2256   
                          ENDP

                  TIM_SetCounter PROC
;;;2262     */
;;;2263   void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
000ad6  8481              STRH     r1,[r0,#0x24]
;;;2264   {
;;;2265     /* Check the parameters */
;;;2266     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2267     /* Set the Counter Register value */
;;;2268     TIMx->CNT = Counter;
;;;2269   }
000ad8  4770              BX       lr
;;;2270   
                          ENDP

                  TIM_SetAutoreload PROC
;;;2276     */
;;;2277   void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
000ada  8581              STRH     r1,[r0,#0x2c]
;;;2278   {
;;;2279     /* Check the parameters */
;;;2280     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2281     /* Set the Autoreload Register value */
;;;2282     TIMx->ARR = Autoreload;
;;;2283   }
000adc  4770              BX       lr
;;;2284   
                          ENDP

                  TIM_SetCompare1 PROC
;;;2291     */
;;;2292   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
000ade  8681              STRH     r1,[r0,#0x34]
;;;2293   {
;;;2294     /* Check the parameters */
;;;2295     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2296     /* Set the Capture Compare1 Register value */
;;;2297     TIMx->CCR1 = Compare1;
;;;2298   }
000ae0  4770              BX       lr
;;;2299   
                          ENDP

                  TIM_SetCompare2 PROC
;;;2306     */
;;;2307   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
000ae2  8701              STRH     r1,[r0,#0x38]
;;;2308   {
;;;2309     /* Check the parameters */
;;;2310     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2311     /* Set the Capture Compare2 Register value */
;;;2312     TIMx->CCR2 = Compare2;
;;;2313   }
000ae4  4770              BX       lr
;;;2314   
                          ENDP

                  TIM_SetCompare3 PROC
;;;2321     */
;;;2322   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
000ae6  8781              STRH     r1,[r0,#0x3c]
;;;2323   {
;;;2324     /* Check the parameters */
;;;2325     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2326     /* Set the Capture Compare3 Register value */
;;;2327     TIMx->CCR3 = Compare3;
;;;2328   }
000ae8  4770              BX       lr
;;;2329   
                          ENDP

                  TIM_SetCompare4 PROC
;;;2336     */
;;;2337   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
000aea  f8a01040          STRH     r1,[r0,#0x40]
;;;2338   {
;;;2339     /* Check the parameters */
;;;2340     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2341     /* Set the Capture Compare4 Register value */
;;;2342     TIMx->CCR4 = Compare4;
;;;2343   }
000aee  4770              BX       lr
;;;2344   
                          ENDP

                  TIM_SetClockDivision PROC
;;;2451     */
;;;2452   void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000af0  8802              LDRH     r2,[r0,#0]
;;;2453   {
;;;2454     /* Check the parameters */
;;;2455     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2456     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2457     /* Reset the CKD Bits */
;;;2458     TIMx->CR1 &= CR1_CKD_Mask;
000af2  b2d2              UXTB     r2,r2
000af4  8002              STRH     r2,[r0,#0]
;;;2459     /* Set the CKD value */
;;;2460     TIMx->CR1 |= TIM_CKD;
000af6  8802              LDRH     r2,[r0,#0]
000af8  430a              ORRS     r2,r2,r1
000afa  8002              STRH     r2,[r0,#0]
;;;2461   }
000afc  4770              BX       lr
;;;2462   
                          ENDP

                  TIM_GetCapture1 PROC
;;;2468     */
;;;2469   uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000afe  4601              MOV      r1,r0
;;;2470   {
;;;2471     /* Check the parameters */
;;;2472     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2473     /* Get the Capture 1 Register value */
;;;2474     return TIMx->CCR1;
000b00  8e88              LDRH     r0,[r1,#0x34]
;;;2475   }
000b02  4770              BX       lr
;;;2476   
                          ENDP

                  TIM_GetCapture2 PROC
;;;2482     */
;;;2483   uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000b04  4601              MOV      r1,r0
;;;2484   {
;;;2485     /* Check the parameters */
;;;2486     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2487     /* Get the Capture 2 Register value */
;;;2488     return TIMx->CCR2;
000b06  8f08              LDRH     r0,[r1,#0x38]
;;;2489   }
000b08  4770              BX       lr
;;;2490   
                          ENDP

                  TIM_GetCapture3 PROC
;;;2496     */
;;;2497   uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000b0a  4601              MOV      r1,r0
;;;2498   {
;;;2499     /* Check the parameters */
;;;2500     assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;2501     /* Get the Capture 3 Register value */
;;;2502     return TIMx->CCR3;
000b0c  8f88              LDRH     r0,[r1,#0x3c]
;;;2503   }
000b0e  4770              BX       lr
;;;2504   
                          ENDP

                  TIM_GetCapture4 PROC
;;;2510     */
;;;2511   uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000b10  4601              MOV      r1,r0
;;;2512   {
;;;2513     /* Check the parameters */
;;;2514     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2515     /* Get the Capture 4 Register value */
;;;2516     return TIMx->CCR4;
000b12  f8b10040          LDRH     r0,[r1,#0x40]
;;;2517   }
000b16  4770              BX       lr
;;;2518   
                          ENDP

                  TIM_GetCounter PROC
;;;2523     */
;;;2524   uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
000b18  4601              MOV      r1,r0
;;;2525   {
;;;2526     /* Check the parameters */
;;;2527     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2528     /* Get the Counter Register value */
;;;2529     return TIMx->CNT;
000b1a  8c88              LDRH     r0,[r1,#0x24]
;;;2530   }
000b1c  4770              BX       lr
;;;2531   
                          ENDP

                  TIM_GetPrescaler PROC
;;;2536     */
;;;2537   uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000b1e  4601              MOV      r1,r0
;;;2538   {
;;;2539     /* Check the parameters */
;;;2540     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2541     /* Get the Prescaler Register value */
;;;2542     return TIMx->PSC;
000b20  8d08              LDRH     r0,[r1,#0x28]
;;;2543   }
000b22  4770              BX       lr
;;;2544   
                          ENDP

                  TIM_GetFlagStatus PROC
;;;2563     */
;;;2564   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000b24  4602              MOV      r2,r0
;;;2565   { 
;;;2566     ITStatus bitstatus = RESET;  
000b26  2000              MOVS     r0,#0
;;;2567     /* Check the parameters */
;;;2568     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2569     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2570     assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
;;;2571     
;;;2572     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000b28  8a13              LDRH     r3,[r2,#0x10]
000b2a  420b              TST      r3,r1
000b2c  d001              BEQ      |L1.2866|
;;;2573     {
;;;2574       bitstatus = SET;
000b2e  2001              MOVS     r0,#1
000b30  e000              B        |L1.2868|
                  |L1.2866|
;;;2575     }
;;;2576     else
;;;2577     {
;;;2578       bitstatus = RESET;
000b32  2000              MOVS     r0,#0
                  |L1.2868|
;;;2579     }
;;;2580     return bitstatus;
;;;2581   }
000b34  4770              BX       lr
;;;2582   
                          ENDP

                  TIM_ClearFlag PROC
;;;2601     */
;;;2602   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000b36  43ca              MVNS     r2,r1
;;;2603   {  
;;;2604     /* Check the parameters */
;;;2605     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2606     assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
;;;2607      
;;;2608     /* Clear the flags */
;;;2609     TIMx->SR = (uint16_t)~TIM_FLAG;
000b38  8202              STRH     r2,[r0,#0x10]
;;;2610   }
000b3a  4770              BX       lr
;;;2611   
                          ENDP

                  TIM_GetITStatus PROC
;;;2627     */
;;;2628   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000b3c  b530              PUSH     {r4,r5,lr}
;;;2629   {
000b3e  4602              MOV      r2,r0
;;;2630     ITStatus bitstatus = RESET;  
000b40  2000              MOVS     r0,#0
;;;2631     uint16_t itstatus = 0x0, itenable = 0x0;
000b42  2300              MOVS     r3,#0
000b44  2400              MOVS     r4,#0
;;;2632     /* Check the parameters */
;;;2633     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2634     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2635     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;2636      
;;;2637     itstatus = TIMx->SR & TIM_IT;
000b46  8a15              LDRH     r5,[r2,#0x10]
000b48  ea050301          AND      r3,r5,r1
;;;2638     
;;;2639     itenable = TIMx->DIER & TIM_IT;
000b4c  8995              LDRH     r5,[r2,#0xc]
000b4e  ea050401          AND      r4,r5,r1
;;;2640     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000b52  b113              CBZ      r3,|L1.2906|
000b54  b10c              CBZ      r4,|L1.2906|
;;;2641     {
;;;2642       bitstatus = SET;
000b56  2001              MOVS     r0,#1
000b58  e000              B        |L1.2908|
                  |L1.2906|
;;;2643     }
;;;2644     else
;;;2645     {
;;;2646       bitstatus = RESET;
000b5a  2000              MOVS     r0,#0
                  |L1.2908|
;;;2647     }
;;;2648     return bitstatus;
;;;2649   }
000b5c  bd30              POP      {r4,r5,pc}
;;;2650   
                          ENDP

                  TIM_ClearITPendingBit PROC
;;;2666     */
;;;2667   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000b5e  43ca              MVNS     r2,r1
;;;2668   {
;;;2669     /* Check the parameters */
;;;2670     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2671     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;2672     /* Clear the IT pending Bit */
;;;2673     TIMx->SR = (uint16_t)~TIM_IT;
000b60  8202              STRH     r2,[r0,#0x10]
;;;2674   }
000b62  4770              BX       lr
;;;2675   
                          ENDP

