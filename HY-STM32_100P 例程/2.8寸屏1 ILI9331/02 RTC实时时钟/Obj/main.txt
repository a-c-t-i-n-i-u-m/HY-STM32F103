; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\main.o --depend=.\Obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\user -I.\FWlib\inc -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Obj\main.crf user\main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Time_Display PROC
;;;370    *******************************************************************************/
;;;371    void Time_Display(u32 TimeVar)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;372    { 
000004  4604              MOV      r4,r0
;;;373      u32 THH = 0, TMM = 0, TSS = 0;
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;374    
;;;375      /* Compute  hours */
;;;376      THH = TimeVar/3600;
00000c  f44f6061          MOV      r0,#0xe10
000010  fbb4f5f0          UDIV     r5,r4,r0
;;;377      /* Compute minutes */
;;;378      TMM = (TimeVar % 3600)/60;
000014  fbb4f1f0          UDIV     r1,r4,r0
000018  fb004011          MLS      r0,r0,r1,r4
00001c  213c              MOVS     r1,#0x3c
00001e  fbb0f6f1          UDIV     r6,r0,r1
;;;379      /* Compute seconds */
;;;380      TSS = (TimeVar % 3600)% 60;
000022  f44f6061          MOV      r0,#0xe10
000026  fbb4f1f0          UDIV     r1,r4,r0
00002a  fb004011          MLS      r0,r0,r1,r4
00002e  213c              MOVS     r1,#0x3c
000030  fbb0f2f1          UDIV     r2,r0,r1
000034  fb010712          MLS      r7,r1,r2,r0
;;;381    
;;;382      printf("Time: %0.2d:%0.2d:%0.2d\r",THH, TMM, TSS);
000038  463b              MOV      r3,r7
00003a  4632              MOV      r2,r6
00003c  4629              MOV      r1,r5
00003e  a0d5              ADR      r0,|L1.916|
000040  f7fffffe          BL       __2printf
;;;383    }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;384    
                          ENDP

                  Time_Show PROC
;;;391    ******************************************************************************/
;;;392    void Time_Show(void)
000048  a0d9              ADR      r0,|L1.944|
;;;393    {
;;;394      printf("\n\r");
00004a  f7fffffe          BL       __2printf
;;;395      
;;;396      /* Infinite loop */ 
;;;397      while(1)
00004e  e00b              B        |L1.104|
                  |L1.80|
;;;398      {
;;;399        /* If 1s has paased */
;;;400        if(TimeDisplay == 1)
000050  48d8              LDR      r0,|L1.948|
000052  6800              LDR      r0,[r0,#0]  ; TimeDisplay
000054  2801              CMP      r0,#1
000056  d107              BNE      |L1.104|
;;;401        {    
;;;402          /* Display current time */
;;;403          Time_Display(RTC_GetCounter());
000058  f7fffffe          BL       RTC_GetCounter
00005c  4604              MOV      r4,r0
00005e  f7fffffe          BL       Time_Display
;;;404          TimeDisplay = 0;
000062  2000              MOVS     r0,#0
000064  49d3              LDR      r1,|L1.948|
000066  6008              STR      r0,[r1,#0]  ; TimeDisplay
                  |L1.104|
000068  e7f2              B        |L1.80|
;;;405        }
;;;406      }
;;;407    }
;;;408    
                          ENDP

                  USART_Scanf PROC
;;;493    *******************************************************************************/
;;;494    u8 USART_Scanf(u32 value)
00006a  b57c              PUSH     {r2-r6,lr}
;;;495    {
00006c  4605              MOV      r5,r0
;;;496      u32 index = 0;
00006e  2400              MOVS     r4,#0
;;;497      u32 tmp[2] = {0, 0};     
000070  2000              MOVS     r0,#0
000072  9000              STR      r0,[sp,#0]
000074  9001              STR      r0,[sp,#4]
;;;498      
;;;499      while(index < 2)
000076  e01b              B        |L1.176|
                  |L1.120|
;;;500      {
;;;501        /* Loop until RXNE = 1 */
;;;502        while(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
000078  bf00              NOP      
                  |L1.122|
00007a  2120              MOVS     r1,#0x20
00007c  48ce              LDR      r0,|L1.952|
00007e  f7fffffe          BL       USART_GetFlagStatus
000082  2800              CMP      r0,#0
000084  d0f9              BEQ      |L1.122|
;;;503        {
;;;504        }
;;;505        tmp[index++] = (USART_ReceiveData(USART1));
000086  48cc              LDR      r0,|L1.952|
000088  f7fffffe          BL       USART_ReceiveData
00008c  4621              MOV      r1,r4
00008e  1c64              ADDS     r4,r4,#1
000090  f84d0021          STR      r0,[sp,r1,LSL #2]
;;;506        if((tmp[index - 1] < 0x30) || (tmp[index - 1] > 0x39))
000094  1e60              SUBS     r0,r4,#1
000096  f85d0020          LDR      r0,[sp,r0,LSL #2]
00009a  2830              CMP      r0,#0x30
00009c  d304              BCC      |L1.168|
00009e  1e60              SUBS     r0,r4,#1
0000a0  f85d0020          LDR      r0,[sp,r0,LSL #2]
0000a4  2839              CMP      r0,#0x39
0000a6  d903              BLS      |L1.176|
                  |L1.168|
;;;507        {
;;;508          printf("\n\rPlease enter valid number between 0 and 9");
0000a8  a0c4              ADR      r0,|L1.956|
0000aa  f7fffffe          BL       __2printf
;;;509          index--;
0000ae  1e64              SUBS     r4,r4,#1
                  |L1.176|
0000b0  2c02              CMP      r4,#2                 ;499
0000b2  d3e1              BCC      |L1.120|
;;;510        }
;;;511      }
;;;512      /* Calculate the Corresponding value */
;;;513      index = (tmp[1] - 0x30) + ((tmp[0] - 0x30) * 10); 
0000b4  9801              LDR      r0,[sp,#4]
0000b6  3830              SUBS     r0,r0,#0x30
0000b8  9900              LDR      r1,[sp,#0]
0000ba  3930              SUBS     r1,r1,#0x30
0000bc  eb010181          ADD      r1,r1,r1,LSL #2
0000c0  eb000441          ADD      r4,r0,r1,LSL #1
;;;514      /* Checks */
;;;515      if(index > value)
0000c4  42ac              CMP      r4,r5
0000c6  d905              BLS      |L1.212|
;;;516      {
;;;517        printf("\n\rPlease enter valid number between 0 and %d", value);
0000c8  4629              MOV      r1,r5
0000ca  a0c7              ADR      r0,|L1.1000|
0000cc  f7fffffe          BL       __2printf
;;;518        return 0xFF;
0000d0  20ff              MOVS     r0,#0xff
                  |L1.210|
;;;519      }
;;;520      return index;
;;;521    }
0000d2  bd7c              POP      {r2-r6,pc}
                  |L1.212|
0000d4  b2e0              UXTB     r0,r4                 ;520
0000d6  e7fc              B        |L1.210|
;;;522    
                          ENDP

                  Time_Regulate PROC
;;;317    *******************************************************************************/
;;;318    u32 Time_Regulate(void)
0000d8  b570              PUSH     {r4-r6,lr}
;;;319    {
;;;320      u32 Tmp_HH = 0xFF, Tmp_MM = 0xFF, Tmp_SS = 0xFF;
0000da  26ff              MOVS     r6,#0xff
0000dc  24ff              MOVS     r4,#0xff
0000de  25ff              MOVS     r5,#0xff
;;;321    
;;;322      printf("\r\n==============Time Settings=====================================");
0000e0  48cd              LDR      r0,|L1.1048|
0000e2  f7fffffe          BL       __2printf
;;;323      printf("\r\n  Please Set Hours");
0000e6  a0cd              ADR      r0,|L1.1052|
0000e8  f7fffffe          BL       __2printf
;;;324      
;;;325      while(Tmp_HH == 0xFF)
0000ec  e003              B        |L1.246|
                  |L1.238|
;;;326      {
;;;327        Tmp_HH = USART_Scanf(23);
0000ee  2017              MOVS     r0,#0x17
0000f0  f7fffffe          BL       USART_Scanf
0000f4  4606              MOV      r6,r0
                  |L1.246|
0000f6  2eff              CMP      r6,#0xff              ;325
0000f8  d0f9              BEQ      |L1.238|
;;;328      }
;;;329      printf(":  %d", Tmp_HH); 
0000fa  4631              MOV      r1,r6
0000fc  a0cd              ADR      r0,|L1.1076|
0000fe  f7fffffe          BL       __2printf
;;;330      printf("\r\n  Please Set Minutes");
000102  a0ce              ADR      r0,|L1.1084|
000104  f7fffffe          BL       __2printf
;;;331      while(Tmp_MM == 0xFF)
000108  e003              B        |L1.274|
                  |L1.266|
;;;332      {
;;;333        Tmp_MM = USART_Scanf(59);
00010a  203b              MOVS     r0,#0x3b
00010c  f7fffffe          BL       USART_Scanf
000110  4604              MOV      r4,r0
                  |L1.274|
000112  2cff              CMP      r4,#0xff              ;331
000114  d0f9              BEQ      |L1.266|
;;;334      }
;;;335      printf(":  %d", Tmp_MM); 
000116  4621              MOV      r1,r4
000118  a0c6              ADR      r0,|L1.1076|
00011a  f7fffffe          BL       __2printf
;;;336      printf("\r\n  Please Set Seconds");
00011e  a0cd              ADR      r0,|L1.1108|
000120  f7fffffe          BL       __2printf
;;;337      while(Tmp_SS == 0xFF)
000124  e003              B        |L1.302|
                  |L1.294|
;;;338      {
;;;339        Tmp_SS = USART_Scanf(59);
000126  203b              MOVS     r0,#0x3b
000128  f7fffffe          BL       USART_Scanf
00012c  4605              MOV      r5,r0
                  |L1.302|
00012e  2dff              CMP      r5,#0xff              ;337
000130  d0f9              BEQ      |L1.294|
;;;340      }
;;;341      printf(":  %d", Tmp_SS); 
000132  4629              MOV      r1,r5
000134  a0bf              ADR      r0,|L1.1076|
000136  f7fffffe          BL       __2printf
;;;342    
;;;343      /* Return the value to store in RTC counter register */
;;;344      return((Tmp_HH*3600 + Tmp_MM*60 + Tmp_SS));
00013a  f44f6061          MOV      r0,#0xe10
00013e  4370              MULS     r0,r6,r0
000140  ebc41104          RSB      r1,r4,r4,LSL #4
000144  eb000081          ADD      r0,r0,r1,LSL #2
000148  4428              ADD      r0,r0,r5
;;;345    }
00014a  bd70              POP      {r4-r6,pc}
;;;346    
                          ENDP

                  Time_Adjust PROC
;;;353    *******************************************************************************/
;;;354    void Time_Adjust(void)
00014c  b510              PUSH     {r4,lr}
;;;355    {
;;;356      /* Wait until last write operation on RTC registers has finished */
;;;357      RTC_WaitForLastTask(); 
00014e  f7fffffe          BL       RTC_WaitForLastTask
;;;358      /* Change the current time */
;;;359      RTC_SetCounter(Time_Regulate());
000152  f7fffffe          BL       Time_Regulate
000156  4604              MOV      r4,r0
000158  f7fffffe          BL       RTC_SetCounter
;;;360      /* Wait until last write operation on RTC registers has finished */
;;;361      RTC_WaitForLastTask();   
00015c  f7fffffe          BL       RTC_WaitForLastTask
;;;362    }
000160  bd10              POP      {r4,pc}
;;;363    
                          ENDP

                  RTC_Configuration PROC
;;;240    *******************************************************************************/
;;;241    void RTC_Configuration(void)
000162  b510              PUSH     {r4,lr}
;;;242    {
;;;243      /* Enable PWR and BKP clocks */
;;;244      RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
000164  2101              MOVS     r1,#1
000166  f04f50c0          MOV      r0,#0x18000000
00016a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;245      
;;;246      /* Allow access to BKP Domain */
;;;247      PWR_BackupAccessCmd(ENABLE);
00016e  2001              MOVS     r0,#1
000170  f7fffffe          BL       PWR_BackupAccessCmd
;;;248    
;;;249      /* Reset Backup Domain */
;;;250      BKP_DeInit();
000174  f7fffffe          BL       BKP_DeInit
;;;251    
;;;252    #ifdef RTCClockSource_LSI
;;;253      /* Enable LSI */ 
;;;254      RCC_LSICmd(ENABLE);
;;;255      /* Wait till LSI is ready */
;;;256      while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
;;;257      {
;;;258      }
;;;259    
;;;260      /* Select LSI as RTC Clock Source */
;;;261      RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);  
;;;262    #elif defined	RTCClockSource_LSE  
;;;263      /* Enable LSE */
;;;264      RCC_LSEConfig(RCC_LSE_ON);
000178  2001              MOVS     r0,#1
00017a  f7fffffe          BL       RCC_LSEConfig
;;;265      /* Wait till LSE is ready */
;;;266      while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
00017e  bf00              NOP      
                  |L1.384|
000180  2041              MOVS     r0,#0x41
000182  f7fffffe          BL       RCC_GetFlagStatus
000186  2800              CMP      r0,#0
000188  d0fa              BEQ      |L1.384|
;;;267      {
;;;268      }
;;;269    
;;;270      /* Select LSE as RTC Clock Source */
;;;271      RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);  
00018a  f44f7080          MOV      r0,#0x100
00018e  f7fffffe          BL       RCC_RTCCLKConfig
;;;272    #endif
;;;273    
;;;274    
;;;275      /* Enable RTC Clock */
;;;276      RCC_RTCCLKCmd(ENABLE);
000192  2001              MOVS     r0,#1
000194  f7fffffe          BL       RCC_RTCCLKCmd
;;;277    
;;;278    
;;;279    #ifdef RTCClockOutput_Enable  
;;;280      /* Disable the Tamper Pin */
;;;281      BKP_TamperPinCmd(DISABLE); /* To output RTCCLK/64 on Tamper pin, the tamper
;;;282                                   functionality must be disabled */
;;;283                                   
;;;284      /* Enable RTC Clock Output on Tamper Pin */
;;;285      BKP_RTCCalibrationClockOutputCmd(ENABLE);
;;;286    #endif 
;;;287    
;;;288      /* Wait for RTC registers synchronization */
;;;289      RTC_WaitForSynchro();
000198  f7fffffe          BL       RTC_WaitForSynchro
;;;290    
;;;291      /* Wait until last write operation on RTC registers has finished */
;;;292      RTC_WaitForLastTask();
00019c  f7fffffe          BL       RTC_WaitForLastTask
;;;293      
;;;294      /* Enable the RTC Second */  
;;;295      RTC_ITConfig(RTC_IT_SEC, ENABLE);
0001a0  2101              MOVS     r1,#1
0001a2  4608              MOV      r0,r1
0001a4  f7fffffe          BL       RTC_ITConfig
;;;296    
;;;297      /* Wait until last write operation on RTC registers has finished */
;;;298      RTC_WaitForLastTask();
0001a8  f7fffffe          BL       RTC_WaitForLastTask
;;;299      
;;;300      /* Set RTC prescaler: set RTC period to 1sec */
;;;301    #ifdef RTCClockSource_LSI
;;;302      RTC_SetPrescaler(31999); /* RTC period = RTCCLK/RTC_PR = (32.000 KHz)/(31999+1) */
;;;303    #elif defined	RTCClockSource_LSE
;;;304      RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
0001ac  f64770ff          MOV      r0,#0x7fff
0001b0  f7fffffe          BL       RTC_SetPrescaler
;;;305    #endif
;;;306      
;;;307      /* Wait until last write operation on RTC registers has finished */
;;;308      RTC_WaitForLastTask();
0001b4  f7fffffe          BL       RTC_WaitForLastTask
;;;309    }
0001b8  bd10              POP      {r4,pc}
;;;310    
                          ENDP

                  USART_Configuration PROC
;;;415    *******************************************************************************/
;;;416    void USART_Configuration(void)
0001ba  b500              PUSH     {lr}
;;;417    {
0001bc  b087              SUB      sp,sp,#0x1c
;;;418      USART_InitTypeDef USART_InitStructure;
;;;419      USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;420    /* USART1 configuration -----------------------------------------------
;;;421    
;;;422    -------*/
;;;423      /* USART1 configured as follow:
;;;424            - BaudRate = 115200 baud  
;;;425            - Word Length = 8 Bits
;;;426            - One Stop Bit
;;;427            - No parity
;;;428            - Hardware flow control disabled (RTS and CTS signals)
;;;429            - Receive and transmit enabled
;;;430            - USART Clock disabled
;;;431            - USART CPOL: Clock is active low
;;;432            - USART CPHA: Data is captured on the middle 
;;;433            - USART LastBit: The clock pulse of the last data bit is not 
;;;434    
;;;435    output to 
;;;436                             the SCLK pin
;;;437      */
;;;438    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
0001be  2000              MOVS     r0,#0
0001c0  f8ad0004          STRH     r0,[sp,#4]
;;;439    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
0001c4  f8ad0006          STRH     r0,[sp,#6]
;;;440    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
0001c8  f44f7000          MOV      r0,#0x200
0001cc  f8ad0008          STRH     r0,[sp,#8]
;;;441    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
0001d0  2000              MOVS     r0,#0
0001d2  f8ad000a          STRH     r0,[sp,#0xa]
;;;442    /* Configure the USART1 synchronous paramters */
;;;443    USART_ClockInit(USART1, &USART_ClockInitStructure);
0001d6  a901              ADD      r1,sp,#4
0001d8  4877              LDR      r0,|L1.952|
0001da  f7fffffe          BL       USART_ClockInit
;;;444    
;;;445    USART_InitStructure.USART_BaudRate = 115200;
0001de  f44f30e1          MOV      r0,#0x1c200
0001e2  9003              STR      r0,[sp,#0xc]
;;;446    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0001e4  2000              MOVS     r0,#0
0001e6  f8ad0010          STRH     r0,[sp,#0x10]
;;;447    USART_InitStructure.USART_StopBits = USART_StopBits_1;
0001ea  f8ad0012          STRH     r0,[sp,#0x12]
;;;448    USART_InitStructure.USART_Parity = USART_Parity_No ;
0001ee  f8ad0014          STRH     r0,[sp,#0x14]
;;;449    USART_InitStructure.USART_HardwareFlowControl = 
0001f2  f8ad0018          STRH     r0,[sp,#0x18]
;;;450    
;;;451    USART_HardwareFlowControl_None;
;;;452    
;;;453    
;;;454    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0001f6  200c              MOVS     r0,#0xc
0001f8  f8ad0016          STRH     r0,[sp,#0x16]
;;;455    /* Configure USART1 basic and asynchronous paramters */
;;;456    USART_Init(USART1, &USART_InitStructure);
0001fc  a903              ADD      r1,sp,#0xc
0001fe  486e              LDR      r0,|L1.952|
000200  f7fffffe          BL       USART_Init
;;;457        
;;;458      /* Enable USART1 */
;;;459      USART_Cmd(USART1, ENABLE);
000204  2101              MOVS     r1,#1
000206  486c              LDR      r0,|L1.952|
000208  f7fffffe          BL       USART_Cmd
;;;460    }
00020c  b007              ADD      sp,sp,#0x1c
00020e  bd00              POP      {pc}
;;;461    
                          ENDP

                  GPIO_Configuration PROC
;;;212    *******************************************************************************/
;;;213    void GPIO_Configuration(void)
000210  b508              PUSH     {r3,lr}
;;;214    {
;;;215      GPIO_InitTypeDef GPIO_InitStructure;
;;;216        
;;;217      /* Configure PC.06 as output push-pull */
;;;218      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000212  2040              MOVS     r0,#0x40
000214  f8ad0000          STRH     r0,[sp,#0]
;;;219      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000218  2003              MOVS     r0,#3
00021a  f88d0002          STRB     r0,[sp,#2]
;;;220      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00021e  2010              MOVS     r0,#0x10
000220  f88d0003          STRB     r0,[sp,#3]
;;;221      GPIO_Init(GPIOC, &GPIO_InitStructure);
000224  4669              MOV      r1,sp
000226  4891              LDR      r0,|L1.1132|
000228  f7fffffe          BL       GPIO_Init
;;;222    
;;;223      /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;224      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00022c  f44f7000          MOV      r0,#0x200
000230  f8ad0000          STRH     r0,[sp,#0]
;;;225      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000234  2018              MOVS     r0,#0x18
000236  f88d0003          STRB     r0,[sp,#3]
;;;226      GPIO_Init(GPIOA, &GPIO_InitStructure);
00023a  4669              MOV      r1,sp
00023c  488c              LDR      r0,|L1.1136|
00023e  f7fffffe          BL       GPIO_Init
;;;227        
;;;228      /* Configure USART1 Rx (PA.10) as input floating */
;;;229      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000242  f44f6080          MOV      r0,#0x400
000246  f8ad0000          STRH     r0,[sp,#0]
;;;230      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00024a  2004              MOVS     r0,#4
00024c  f88d0003          STRB     r0,[sp,#3]
;;;231      GPIO_Init(GPIOA, &GPIO_InitStructure);
000250  4669              MOV      r1,sp
000252  4887              LDR      r0,|L1.1136|
000254  f7fffffe          BL       GPIO_Init
;;;232    }
000258  bd08              POP      {r3,pc}
;;;233    
                          ENDP

                  NVIC_Configuration PROC
;;;190    *******************************************************************************/
;;;191    void NVIC_Configuration(void)
00025a  b508              PUSH     {r3,lr}
;;;192    {
;;;193      NVIC_InitTypeDef NVIC_InitStructure;
;;;194      
;;;195      /* Configure one bit for preemption priority */
;;;196      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
00025c  f44f60c0          MOV      r0,#0x600
000260  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;197      
;;;198      /* Enable the RTC Interrupt */
;;;199      NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;
000264  2003              MOVS     r0,#3
000266  f88d0000          STRB     r0,[sp,#0]
;;;200      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00026a  2001              MOVS     r0,#1
00026c  f88d0001          STRB     r0,[sp,#1]
;;;201      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000270  2000              MOVS     r0,#0
000272  f88d0002          STRB     r0,[sp,#2]
;;;202      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000276  2001              MOVS     r0,#1
000278  f88d0003          STRB     r0,[sp,#3]
;;;203      NVIC_Init(&NVIC_InitStructure);
00027c  4668              MOV      r0,sp
00027e  f7fffffe          BL       NVIC_Init
;;;204    }
000282  bd08              POP      {r3,pc}
;;;205    
                          ENDP

                  RCC_Configuration PROC
;;;131    *******************************************************************************/
;;;132    void RCC_Configuration(void)
000284  b510              PUSH     {r4,lr}
;;;133    {
;;;134      /* RCC system reset(for debug purpose) */
;;;135      RCC_DeInit();
000286  f7fffffe          BL       RCC_DeInit
;;;136    
;;;137      /* Enable HSE */
;;;138      RCC_HSEConfig(RCC_HSE_ON);
00028a  f44f3080          MOV      r0,#0x10000
00028e  f7fffffe          BL       RCC_HSEConfig
;;;139    
;;;140      /* Wait till HSE is ready */
;;;141      HSEStartUpStatus = RCC_WaitForHSEStartUp();
000292  f7fffffe          BL       RCC_WaitForHSEStartUp
000296  4977              LDR      r1,|L1.1140|
000298  7008              STRB     r0,[r1,#0]
;;;142    
;;;143      if(HSEStartUpStatus == SUCCESS)
00029a  4608              MOV      r0,r1
00029c  7800              LDRB     r0,[r0,#0]  ; HSEStartUpStatus
00029e  2801              CMP      r0,#1
0002a0  d126              BNE      |L1.752|
;;;144      {
;;;145        /* HCLK = SYSCLK */
;;;146        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
0002a2  2000              MOVS     r0,#0
0002a4  f7fffffe          BL       RCC_HCLKConfig
;;;147      
;;;148        /* PCLK2 = HCLK */
;;;149        RCC_PCLK2Config(RCC_HCLK_Div1); 
0002a8  2000              MOVS     r0,#0
0002aa  f7fffffe          BL       RCC_PCLK2Config
;;;150    
;;;151        /* PCLK1 = HCLK/2 */
;;;152        RCC_PCLK1Config(RCC_HCLK_Div2);
0002ae  f44f6080          MOV      r0,#0x400
0002b2  f7fffffe          BL       RCC_PCLK1Config
;;;153    
;;;154        /* Flash 2 wait state */
;;;155        FLASH_SetLatency(FLASH_Latency_2);
0002b6  2002              MOVS     r0,#2
0002b8  f7fffffe          BL       FLASH_SetLatency
;;;156        /* Enable Prefetch Buffer */
;;;157        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
0002bc  2010              MOVS     r0,#0x10
0002be  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;158    
;;;159        /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;160        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
0002c2  f44f11e0          MOV      r1,#0x1c0000
0002c6  f44f3080          MOV      r0,#0x10000
0002ca  f7fffffe          BL       RCC_PLLConfig
;;;161    
;;;162        /* Enable PLL */ 
;;;163        RCC_PLLCmd(ENABLE);
0002ce  2001              MOVS     r0,#1
0002d0  f7fffffe          BL       RCC_PLLCmd
;;;164    
;;;165        /* Wait till PLL is ready */
;;;166        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
0002d4  bf00              NOP      
                  |L1.726|
0002d6  2039              MOVS     r0,#0x39
0002d8  f7fffffe          BL       RCC_GetFlagStatus
0002dc  2800              CMP      r0,#0
0002de  d0fa              BEQ      |L1.726|
;;;167        {
;;;168        }
;;;169    
;;;170        /* Select PLL as system clock source */
;;;171        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
0002e0  2002              MOVS     r0,#2
0002e2  f7fffffe          BL       RCC_SYSCLKConfig
;;;172    
;;;173        /* Wait till PLL is used as system clock source */
;;;174        while(RCC_GetSYSCLKSource() != 0x08)
0002e6  bf00              NOP      
                  |L1.744|
0002e8  f7fffffe          BL       RCC_GetSYSCLKSource
0002ec  2808              CMP      r0,#8
0002ee  d1fb              BNE      |L1.744|
                  |L1.752|
;;;175        {
;;;176        }
;;;177      }
;;;178    
;;;179      /* Enable USART1, GPIOA and GPIOC clocks */
;;;180      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | 
0002f0  2101              MOVS     r1,#1
0002f2  f2440014          MOV      r0,#0x4014
0002f6  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;181                             RCC_APB2Periph_GPIOC , ENABLE);
;;;182    }
0002fa  bd10              POP      {r4,pc}
;;;183    
                          ENDP

                  main PROC
;;;59     *******************************************************************************/
;;;60     int main(void)
0002fc  f7fffffe          BL       RCC_Configuration
;;;61     {
;;;62     #ifdef DEBUG
;;;63       debug();
;;;64     #endif
;;;65     
;;;66       /* System Clocks Configuration */
;;;67       RCC_Configuration();
;;;68      
;;;69       /* NVIC configuration */
;;;70       NVIC_Configuration();
000300  f7fffffe          BL       NVIC_Configuration
;;;71     
;;;72       /* Configure the GPIOs */
;;;73       GPIO_Configuration();
000304  f7fffffe          BL       GPIO_Configuration
;;;74       
;;;75       /* Configure the USART1 */
;;;76       USART_Configuration();
000308  f7fffffe          BL       USART_Configuration
;;;77          
;;;78       if(BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5)
00030c  2004              MOVS     r0,#4
00030e  f7fffffe          BL       BKP_ReadBackupRegister
000312  f5a04125          SUB      r1,r0,#0xa500
000316  39a5              SUBS     r1,r1,#0xa5
000318  d00f              BEQ      |L1.826|
;;;79       {
;;;80         /* Backup data register value is not correct or not yet programmed (when
;;;81            the first time the program is executed) */
;;;82     
;;;83         printf("\r\n\n RTC not yet configured....");
00031a  a057              ADR      r0,|L1.1144|
00031c  f7fffffe          BL       __2printf
;;;84        
;;;85         /* RTC Configuration */
;;;86         RTC_Configuration();
000320  f7fffffe          BL       RTC_Configuration
;;;87     
;;;88          printf("\r\n RTC configured....");
000324  a05c              ADR      r0,|L1.1176|
000326  f7fffffe          BL       __2printf
;;;89      
;;;90         /* Adjust time by values entred by the user on the hyperterminal */
;;;91         Time_Adjust();
00032a  f7fffffe          BL       Time_Adjust
;;;92     
;;;93         BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);    
00032e  f24a51a5          MOV      r1,#0xa5a5
000332  2004              MOVS     r0,#4
000334  f7fffffe          BL       BKP_WriteBackupRegister
000338  e019              B        |L1.878|
                  |L1.826|
;;;94       }
;;;95       else
;;;96       {
;;;97         /* Check if the Power On Reset flag is set */
;;;98         if(RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)
00033a  207b              MOVS     r0,#0x7b
00033c  f7fffffe          BL       RCC_GetFlagStatus
000340  b118              CBZ      r0,|L1.842|
;;;99         {
;;;100          printf("\r\n\n Power On Reset occurred....");
000342  a05b              ADR      r0,|L1.1200|
000344  f7fffffe          BL       __2printf
000348  e006              B        |L1.856|
                  |L1.842|
;;;101        }
;;;102        /* Check if the Pin Reset flag is set */
;;;103        else if(RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET)
00034a  207a              MOVS     r0,#0x7a
00034c  f7fffffe          BL       RCC_GetFlagStatus
000350  b110              CBZ      r0,|L1.856|
;;;104        {
;;;105          printf("\r\n\n External Reset occurred....");
000352  a05f              ADR      r0,|L1.1232|
000354  f7fffffe          BL       __2printf
                  |L1.856|
;;;106        }
;;;107    
;;;108        printf("\r\n No need to configure RTC....");    
000358  a065              ADR      r0,|L1.1264|
00035a  f7fffffe          BL       __2printf
;;;109        /* Wait for RTC registers synchronization */
;;;110        RTC_WaitForSynchro();
00035e  f7fffffe          BL       RTC_WaitForSynchro
;;;111    
;;;112        /* Enable the RTC Second */  
;;;113        RTC_ITConfig(RTC_IT_SEC, ENABLE);
000362  2101              MOVS     r1,#1
000364  4608              MOV      r0,r1
000366  f7fffffe          BL       RTC_ITConfig
;;;114        /* Wait until last write operation on RTC registers has finished */
;;;115        RTC_WaitForLastTask();
00036a  f7fffffe          BL       RTC_WaitForLastTask
                  |L1.878|
;;;116      }
;;;117    
;;;118      /* Clear reset flags */
;;;119      RCC_ClearFlag();
00036e  f7fffffe          BL       RCC_ClearFlag
;;;120      
;;;121      /* Display time in infinte loop */
;;;122      Time_Show();
000372  f7fffffe          BL       Time_Show
;;;123    }
;;;124    
                          ENDP

                  fputc PROC
;;;469    
;;;470    int fputc(int ch, FILE *f)
000376  b570              PUSH     {r4-r6,lr}
;;;471    {
000378  4604              MOV      r4,r0
00037a  460d              MOV      r5,r1
;;;472    #ifdef DBG_ITM
;;;473    /* 将Printf内容发往ITM激励寄存器端口  */
;;;474      if (DEMCR & TRCENA) {
;;;475        while (ITM_Port32(0) == 0);
;;;476        ITM_Port8(0) = ch;
;;;477      }
;;;478    #else  
;;;479    /* 将Printf内容发往串口 */
;;;480      USART_SendData(USART1, (unsigned char) ch);
00037c  b2e1              UXTB     r1,r4
00037e  480e              LDR      r0,|L1.952|
000380  f7fffffe          BL       USART_SendData
;;;481      while (!(USART1->SR & USART_FLAG_TXE));
000384  bf00              NOP      
                  |L1.902|
000386  480c              LDR      r0,|L1.952|
000388  8800              LDRH     r0,[r0,#0]
00038a  f0100f80          TST      r0,#0x80
00038e  d0fa              BEQ      |L1.902|
;;;482    #endif  
;;;483      return (ch);
000390  4620              MOV      r0,r4
;;;484    }
000392  bd70              POP      {r4-r6,pc}
;;;485    
                          ENDP

                  |L1.916|
000394  54696d65          DCB      "Time: %0.2d:%0.2d:%0.2d\r",0
000398  3a202530
00039c  2e32643a
0003a0  25302e32
0003a4  643a2530
0003a8  2e32640d
0003ac  00      
0003ad  00                DCB      0
0003ae  00                DCB      0
0003af  00                DCB      0
                  |L1.944|
0003b0  0a0d00            DCB      "\n\r",0
0003b3  00                DCB      0
                  |L1.948|
                          DCD      TimeDisplay
                  |L1.952|
                          DCD      0x40013800
                  |L1.956|
0003bc  0a0d506c          DCB      "\n\rPlease enter valid number between 0 and 9",0
0003c0  65617365
0003c4  20656e74
0003c8  65722076
0003cc  616c6964
0003d0  206e756d
0003d4  62657220
0003d8  62657477
0003dc  65656e20
0003e0  3020616e
0003e4  64203900
                  |L1.1000|
0003e8  0a0d506c          DCB      "\n\rPlease enter valid number between 0 and %d",0
0003ec  65617365
0003f0  20656e74
0003f4  65722076
0003f8  616c6964
0003fc  206e756d
000400  62657220
000404  62657477
000408  65656e20
00040c  3020616e
000410  64202564
000414  00      
000415  00                DCB      0
000416  00                DCB      0
000417  00                DCB      0
                  |L1.1048|
                          DCD      ||.constdata||
                  |L1.1052|
00041c  0d0a2020          DCB      "\r\n  Please Set Hours",0
000420  506c6561
000424  73652053
000428  65742048
00042c  6f757273
000430  00      
000431  00                DCB      0
000432  00                DCB      0
000433  00                DCB      0
                  |L1.1076|
000434  3a202025          DCB      ":  %d",0
000438  6400    
00043a  00                DCB      0
00043b  00                DCB      0
                  |L1.1084|
00043c  0d0a2020          DCB      "\r\n  Please Set Minutes",0
000440  506c6561
000444  73652053
000448  6574204d
00044c  696e7574
000450  657300  
000453  00                DCB      0
                  |L1.1108|
000454  0d0a2020          DCB      "\r\n  Please Set Seconds",0
000458  506c6561
00045c  73652053
000460  65742053
000464  65636f6e
000468  647300  
00046b  00                DCB      0
                  |L1.1132|
                          DCD      0x40011000
                  |L1.1136|
                          DCD      0x40010800
                  |L1.1140|
                          DCD      HSEStartUpStatus
                  |L1.1144|
000478  0d0a0a20          DCB      "\r\n\n RTC not yet configured....",0
00047c  52544320
000480  6e6f7420
000484  79657420
000488  636f6e66
00048c  69677572
000490  65642e2e
000494  2e2e00  
000497  00                DCB      0
                  |L1.1176|
000498  0d0a2052          DCB      "\r\n RTC configured....",0
00049c  54432063
0004a0  6f6e6669
0004a4  67757265
0004a8  642e2e2e
0004ac  2e00    
0004ae  00                DCB      0
0004af  00                DCB      0
                  |L1.1200|
0004b0  0d0a0a20          DCB      "\r\n\n Power On Reset occurred....",0
0004b4  506f7765
0004b8  72204f6e
0004bc  20526573
0004c0  6574206f
0004c4  63637572
0004c8  7265642e
0004cc  2e2e2e00
                  |L1.1232|
0004d0  0d0a0a20          DCB      "\r\n\n External Reset occurred....",0
0004d4  45787465
0004d8  726e616c
0004dc  20526573
0004e0  6574206f
0004e4  63637572
0004e8  7265642e
0004ec  2e2e2e00
                  |L1.1264|
0004f0  0d0a204e          DCB      "\r\n No need to configure RTC....",0
0004f4  6f206e65
0004f8  65642074
0004fc  6f20636f
000500  6e666967
000504  75726520
000508  5254432e
00050c  2e2e2e00

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  0d0a3d3d          DCB      0x0d,0x0a,0x3d,0x3d
000004  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000008  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00000c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000010  54696d65          DCB      0x54,0x69,0x6d,0x65
000014  20536574          DCB      0x20,0x53,0x65,0x74
000018  74696e67          DCB      0x74,0x69,0x6e,0x67
00001c  733d3d3d          DCB      0x73,0x3d,0x3d,0x3d
000020  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000024  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000028  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00002c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000030  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000034  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000038  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00003c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000040  3d3d00            DCB      0x3d,0x3d,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  TimeDisplay
                          DCD      0x00000000
                  HSEStartUpStatus
000004  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
