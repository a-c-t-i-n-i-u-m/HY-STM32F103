; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\stm32f10x_usart.o --depend=.\Obj\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\user -I.\FWlib\inc -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Obj\stm32f10x_usart.crf FWlib\SRC\stm32f10x_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;131      */
;;;132    void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;133    {
000002  4604              MOV      r4,r0
;;;134      /* Check the parameters */
;;;135      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;136      switch (*(uint32_t*)&USARTx)
000004  49d9              LDR      r1,|L1.876|
000006  1a60              SUBS     r0,r4,r1
000008  428c              CMP      r4,r1
00000a  d02b              BEQ      |L1.100|
00000c  dc06              BGT      |L1.28|
00000e  48d8              LDR      r0,|L1.880|
000010  1820              ADDS     r0,r4,r0
000012  d013              BEQ      |L1.60|
000014  f5b06f80          CMP      r0,#0x400
000018  d138              BNE      |L1.140|
00001a  e019              B        |L1.80|
                  |L1.28|
00001c  f5b06f80          CMP      r0,#0x400
000020  d02a              BEQ      |L1.120|
000022  f5b04f6c          CMP      r0,#0xec00
000026  d131              BNE      |L1.140|
;;;137      {
;;;138        case USART1_BASE:
;;;139          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
000028  2101              MOVS     r1,#1
00002a  0388              LSLS     r0,r1,#14
00002c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;140          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000030  2100              MOVS     r1,#0
000032  f44f4080          MOV      r0,#0x4000
000036  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;141          break;
00003a  e028              B        |L1.142|
                  |L1.60|
;;;142        case USART2_BASE:
;;;143          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  0448              LSLS     r0,r1,#17
000040  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;144          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
000044  2100              MOVS     r1,#0
000046  f44f3000          MOV      r0,#0x20000
00004a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;145          break;
00004e  e01e              B        |L1.142|
                  |L1.80|
;;;146        case USART3_BASE:
;;;147          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000050  2101              MOVS     r1,#1
000052  0488              LSLS     r0,r1,#18
000054  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;148          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000058  2100              MOVS     r1,#0
00005a  f44f2080          MOV      r0,#0x40000
00005e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;149          break;
000062  e014              B        |L1.142|
                  |L1.100|
;;;150        
;;;151        case UART4_BASE:
;;;152          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000064  2101              MOVS     r1,#1
000066  04c8              LSLS     r0,r1,#19
000068  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;153          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
00006c  2100              MOVS     r1,#0
00006e  f44f2000          MOV      r0,#0x80000
000072  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;154          break;
000076  e00a              B        |L1.142|
                  |L1.120|
;;;155        
;;;156        case UART5_BASE:
;;;157          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000078  2101              MOVS     r1,#1
00007a  0508              LSLS     r0,r1,#20
00007c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;158          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000080  2100              MOVS     r1,#0
000082  f44f1080          MOV      r0,#0x100000
000086  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;159          break;            
00008a  e000              B        |L1.142|
                  |L1.140|
;;;160        default:
;;;161          break;
00008c  bf00              NOP      
                  |L1.142|
00008e  bf00              NOP                            ;141
;;;162      }
;;;163    }
000090  bd10              POP      {r4,pc}
;;;164    
                          ENDP

                  USART_Init PROC
;;;175      */
;;;176    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000092  e92d47f0          PUSH     {r4-r10,lr}
;;;177    {
000096  b086              SUB      sp,sp,#0x18
000098  4605              MOV      r5,r0
00009a  460e              MOV      r6,r1
;;;178      uint32_t tmpreg = 0x00, apbclock = 0x00;
00009c  2400              MOVS     r4,#0
00009e  46a2              MOV      r10,r4
;;;179      uint32_t integerdivider = 0x00;
0000a0  bf00              NOP      
;;;180      uint32_t fractionaldivider = 0x00;
0000a2  bf00              NOP      
;;;181      uint32_t usartxbase = 0;
0000a4  2700              MOVS     r7,#0
;;;182      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;183      /* Check the parameters */
;;;184      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;185      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;186      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;187      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;188      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;189      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;190      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;191      /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;192      assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct->USART_HardwareFlowControl));
;;;193    
;;;194      usartxbase = (*(uint32_t*)&USARTx);
0000a6  462f              MOV      r7,r5
;;;195    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;196      tmpreg = USARTx->CR2;
0000a8  8a2c              LDRH     r4,[r5,#0x10]
;;;197      /* Clear STOP[13:12] bits */
;;;198      tmpreg &= CR2_STOP_CLEAR_Mask;
0000aa  f64c70ff          MOV      r0,#0xcfff
0000ae  4004              ANDS     r4,r4,r0
;;;199      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;200      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;201      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
0000b0  88f0              LDRH     r0,[r6,#6]
0000b2  4304              ORRS     r4,r4,r0
;;;202      
;;;203      /* Write to USART CR2 */
;;;204      USARTx->CR2 = (uint16_t)tmpreg;
0000b4  822c              STRH     r4,[r5,#0x10]
;;;205    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;206      tmpreg = USARTx->CR1;
0000b6  89ac              LDRH     r4,[r5,#0xc]
;;;207      /* Clear M, PCE, PS, TE and RE bits */
;;;208      tmpreg &= CR1_CLEAR_Mask;
0000b8  f64e10f3          MOV      r0,#0xe9f3
0000bc  4004              ANDS     r4,r4,r0
;;;209      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;210      /* Set the M bits according to USART_WordLength value */
;;;211      /* Set PCE and PS bits according to USART_Parity value */
;;;212      /* Set TE and RE bits according to USART_Mode value */
;;;213      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
0000be  88b0              LDRH     r0,[r6,#4]
0000c0  8931              LDRH     r1,[r6,#8]
0000c2  4308              ORRS     r0,r0,r1
0000c4  8971              LDRH     r1,[r6,#0xa]
0000c6  4308              ORRS     r0,r0,r1
0000c8  4304              ORRS     r4,r4,r0
;;;214                USART_InitStruct->USART_Mode;
;;;215      /* Write to USART CR1 */
;;;216      USARTx->CR1 = (uint16_t)tmpreg;
0000ca  81ac              STRH     r4,[r5,#0xc]
;;;217    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;218      tmpreg = USARTx->CR3;
0000cc  8aac              LDRH     r4,[r5,#0x14]
;;;219      /* Clear CTSE and RTSE bits */
;;;220      tmpreg &= CR3_CLEAR_Mask;
0000ce  f64f40ff          MOV      r0,#0xfcff
0000d2  4004              ANDS     r4,r4,r0
;;;221      /* Configure the USART HFC -------------------------------------------------*/
;;;222      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;223      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
0000d4  89b0              LDRH     r0,[r6,#0xc]
0000d6  4304              ORRS     r4,r4,r0
;;;224      /* Write to USART CR3 */
;;;225      USARTx->CR3 = (uint16_t)tmpreg;
0000d8  82ac              STRH     r4,[r5,#0x14]
;;;226    /*---------------------------- USART BRR Configuration -----------------------*/
;;;227      /* Configure the USART Baud Rate -------------------------------------------*/
;;;228      RCC_GetClocksFreq(&RCC_ClocksStatus);
0000da  a801              ADD      r0,sp,#4
0000dc  f7fffffe          BL       RCC_GetClocksFreq
;;;229      if (usartxbase == USART1_BASE)
0000e0  48a4              LDR      r0,|L1.884|
0000e2  4287              CMP      r7,r0
0000e4  d102              BNE      |L1.236|
;;;230      {
;;;231        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
0000e6  f8dda010          LDR      r10,[sp,#0x10]
0000ea  e001              B        |L1.240|
                  |L1.236|
;;;232      }
;;;233      else
;;;234      {
;;;235        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
0000ec  f8dda00c          LDR      r10,[sp,#0xc]
                  |L1.240|
;;;236      }
;;;237      /* Determine the integer part */
;;;238      integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
0000f0  eb0a00ca          ADD      r0,r10,r10,LSL #3
0000f4  eb00100a          ADD      r0,r0,r10,LSL #4
0000f8  6831              LDR      r1,[r6,#0]
0000fa  0089              LSLS     r1,r1,#2
0000fc  fbb0f8f1          UDIV     r8,r0,r1
;;;239      tmpreg = (integerdivider / 0x64) << 0x04;
000100  2064              MOVS     r0,#0x64
000102  fbb8f0f0          UDIV     r0,r8,r0
000106  0104              LSLS     r4,r0,#4
;;;240      /* Determine the fractional part */
;;;241      fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
000108  0920              LSRS     r0,r4,#4
00010a  2164              MOVS     r1,#0x64
00010c  fb018910          MLS      r9,r1,r0,r8
;;;242      tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((uint8_t)0x0F);
000110  2032              MOVS     r0,#0x32
000112  eb001009          ADD      r0,r0,r9,LSL #4
000116  fbb0f0f1          UDIV     r0,r0,r1
00011a  f000000f          AND      r0,r0,#0xf
00011e  4304              ORRS     r4,r4,r0
;;;243      /* Write to USART BRR */
;;;244      USARTx->BRR = (uint16_t)tmpreg;
000120  812c              STRH     r4,[r5,#8]
;;;245    }
000122  b006              ADD      sp,sp,#0x18
000124  e8bd87f0          POP      {r4-r10,pc}
;;;246    
                          ENDP

                  USART_StructInit PROC
;;;252      */
;;;253    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000128  f44f5116          MOV      r1,#0x2580
;;;254    {
;;;255      /* USART_InitStruct members default value */
;;;256      USART_InitStruct->USART_BaudRate = 9600;
00012c  6001              STR      r1,[r0,#0]
;;;257      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
00012e  2100              MOVS     r1,#0
000130  8081              STRH     r1,[r0,#4]
;;;258      USART_InitStruct->USART_StopBits = USART_StopBits_1;
000132  80c1              STRH     r1,[r0,#6]
;;;259      USART_InitStruct->USART_Parity = USART_Parity_No ;
000134  8101              STRH     r1,[r0,#8]
;;;260      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000136  210c              MOVS     r1,#0xc
000138  8141              STRH     r1,[r0,#0xa]
;;;261      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
00013a  2100              MOVS     r1,#0
00013c  8181              STRH     r1,[r0,#0xc]
;;;262    }
00013e  4770              BX       lr
;;;263    
                          ENDP

                  USART_ClockInit PROC
;;;273      */
;;;274    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000140  b510              PUSH     {r4,lr}
;;;275    {
000142  4602              MOV      r2,r0
;;;276      uint32_t tmpreg = 0x00;
000144  2000              MOVS     r0,#0
;;;277      /* Check the parameters */
;;;278      assert_param(IS_USART_123_PERIPH(USARTx));
;;;279      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;280      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;281      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;282      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;283      
;;;284    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;285      tmpreg = USARTx->CR2;
000146  8a10              LDRH     r0,[r2,#0x10]
;;;286      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;287      tmpreg &= CR2_CLOCK_CLEAR_Mask;
000148  f24f03ff          MOV      r3,#0xf0ff
00014c  4018              ANDS     r0,r0,r3
;;;288      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;289      /* Set CLKEN bit according to USART_Clock value */
;;;290      /* Set CPOL bit according to USART_CPOL value */
;;;291      /* Set CPHA bit according to USART_CPHA value */
;;;292      /* Set LBCL bit according to USART_LastBit value */
;;;293      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00014e  880b              LDRH     r3,[r1,#0]
000150  884c              LDRH     r4,[r1,#2]
000152  4323              ORRS     r3,r3,r4
000154  888c              LDRH     r4,[r1,#4]
000156  4323              ORRS     r3,r3,r4
000158  88cc              LDRH     r4,[r1,#6]
00015a  4323              ORRS     r3,r3,r4
00015c  4318              ORRS     r0,r0,r3
;;;294                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;295      /* Write to USART CR2 */
;;;296      USARTx->CR2 = (uint16_t)tmpreg;
00015e  8210              STRH     r0,[r2,#0x10]
;;;297    }
000160  bd10              POP      {r4,pc}
;;;298    
                          ENDP

                  USART_ClockStructInit PROC
;;;304      */
;;;305    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000162  2100              MOVS     r1,#0
;;;306    {
;;;307      /* USART_ClockInitStruct members default value */
;;;308      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000164  8001              STRH     r1,[r0,#0]
;;;309      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000166  8041              STRH     r1,[r0,#2]
;;;310      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000168  8081              STRH     r1,[r0,#4]
;;;311      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
00016a  80c1              STRH     r1,[r0,#6]
;;;312    }
00016c  4770              BX       lr
;;;313    
                          ENDP

                  USART_Cmd PROC
;;;322      */
;;;323    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
00016e  b121              CBZ      r1,|L1.378|
;;;324    {
;;;325      /* Check the parameters */
;;;326      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;327      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;328      
;;;329      if (NewState != DISABLE)
;;;330      {
;;;331        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;332        USARTx->CR1 |= CR1_UE_Set;
000170  8982              LDRH     r2,[r0,#0xc]
000172  f4425200          ORR      r2,r2,#0x2000
000176  8182              STRH     r2,[r0,#0xc]
000178  e004              B        |L1.388|
                  |L1.378|
;;;333      }
;;;334      else
;;;335      {
;;;336        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;337        USARTx->CR1 &= CR1_UE_Reset;
00017a  8982              LDRH     r2,[r0,#0xc]
00017c  f64d73ff          MOV      r3,#0xdfff
000180  401a              ANDS     r2,r2,r3
000182  8182              STRH     r2,[r0,#0xc]
                  |L1.388|
;;;338      }
;;;339    }
000184  4770              BX       lr
;;;340    
                          ENDP

                  USART_ITConfig PROC
;;;363      */
;;;364    void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000186  b5f0              PUSH     {r4-r7,lr}
;;;365    {
000188  4603              MOV      r3,r0
;;;366      uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
00018a  2400              MOVS     r4,#0
00018c  2600              MOVS     r6,#0
00018e  2500              MOVS     r5,#0
;;;367      uint32_t usartxbase = 0x00;
000190  2000              MOVS     r0,#0
;;;368      /* Check the parameters */
;;;369      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;370      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;371      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
;;;372      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;373      usartxbase = (*(uint32_t*)&(USARTx));
000192  4618              MOV      r0,r3
;;;374      /* Get the USART register index */
;;;375      usartreg = (((uint8_t)USART_IT) >> 0x05);
000194  f3c11442          UBFX     r4,r1,#5,#3
;;;376      /* Get the interrupt position */
;;;377      itpos = USART_IT & IT_Mask;
000198  f001061f          AND      r6,r1,#0x1f
;;;378      itmask = (((uint32_t)0x01) << itpos);
00019c  2701              MOVS     r7,#1
00019e  fa07f506          LSL      r5,r7,r6
;;;379        
;;;380      if (usartreg == 0x01) /* The IT is in CR1 register */
0001a2  2c01              CMP      r4,#1
0001a4  d101              BNE      |L1.426|
;;;381      {
;;;382        usartxbase += 0x0C;
0001a6  300c              ADDS     r0,r0,#0xc
0001a8  e004              B        |L1.436|
                  |L1.426|
;;;383      }
;;;384      else if (usartreg == 0x02) /* The IT is in CR2 register */
0001aa  2c02              CMP      r4,#2
0001ac  d101              BNE      |L1.434|
;;;385      {
;;;386        usartxbase += 0x10;
0001ae  3010              ADDS     r0,r0,#0x10
0001b0  e000              B        |L1.436|
                  |L1.434|
;;;387      }
;;;388      else /* The IT is in CR3 register */
;;;389      {
;;;390        usartxbase += 0x14; 
0001b2  3014              ADDS     r0,r0,#0x14
                  |L1.436|
;;;391      }
;;;392      if (NewState != DISABLE)
0001b4  b11a              CBZ      r2,|L1.446|
;;;393      {
;;;394        *(__IO uint32_t*)usartxbase  |= itmask;
0001b6  6807              LDR      r7,[r0,#0]
0001b8  432f              ORRS     r7,r7,r5
0001ba  6007              STR      r7,[r0,#0]
0001bc  e002              B        |L1.452|
                  |L1.446|
;;;395      }
;;;396      else
;;;397      {
;;;398        *(__IO uint32_t*)usartxbase &= ~itmask;
0001be  6807              LDR      r7,[r0,#0]
0001c0  43af              BICS     r7,r7,r5
0001c2  6007              STR      r7,[r0,#0]
                  |L1.452|
;;;399      }
;;;400    }
0001c4  bdf0              POP      {r4-r7,pc}
;;;401    
                          ENDP

                  USART_DMACmd PROC
;;;415      */
;;;416    void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
0001c6  b510              PUSH     {r4,lr}
;;;417    {
;;;418      /* Check the parameters */
;;;419      assert_param(IS_USART_1234_PERIPH(USARTx));
;;;420      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;421      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;422      if (NewState != DISABLE)
0001c8  b11a              CBZ      r2,|L1.466|
;;;423      {
;;;424        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;425           DMAR bits in the USART CR3 register */
;;;426        USARTx->CR3 |= USART_DMAReq;
0001ca  8a83              LDRH     r3,[r0,#0x14]
0001cc  430b              ORRS     r3,r3,r1
0001ce  8283              STRH     r3,[r0,#0x14]
0001d0  e004              B        |L1.476|
                  |L1.466|
;;;427      }
;;;428      else
;;;429      {
;;;430        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;431           DMAR bits in the USART CR3 register */
;;;432        USARTx->CR3 &= (uint16_t)~USART_DMAReq;
0001d2  8a83              LDRH     r3,[r0,#0x14]
0001d4  43cc              MVNS     r4,r1
0001d6  b2a4              UXTH     r4,r4
0001d8  4023              ANDS     r3,r3,r4
0001da  8283              STRH     r3,[r0,#0x14]
                  |L1.476|
;;;433      }
;;;434    }
0001dc  bd10              POP      {r4,pc}
;;;435    
                          ENDP

                  USART_SetAddress PROC
;;;443      */
;;;444    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
0001de  8a02              LDRH     r2,[r0,#0x10]
;;;445    {
;;;446      /* Check the parameters */
;;;447      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;448      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;449        
;;;450      /* Clear the USART address */
;;;451      USARTx->CR2 &= CR2_Address_Mask;
0001e0  f64f73f0          MOV      r3,#0xfff0
0001e4  401a              ANDS     r2,r2,r3
0001e6  8202              STRH     r2,[r0,#0x10]
;;;452      /* Set the USART address node */
;;;453      USARTx->CR2 |= USART_Address;
0001e8  8a02              LDRH     r2,[r0,#0x10]
0001ea  430a              ORRS     r2,r2,r1
0001ec  8202              STRH     r2,[r0,#0x10]
;;;454    }
0001ee  4770              BX       lr
;;;455    
                          ENDP

                  USART_WakeUpConfig PROC
;;;466      */
;;;467    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
0001f0  8982              LDRH     r2,[r0,#0xc]
;;;468    {
;;;469      /* Check the parameters */
;;;470      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;471      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;472      
;;;473      USARTx->CR1 &= CR1_WAKE_Mask;
0001f2  f24f73ff          MOV      r3,#0xf7ff
0001f6  401a              ANDS     r2,r2,r3
0001f8  8182              STRH     r2,[r0,#0xc]
;;;474      USARTx->CR1 |= USART_WakeUp;
0001fa  8982              LDRH     r2,[r0,#0xc]
0001fc  430a              ORRS     r2,r2,r1
0001fe  8182              STRH     r2,[r0,#0xc]
;;;475    }
000200  4770              BX       lr
;;;476    
                          ENDP

                  USART_ReceiverWakeUpCmd PROC
;;;485      */
;;;486    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000202  b121              CBZ      r1,|L1.526|
;;;487    {
;;;488      /* Check the parameters */
;;;489      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;490      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;491      
;;;492      if (NewState != DISABLE)
;;;493      {
;;;494        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;495        USARTx->CR1 |= CR1_RWU_Set;
000204  8982              LDRH     r2,[r0,#0xc]
000206  f0420202          ORR      r2,r2,#2
00020a  8182              STRH     r2,[r0,#0xc]
00020c  e004              B        |L1.536|
                  |L1.526|
;;;496      }
;;;497      else
;;;498      {
;;;499        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;500        USARTx->CR1 &= CR1_RWU_Reset;
00020e  8982              LDRH     r2,[r0,#0xc]
000210  f64f73fd          MOV      r3,#0xfffd
000214  401a              ANDS     r2,r2,r3
000216  8182              STRH     r2,[r0,#0xc]
                  |L1.536|
;;;501      }
;;;502    }
000218  4770              BX       lr
;;;503    
                          ENDP

                  USART_LINBreakDetectLengthConfig PROC
;;;515      */
;;;516    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
00021a  8a02              LDRH     r2,[r0,#0x10]
;;;517    {
;;;518      /* Check the parameters */
;;;519      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;520      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;521      
;;;522      USARTx->CR2 &= CR2_LBDL_Mask;
00021c  f64f73df          MOV      r3,#0xffdf
000220  401a              ANDS     r2,r2,r3
000222  8202              STRH     r2,[r0,#0x10]
;;;523      USARTx->CR2 |= USART_LINBreakDetectLength;  
000224  8a02              LDRH     r2,[r0,#0x10]
000226  430a              ORRS     r2,r2,r1
000228  8202              STRH     r2,[r0,#0x10]
;;;524    }
00022a  4770              BX       lr
;;;525    
                          ENDP

                  USART_LINCmd PROC
;;;534      */
;;;535    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
00022c  b121              CBZ      r1,|L1.568|
;;;536    {
;;;537      /* Check the parameters */
;;;538      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;539      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;540      
;;;541      if (NewState != DISABLE)
;;;542      {
;;;543        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;544        USARTx->CR2 |= CR2_LINEN_Set;
00022e  8a02              LDRH     r2,[r0,#0x10]
000230  f4424280          ORR      r2,r2,#0x4000
000234  8202              STRH     r2,[r0,#0x10]
000236  e004              B        |L1.578|
                  |L1.568|
;;;545      }
;;;546      else
;;;547      {
;;;548        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;549        USARTx->CR2 &= CR2_LINEN_Reset;
000238  8a02              LDRH     r2,[r0,#0x10]
00023a  f64b73ff          MOV      r3,#0xbfff
00023e  401a              ANDS     r2,r2,r3
000240  8202              STRH     r2,[r0,#0x10]
                  |L1.578|
;;;550      }
;;;551    }
000242  4770              BX       lr
;;;552    
                          ENDP

                  USART_SendData PROC
;;;560      */
;;;561    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000244  f3c10208          UBFX     r2,r1,#0,#9
;;;562    {
;;;563      /* Check the parameters */
;;;564      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;565      assert_param(IS_USART_DATA(Data)); 
;;;566        
;;;567      /* Transmit Data */
;;;568      USARTx->DR = (Data & (uint16_t)0x01FF);
000248  8082              STRH     r2,[r0,#4]
;;;569    }
00024a  4770              BX       lr
;;;570    
                          ENDP

                  USART_ReceiveData PROC
;;;577      */
;;;578    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
00024c  4601              MOV      r1,r0
;;;579    {
;;;580      /* Check the parameters */
;;;581      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;582      
;;;583      /* Receive Data */
;;;584      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
00024e  8888              LDRH     r0,[r1,#4]
000250  f3c00008          UBFX     r0,r0,#0,#9
;;;585    }
000254  4770              BX       lr
;;;586    
                          ENDP

                  USART_SendBreak PROC
;;;593      */
;;;594    void USART_SendBreak(USART_TypeDef* USARTx)
000256  8981              LDRH     r1,[r0,#0xc]
;;;595    {
;;;596      /* Check the parameters */
;;;597      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;598      
;;;599      /* Send break characters */
;;;600      USARTx->CR1 |= CR1_SBK_Set;
000258  f0410101          ORR      r1,r1,#1
00025c  8181              STRH     r1,[r0,#0xc]
;;;601    }
00025e  4770              BX       lr
;;;602    
                          ENDP

                  USART_SetGuardTime PROC
;;;610      */
;;;611    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000260  8b02              LDRH     r2,[r0,#0x18]
;;;612    {    
;;;613      /* Check the parameters */
;;;614      assert_param(IS_USART_123_PERIPH(USARTx));
;;;615      
;;;616      /* Clear the USART Guard time */
;;;617      USARTx->GTPR &= GTPR_LSB_Mask;
000262  b2d2              UXTB     r2,r2
000264  8302              STRH     r2,[r0,#0x18]
;;;618      /* Set the USART guard time */
;;;619      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
000266  8b02              LDRH     r2,[r0,#0x18]
000268  ea422201          ORR      r2,r2,r1,LSL #8
00026c  8302              STRH     r2,[r0,#0x18]
;;;620    }
00026e  4770              BX       lr
;;;621    
                          ENDP

                  USART_SetPrescaler PROC
;;;630      */
;;;631    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000270  8b02              LDRH     r2,[r0,#0x18]
;;;632    { 
;;;633      /* Check the parameters */
;;;634      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;635      
;;;636      /* Clear the USART prescaler */
;;;637      USARTx->GTPR &= GTPR_MSB_Mask;
000272  f402427f          AND      r2,r2,#0xff00
000276  8302              STRH     r2,[r0,#0x18]
;;;638      /* Set the USART prescaler */
;;;639      USARTx->GTPR |= USART_Prescaler;
000278  8b02              LDRH     r2,[r0,#0x18]
00027a  430a              ORRS     r2,r2,r1
00027c  8302              STRH     r2,[r0,#0x18]
;;;640    }
00027e  4770              BX       lr
;;;641    
                          ENDP

                  USART_SmartCardCmd PROC
;;;650      */
;;;651    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000280  b121              CBZ      r1,|L1.652|
;;;652    {
;;;653      /* Check the parameters */
;;;654      assert_param(IS_USART_123_PERIPH(USARTx));
;;;655      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;656      if (NewState != DISABLE)
;;;657      {
;;;658        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;659        USARTx->CR3 |= CR3_SCEN_Set;
000282  8a82              LDRH     r2,[r0,#0x14]
000284  f0420220          ORR      r2,r2,#0x20
000288  8282              STRH     r2,[r0,#0x14]
00028a  e004              B        |L1.662|
                  |L1.652|
;;;660      }
;;;661      else
;;;662      {
;;;663        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;664        USARTx->CR3 &= CR3_SCEN_Reset;
00028c  8a82              LDRH     r2,[r0,#0x14]
00028e  f64f73df          MOV      r3,#0xffdf
000292  401a              ANDS     r2,r2,r3
000294  8282              STRH     r2,[r0,#0x14]
                  |L1.662|
;;;665      }
;;;666    }
000296  4770              BX       lr
;;;667    
                          ENDP

                  USART_SmartCardNACKCmd PROC
;;;676      */
;;;677    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000298  b121              CBZ      r1,|L1.676|
;;;678    {
;;;679      /* Check the parameters */
;;;680      assert_param(IS_USART_123_PERIPH(USARTx));  
;;;681      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;682      if (NewState != DISABLE)
;;;683      {
;;;684        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;685        USARTx->CR3 |= CR3_NACK_Set;
00029a  8a82              LDRH     r2,[r0,#0x14]
00029c  f0420210          ORR      r2,r2,#0x10
0002a0  8282              STRH     r2,[r0,#0x14]
0002a2  e004              B        |L1.686|
                  |L1.676|
;;;686      }
;;;687      else
;;;688      {
;;;689        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;690        USARTx->CR3 &= CR3_NACK_Reset;
0002a4  8a82              LDRH     r2,[r0,#0x14]
0002a6  f64f73ef          MOV      r3,#0xffef
0002aa  401a              ANDS     r2,r2,r3
0002ac  8282              STRH     r2,[r0,#0x14]
                  |L1.686|
;;;691      }
;;;692    }
0002ae  4770              BX       lr
;;;693    
                          ENDP

                  USART_HalfDuplexCmd PROC
;;;702      */
;;;703    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002b0  b121              CBZ      r1,|L1.700|
;;;704    {
;;;705      /* Check the parameters */
;;;706      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;707      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;708      
;;;709      if (NewState != DISABLE)
;;;710      {
;;;711        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;712        USARTx->CR3 |= CR3_HDSEL_Set;
0002b2  8a82              LDRH     r2,[r0,#0x14]
0002b4  f0420208          ORR      r2,r2,#8
0002b8  8282              STRH     r2,[r0,#0x14]
0002ba  e004              B        |L1.710|
                  |L1.700|
;;;713      }
;;;714      else
;;;715      {
;;;716        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;717        USARTx->CR3 &= CR3_HDSEL_Reset;
0002bc  8a82              LDRH     r2,[r0,#0x14]
0002be  f64f73f7          MOV      r3,#0xfff7
0002c2  401a              ANDS     r2,r2,r3
0002c4  8282              STRH     r2,[r0,#0x14]
                  |L1.710|
;;;718      }
;;;719    }
0002c6  4770              BX       lr
;;;720    
                          ENDP

                  USART_IrDAConfig PROC
;;;731      */
;;;732    void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
0002c8  8a82              LDRH     r2,[r0,#0x14]
;;;733    {
;;;734      /* Check the parameters */
;;;735      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;736      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;737        
;;;738      USARTx->CR3 &= CR3_IRLP_Mask;
0002ca  f64f73fb          MOV      r3,#0xfffb
0002ce  401a              ANDS     r2,r2,r3
0002d0  8282              STRH     r2,[r0,#0x14]
;;;739      USARTx->CR3 |= USART_IrDAMode;
0002d2  8a82              LDRH     r2,[r0,#0x14]
0002d4  430a              ORRS     r2,r2,r1
0002d6  8282              STRH     r2,[r0,#0x14]
;;;740    }
0002d8  4770              BX       lr
;;;741    
                          ENDP

                  USART_IrDACmd PROC
;;;750      */
;;;751    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002da  b121              CBZ      r1,|L1.742|
;;;752    {
;;;753      /* Check the parameters */
;;;754      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;755      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;756        
;;;757      if (NewState != DISABLE)
;;;758      {
;;;759        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;760        USARTx->CR3 |= CR3_IREN_Set;
0002dc  8a82              LDRH     r2,[r0,#0x14]
0002de  f0420202          ORR      r2,r2,#2
0002e2  8282              STRH     r2,[r0,#0x14]
0002e4  e004              B        |L1.752|
                  |L1.742|
;;;761      }
;;;762      else
;;;763      {
;;;764        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;765        USARTx->CR3 &= CR3_IREN_Reset;
0002e6  8a82              LDRH     r2,[r0,#0x14]
0002e8  f64f73fd          MOV      r3,#0xfffd
0002ec  401a              ANDS     r2,r2,r3
0002ee  8282              STRH     r2,[r0,#0x14]
                  |L1.752|
;;;766      }
;;;767    }
0002f0  4770              BX       lr
;;;768    
                          ENDP

                  USART_GetFlagStatus PROC
;;;787      */
;;;788    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
0002f2  4602              MOV      r2,r0
;;;789    {
;;;790      FlagStatus bitstatus = RESET;
0002f4  2000              MOVS     r0,#0
;;;791      /* Check the parameters */
;;;792      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;793      assert_param(IS_USART_FLAG(USART_FLAG));
;;;794      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;795      if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
0002f6  8813              LDRH     r3,[r2,#0]
0002f8  420b              TST      r3,r1
0002fa  d001              BEQ      |L1.768|
;;;796      {
;;;797        bitstatus = SET;
0002fc  2001              MOVS     r0,#1
0002fe  e000              B        |L1.770|
                  |L1.768|
;;;798      }
;;;799      else
;;;800      {
;;;801        bitstatus = RESET;
000300  2000              MOVS     r0,#0
                  |L1.770|
;;;802      }
;;;803      return bitstatus;
;;;804    }
000302  4770              BX       lr
;;;805    
                          ENDP

                  USART_ClearFlag PROC
;;;831      */
;;;832    void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000304  43ca              MVNS     r2,r1
;;;833    {
;;;834      /* Check the parameters */
;;;835      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;836      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;837      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;838       
;;;839      USARTx->SR = (uint16_t)~USART_FLAG;
000306  8002              STRH     r2,[r0,#0]
;;;840    }
000308  4770              BX       lr
;;;841    
                          ENDP

                  USART_GetITStatus PROC
;;;860      */
;;;861    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
00030a  b570              PUSH     {r4-r6,lr}
;;;862    {
00030c  4602              MOV      r2,r0
00030e  460b              MOV      r3,r1
;;;863      uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
000310  2400              MOVS     r4,#0
000312  2100              MOVS     r1,#0
000314  2500              MOVS     r5,#0
;;;864      ITStatus bitstatus = RESET;
000316  2000              MOVS     r0,#0
;;;865      /* Check the parameters */
;;;866      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;867      assert_param(IS_USART_GET_IT(USART_IT));
;;;868      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
;;;869      
;;;870      /* Get the USART register index */
;;;871      usartreg = (((uint8_t)USART_IT) >> 0x05);
000318  f3c31542          UBFX     r5,r3,#5,#3
;;;872      /* Get the interrupt position */
;;;873      itmask = USART_IT & IT_Mask;
00031c  f003011f          AND      r1,r3,#0x1f
;;;874      itmask = (uint32_t)0x01 << itmask;
000320  2601              MOVS     r6,#1
000322  fa06f101          LSL      r1,r6,r1
;;;875      
;;;876      if (usartreg == 0x01) /* The IT  is in CR1 register */
000326  2d01              CMP      r5,#1
000328  d102              BNE      |L1.816|
;;;877      {
;;;878        itmask &= USARTx->CR1;
00032a  8996              LDRH     r6,[r2,#0xc]
00032c  4031              ANDS     r1,r1,r6
00032e  e006              B        |L1.830|
                  |L1.816|
;;;879      }
;;;880      else if (usartreg == 0x02) /* The IT  is in CR2 register */
000330  2d02              CMP      r5,#2
000332  d102              BNE      |L1.826|
;;;881      {
;;;882        itmask &= USARTx->CR2;
000334  8a16              LDRH     r6,[r2,#0x10]
000336  4031              ANDS     r1,r1,r6
000338  e001              B        |L1.830|
                  |L1.826|
;;;883      }
;;;884      else /* The IT  is in CR3 register */
;;;885      {
;;;886        itmask &= USARTx->CR3;
00033a  8a96              LDRH     r6,[r2,#0x14]
00033c  4031              ANDS     r1,r1,r6
                  |L1.830|
;;;887      }
;;;888      
;;;889      bitpos = USART_IT >> 0x08;
00033e  121c              ASRS     r4,r3,#8
;;;890      bitpos = (uint32_t)0x01 << bitpos;
000340  2601              MOVS     r6,#1
000342  fa06f404          LSL      r4,r6,r4
;;;891      bitpos &= USARTx->SR;
000346  8816              LDRH     r6,[r2,#0]
000348  4034              ANDS     r4,r4,r6
;;;892      if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
00034a  b111              CBZ      r1,|L1.850|
00034c  b10c              CBZ      r4,|L1.850|
;;;893      {
;;;894        bitstatus = SET;
00034e  2001              MOVS     r0,#1
000350  e000              B        |L1.852|
                  |L1.850|
;;;895      }
;;;896      else
;;;897      {
;;;898        bitstatus = RESET;
000352  2000              MOVS     r0,#0
                  |L1.852|
;;;899      }
;;;900      
;;;901      return bitstatus;  
;;;902    }
000354  bd70              POP      {r4-r6,pc}
;;;903    
                          ENDP

                  USART_ClearITPendingBit PROC
;;;930      */
;;;931    void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000356  b510              PUSH     {r4,lr}
;;;932    {
;;;933      uint16_t bitpos = 0x00, itmask = 0x00;
000358  2200              MOVS     r2,#0
00035a  2300              MOVS     r3,#0
;;;934      /* Check the parameters */
;;;935      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;936      assert_param(IS_USART_CLEAR_IT(USART_IT));
;;;937      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
;;;938      
;;;939      bitpos = USART_IT >> 0x08;
00035c  120a              ASRS     r2,r1,#8
;;;940      itmask = (uint16_t)((uint16_t)0x01 << bitpos);
00035e  2401              MOVS     r4,#1
000360  4094              LSLS     r4,r4,r2
000362  b2a3              UXTH     r3,r4
;;;941      USARTx->SR = (uint16_t)~itmask;
000364  43dc              MVNS     r4,r3
000366  8004              STRH     r4,[r0,#0]
;;;942    }
000368  bd10              POP      {r4,pc}
;;;943    /**
                          ENDP

00036a  0000              DCW      0x0000
                  |L1.876|
                          DCD      0x40004c00
                  |L1.880|
                          DCD      0xbfffbc00
                  |L1.884|
                          DCD      0x40013800
