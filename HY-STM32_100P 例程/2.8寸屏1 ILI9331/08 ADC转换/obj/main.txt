; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\main.o --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\FWlib\inc -I.\user -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\main.crf user\main.c]
                          THUMB

                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;227    *******************************************************************************/
;;;228    void GPIO_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;229    {
;;;230      GPIO_InitTypeDef GPIO_InitStructure;
;;;231    
;;;232      /* Configure PC.04 (ADC Channel14) as analog input -------------------------*/
;;;233      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000002  2002              MOVS     r0,#2
000004  f8ad0000          STRH     r0,[sp,#0]
;;;234      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
000008  2000              MOVS     r0,#0
00000a  f88d0003          STRB     r0,[sp,#3]
;;;235      GPIO_Init(GPIOC, &GPIO_InitStructure);
00000e  4669              MOV      r1,sp
000010  480e              LDR      r0,|L1.76|
000012  f7fffffe          BL       GPIO_Init
;;;236    
;;;237       /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;238      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000016  f44f7000          MOV      r0,#0x200
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;239      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001e  2018              MOVS     r0,#0x18
000020  f88d0003          STRB     r0,[sp,#3]
;;;240      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2003              MOVS     r0,#3
;;;241      GPIO_Init(GPIOA, &GPIO_InitStructure);
000026  4c0a              LDR      r4,|L1.80|
000028  f88d0002          STRB     r0,[sp,#2]            ;240
00002c  4669              MOV      r1,sp
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_Init
;;;242        
;;;243      /* Configure USART1 Rx (PA.10) as input floating */
;;;244      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000034  1520              ASRS     r0,r4,#20
000036  f8ad0000          STRH     r0,[sp,#0]
;;;245      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003a  2004              MOVS     r0,#4
00003c  f88d0003          STRB     r0,[sp,#3]
;;;246      GPIO_Init(GPIOA, &GPIO_InitStructure);
000040  4669              MOV      r1,sp
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       GPIO_Init
;;;247    
;;;248    }
000048  bd38              POP      {r3-r5,pc}
;;;249    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
                          DCD      0x40011000
                  |L1.80|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;256    *******************************************************************************/
;;;257    void NVIC_Configuration(void)
000000  2100              MOVS     r1,#0
;;;258    {
;;;259    #ifdef  VECT_TAB_RAM  
;;;260      /* Set the Vector Table base location at 0x20000000 */ 
;;;261      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;262    #else  /* VECT_TAB_FLASH  */
;;;263      /* Set the Vector Table base location at 0x08000000 */ 
;;;264      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000002  f04f6000          MOV      r0,#0x8000000
000006  f7ffbffe          B.W      NVIC_SetVectorTable
;;;265    #endif
;;;266    }
;;;267    
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;159    *******************************************************************************/
;;;160    void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;161    {
;;;162      /* RCC system reset(for debug purpose) */
;;;163      RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;164    
;;;165      /* Enable HSE */
;;;166      RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3480          MOV      r4,#0x10000
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RCC_HSEConfig
;;;167    
;;;168      /* Wait till HSE is ready */
;;;169      HSEStartUpStatus = RCC_WaitForHSEStartUp();
000010  f7fffffe          BL       RCC_WaitForHSEStartUp
000014  491c              LDR      r1,|L3.136|
;;;170    
;;;171      if(HSEStartUpStatus == SUCCESS)
000016  2801              CMP      r0,#1
000018  7048              STRB     r0,[r1,#1]            ;169
00001a  d125              BNE      |L3.104|
;;;172      {
;;;173        /* HCLK = SYSCLK */
;;;174        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       RCC_HCLKConfig
;;;175      
;;;176        /* PCLK2 = HCLK */
;;;177        RCC_PCLK2Config(RCC_HCLK_Div1); 
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       RCC_PCLK2Config
;;;178    
;;;179        /* PCLK1 = HCLK/2 */
;;;180        RCC_PCLK1Config(RCC_HCLK_Div2);
000028  11a0              ASRS     r0,r4,#6
00002a  f7fffffe          BL       RCC_PCLK1Config
;;;181    
;;;182        /* ADCCLK = PCLK2/4 */
;;;183        RCC_ADCCLKConfig(RCC_PCLK2_Div4); 
00002e  10a0              ASRS     r0,r4,#2
000030  f7fffffe          BL       RCC_ADCCLKConfig
;;;184      
;;;185        /* Flash 2 wait state */
;;;186        FLASH_SetLatency(FLASH_Latency_2);
000034  2002              MOVS     r0,#2
000036  f7fffffe          BL       FLASH_SetLatency
;;;187        /* Enable Prefetch Buffer */
;;;188        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
00003a  2010              MOVS     r0,#0x10
00003c  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;189    
;;;190        /* PLLCLK = 8MHz * 9 = 56 MHz */
;;;191        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
000040  f44f11e0          MOV      r1,#0x1c0000
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       RCC_PLLConfig
;;;192    
;;;193        /* Enable PLL */ 
;;;194        RCC_PLLCmd(ENABLE);
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       RCC_PLLCmd
                  |L3.80|
;;;195    
;;;196        /* Wait till PLL is ready */
;;;197        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000050  2039              MOVS     r0,#0x39
000052  f7fffffe          BL       RCC_GetFlagStatus
000056  2800              CMP      r0,#0
000058  d0fa              BEQ      |L3.80|
;;;198        {
;;;199        }
;;;200    
;;;201        /* Select PLL as system clock source */
;;;202        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00005a  2002              MOVS     r0,#2
00005c  f7fffffe          BL       RCC_SYSCLKConfig
                  |L3.96|
;;;203    
;;;204        /* Wait till PLL is used as system clock source */
;;;205        while(RCC_GetSYSCLKSource() != 0x08)
000060  f7fffffe          BL       RCC_GetSYSCLKSource
000064  2808              CMP      r0,#8
000066  d1fb              BNE      |L3.96|
                  |L3.104|
;;;206        {
;;;207        }
;;;208      }
;;;209    
;;;210    /* Enable peripheral clocks --------------------------------------------------*/
;;;211      /* Enable DMA clock */
;;;212      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000068  2101              MOVS     r1,#1
00006a  4608              MOV      r0,r1
00006c  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;213    
;;;214      /* Enable ADC1 and GPIOC clock */
;;;215      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOC, ENABLE);
000070  2101              MOVS     r1,#1
000072  f44f7004          MOV      r0,#0x210
000076  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;216    
;;;217      /* Enable USART1 and GPIOA clock */
;;;218      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);
00007a  e8bd4010          POP      {r4,lr}
00007e  2101              MOVS     r1,#1
000080  f2440004          MOV      r0,#0x4004
000084  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;219    }
;;;220    
                          ENDP

                  |L3.136|
                          DCD      ||.data||

                          AREA ||i.USART_Configuration1||, CODE, READONLY, ALIGN=2

                  USART_Configuration1 PROC
;;;295    *******************************************************************************/
;;;296    void USART_Configuration1(void)
000000  b530              PUSH     {r4,r5,lr}
;;;297    {
000002  b087              SUB      sp,sp,#0x1c
;;;298      USART_InitTypeDef USART_InitStructure;
;;;299      USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;300    /* USART1 configuration ------------------------------------------------------*/
;;;301      /* USART1 configured as follow:
;;;302            - BaudRate = 115200 baud  
;;;303            - Word Length = 8 Bits
;;;304            - One Stop Bit
;;;305            - No parity
;;;306            - Hardware flow control disabled (RTS and CTS signals)
;;;307            - Receive and transmit enabled
;;;308            - USART Clock disabled
;;;309            - USART CPOL: Clock is active low
;;;310            - USART CPHA: Data is captured on the middle 
;;;311            - USART LastBit: The clock pulse of the last data bit is not output to 
;;;312                             the SCLK pin
;;;313      */
;;;314      USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
000004  2400              MOVS     r4,#0
;;;315    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
;;;316    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000006  f44f7000          MOV      r0,#0x200
00000a  f8ad0014          STRH     r0,[sp,#0x14]
;;;317    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
;;;318    /* Configure the USART1 synchronous paramters */
;;;319    USART_ClockInit(USART1, &USART_ClockInitStructure);
00000e  4d11              LDR      r5,|L4.84|
000010  f8ad4010          STRH     r4,[sp,#0x10]         ;314
000014  f8ad4012          STRH     r4,[sp,#0x12]         ;315
000018  f8ad4016          STRH     r4,[sp,#0x16]         ;317
00001c  a904              ADD      r1,sp,#0x10
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       USART_ClockInit
;;;320    
;;;321    USART_InitStructure.USART_BaudRate = 115200;
000024  f44f30e1          MOV      r0,#0x1c200
;;;322    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000028  9000              STR      r0,[sp,#0]
;;;323    USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;324    USART_InitStructure.USART_Parity = USART_Parity_No ;
00002a  f8ad4008          STRH     r4,[sp,#8]
;;;325    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;326    
;;;327    
;;;328    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00002e  200c              MOVS     r0,#0xc
000030  f8ad4004          STRH     r4,[sp,#4]            ;322
000034  f8ad000a          STRH     r0,[sp,#0xa]
000038  f8ad4006          STRH     r4,[sp,#6]            ;323
00003c  f8ad400c          STRH     r4,[sp,#0xc]          ;325
;;;329    /* Configure USART1 basic and asynchronous paramters */
;;;330    USART_Init(USART1, &USART_InitStructure);
000040  4669              MOV      r1,sp
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       USART_Init
;;;331      /* Enable USART1 */
;;;332      USART_Cmd(USART1, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       USART_Cmd
;;;333    }
000050  b007              ADD      sp,sp,#0x1c
000052  bd30              POP      {r4,r5,pc}
;;;334     
                          ENDP

                  |L4.84|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;342    
;;;343    int fputc(int ch, FILE *f)
000000  b510              PUSH     {r4,lr}
;;;344    {
000002  4604              MOV      r4,r0
;;;345    #ifdef DBG_ITM
;;;346    /* 将Printf内容发往ITM激励寄存器端口  */
;;;347      if (DEMCR & TRCENA) {
;;;348        while (ITM_Port32(0) == 0);
;;;349        ITM_Port8(0) = ch;
;;;350      }
;;;351    #else  
;;;352    /* 将Printf内容发往串口 */
;;;353      USART_SendData(USART1, (unsigned char) ch);
000004  b2c1              UXTB     r1,r0
000006  4805              LDR      r0,|L5.28|
000008  f7fffffe          BL       USART_SendData
;;;354      while (!(USART1->SR & USART_FLAG_TXE));
00000c  4804              LDR      r0,|L5.32|
00000e  bf00              NOP      
                  |L5.16|
000010  f8b01800          LDRH     r1,[r0,#0x800]
000014  0609              LSLS     r1,r1,#24
000016  d5fb              BPL      |L5.16|
;;;355    #endif  
;;;356      return (ch);
000018  4620              MOV      r0,r4
;;;357    }
00001a  bd10              POP      {r4,pc}
;;;358    
                          ENDP

                  |L5.28|
                          DCD      0x40013800
                  |L5.32|
                          DCD      0x40013000

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  main PROC
;;;62     *******************************************************************************/
;;;63     int main(void)
000000  f7fffffe          BL       RCC_Configuration
;;;64     {
;;;65     #ifdef DEBUG
;;;66       debug();
;;;67     #endif
;;;68     
;;;69       /* System clocks configuration ---------------------------------------------*/
;;;70       RCC_Configuration();
;;;71     
;;;72       /* NVIC configuration ------------------------------------------------------*/
;;;73       NVIC_Configuration();
000004  f7fffffe          BL       NVIC_Configuration
;;;74     
;;;75       /* GPIO configuration ------------------------------------------------------*/
;;;76       GPIO_Configuration();
000008  f7fffffe          BL       GPIO_Configuration
;;;77        
;;;78        /* Configure the USART1 */
;;;79       USART_Configuration1();
00000c  f7fffffe          BL       USART_Configuration1
;;;80     
;;;81       printf("\r\n USART1 print AD_value -------------------------- \r\n"); 
000010  a03f              ADR      r0,|L6.272|
000012  f7fffffe          BL       __2printf
;;;82     
;;;83       /* DMA channel1 configuration ----------------------------------------------*/
;;;84       DMA_DeInit(DMA1_Channel1);
000016  4d4c              LDR      r5,|L6.328|
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       DMA_DeInit
;;;85       DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;
00001e  484c              LDR      r0,|L6.336|
000020  494a              LDR      r1,|L6.332|
;;;86       DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADC_ConvertedValue;
;;;87       DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
;;;88       DMA_InitStructure.DMA_BufferSize = 1;
000022  1d02              ADDS     r2,r0,#4
000024  6001              STR      r1,[r0,#0]            ;86  ; DMA_InitStructure
000026  494b              LDR      r1,|L6.340|
000028  2400              MOVS     r4,#0                 ;87
00002a  2701              MOVS     r7,#1
00002c  c292              STM      r2!,{r1,r4,r7}
;;;89       DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
;;;90       DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
;;;91       DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
00002e  15a9              ASRS     r1,r5,#22
000030  6104              STR      r4,[r0,#0x10]  ; DMA_InitStructure
000032  e9c04105          STRD     r4,r1,[r0,#0x14]
;;;92       DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000036  0089              LSLS     r1,r1,#2
;;;93       DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
000038  61c1              STR      r1,[r0,#0x1c]  ; DMA_InitStructure
00003a  2120              MOVS     r1,#0x20
;;;94       DMA_InitStructure.DMA_Priority = DMA_Priority_High;
00003c  6201              STR      r1,[r0,#0x20]  ; DMA_InitStructure
00003e  0209              LSLS     r1,r1,#8
000040  e9c01409          STRD     r1,r4,[r0,#0x24]
;;;95       DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
;;;96       DMA_Init(DMA1_Channel1, &DMA_InitStructure);
000044  4601              MOV      r1,r0
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       DMA_Init
;;;97       
;;;98       /* Enable DMA channel1 */
;;;99       DMA_Cmd(DMA1_Channel1, ENABLE);
00004c  2101              MOVS     r1,#1
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       DMA_Cmd
;;;100         
;;;101      /* ADC1 configuration ------------------------------------------------------*/
;;;102      ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000054  483e              LDR      r0,|L6.336|
;;;103      ADC_InitStructure.ADC_ScanConvMode = ENABLE;
;;;104      ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
;;;105      ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
000056  f44f2160          MOV      r1,#0xe0000
00005a  3814              SUBS     r0,r0,#0x14           ;102
;;;106      ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
;;;107      ADC_InitStructure.ADC_NbrOfChannel = 1;
;;;108      ADC_Init(ADC1, &ADC_InitStructure);
00005c  4e3b              LDR      r6,|L6.332|
00005e  6004              STR      r4,[r0,#0]            ;103  ; ADC_InitStructure
000060  7107              STRB     r7,[r0,#4]            ;103
000062  7147              STRB     r7,[r0,#5]            ;104
000064  e9c01402          STRD     r1,r4,[r0,#8]         ;105
000068  7407              STRB     r7,[r0,#0x10]         ;107
00006a  4601              MOV      r1,r0
00006c  3e4c              SUBS     r6,r6,#0x4c
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       ADC_Init
;;;109    
;;;110      /* Enable ADC1 DMA */
;;;111      ADC_DMACmd(ADC1, ENABLE);
000074  2101              MOVS     r1,#1
000076  4630              MOV      r0,r6
000078  f7fffffe          BL       ADC_DMACmd
;;;112      
;;;113      /* Enable ADC1 */
;;;114      ADC_Cmd(ADC1, ENABLE);
00007c  2101              MOVS     r1,#1
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       ADC_Cmd
;;;115    
;;;116      /* Enable ADC1 reset calibaration register */   
;;;117      ADC_ResetCalibration(ADC1);
000084  4630              MOV      r0,r6
000086  f7fffffe          BL       ADC_ResetCalibration
                  |L6.138|
;;;118      /* Check the end of ADC1 reset calibration register */
;;;119      while(ADC_GetResetCalibrationStatus(ADC1));
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       ADC_GetResetCalibrationStatus
000090  2800              CMP      r0,#0
000092  d1fa              BNE      |L6.138|
;;;120    
;;;121      /* Start ADC1 calibaration */
;;;122      ADC_StartCalibration(ADC1);
000094  4630              MOV      r0,r6
000096  f7fffffe          BL       ADC_StartCalibration
                  |L6.154|
;;;123    
;;;124      /* Check the end of ADC1 calibration */
;;;125      while(ADC_GetCalibrationStatus(ADC1));
00009a  4630              MOV      r0,r6
00009c  f7fffffe          BL       ADC_GetCalibrationStatus
0000a0  2800              CMP      r0,#0
0000a2  d1fa              BNE      |L6.154|
;;;126         
;;;127      /* Start ADC1 Software Conversion */ 
;;;128      ADC_SoftwareStartConvCmd(ADC1, ENABLE);
0000a4  2101              MOVS     r1,#1
0000a6  4630              MOV      r0,r6
0000a8  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;129    
;;;130     while(1)
;;;131      {
;;;132       for(Y=0;Y<5;Y++);
0000ac  4d29              LDR      r5,|L6.340|
0000ae  1ead              SUBS     r5,r5,#2
                  |L6.176|
0000b0  4620              MOV      r0,r4
0000b2  612c              STR      r4,[r5,#0x10]  ; Y
                  |L6.180|
0000b4  1c40              ADDS     r0,r0,#1
0000b6  2805              CMP      r0,#5
0000b8  d3fc              BCC      |L6.180|
;;;133       if (ticks++ >= 900000) {                  /* Set Clock1s to 1 every 1 second    */
0000ba  6128              STR      r0,[r5,#0x10]  ; Y
0000bc  68e8              LDR      r0,[r5,#0xc]  ; ticks
0000be  1c41              ADDS     r1,r0,#1
0000c0  60e9              STR      r1,[r5,#0xc]  ; ticks
0000c2  4925              LDR      r1,|L6.344|
0000c4  4288              CMP      r0,r1
0000c6  d302              BCC      |L6.206|
;;;134        ticks   = 0;
;;;135        Clock1s = 1;
0000c8  60ec              STR      r4,[r5,#0xc]  ; ticks
0000ca  702f              STRB     r7,[r5,#0]
0000cc  e002              B        |L6.212|
                  |L6.206|
;;;136      }
;;;137       /* Printf message with AD value to serial port every 1 second             */
;;;138        if (Clock1s) {
0000ce  7828              LDRB     r0,[r5,#0]  ; Clock1s
0000d0  2800              CMP      r0,#0
0000d2  d0ed              BEQ      |L6.176|
                  |L6.212|
;;;139          Clock1s = 0;
0000d4  702c              STRB     r4,[r5,#0]
;;;140          ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 1, ADC_SampleTime_55Cycles5);
0000d6  2305              MOVS     r3,#5
0000d8  2201              MOVS     r2,#1
0000da  210b              MOVS     r1,#0xb
0000dc  4630              MOV      r0,r6
0000de  f7fffffe          BL       ADC_RegularChannelConfig
;;;141    	  AD_value=ADC_GetConversionValue(ADC1);
0000e2  4630              MOV      r0,r6
0000e4  f7fffffe          BL       ADC_GetConversionValue
0000e8  4601              MOV      r1,r0
;;;142    	  printf("The current AD2 value = 0x%04X \r\n", AD_value);
0000ea  6068              STR      r0,[r5,#4]  ; AD_value
0000ec  a01b              ADR      r0,|L6.348|
0000ee  f7fffffe          BL       __2printf
;;;143    
;;;144          ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_55Cycles5);
0000f2  2305              MOVS     r3,#5
0000f4  2201              MOVS     r2,#1
0000f6  210a              MOVS     r1,#0xa
0000f8  4630              MOV      r0,r6
0000fa  f7fffffe          BL       ADC_RegularChannelConfig
;;;145    	  AD1_value=ADC_GetConversionValue(ADC1);
0000fe  4630              MOV      r0,r6
000100  f7fffffe          BL       ADC_GetConversionValue
000104  4601              MOV      r1,r0
;;;146          printf("The current AD1 value = 0x%04X \r\n", AD1_value);
000106  60a8              STR      r0,[r5,#8]  ; AD1_value
000108  a01d              ADR      r0,|L6.384|
00010a  f7fffffe          BL       __2printf
00010e  e7cf              B        |L6.176|
;;;147    
;;;148        }
;;;149      
;;;150      }
;;;151    }
;;;152    
                          ENDP

                  |L6.272|
000110  0d0a2055          DCB      "\r\n USART1 print AD_value -------------------------- \r"
000114  53415254
000118  31207072
00011c  696e7420
000120  41445f76
000124  616c7565
000128  202d2d2d
00012c  2d2d2d2d
000130  2d2d2d2d
000134  2d2d2d2d
000138  2d2d2d2d
00013c  2d2d2d2d
000140  2d2d2d20
000144  0d      
000145  0a00              DCB      "\n",0
000147  00                DCB      0
                  |L6.328|
                          DCD      0x40020008
                  |L6.332|
                          DCD      0x4001244c
                  |L6.336|
                          DCD      ||.bss||+0x14
                  |L6.340|
                          DCD      ||.data||+0x2
                  |L6.344|
                          DCD      0x000dbba0
                  |L6.348|
00015c  54686520          DCB      "The current AD2 value = 0x%04X \r\n",0
000160  63757272
000164  656e7420
000168  41443220
00016c  76616c75
000170  65203d20
000174  30782530
000178  3458200d
00017c  0a00    
00017e  00                DCB      0
00017f  00                DCB      0
                  |L6.384|
000180  54686520          DCB      "The current AD1 value = 0x%04X \r\n",0
000184  63757272
000188  656e7420
00018c  41443120
000190  76616c75
000194  65203d20
000198  30782530
00019c  3458200d
0001a0  0a00    
0001a2  00                DCB      0
0001a3  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ADC_InitStructure
                          %        20
                  DMA_InitStructure
                          %        44

                          AREA ||.data||, DATA, ALIGN=2

                  Clock1s
000000  00                DCB      0x00
                  HSEStartUpStatus
000001  00                DCB      0x00
                  ADC_ConvertedValue
000002  0000              DCB      0x00,0x00
                  AD_value
                          DCD      0x00000000
                  AD1_value
                          DCD      0x00000000
                  ticks
                          DCD      0x00000000
                  Y
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
