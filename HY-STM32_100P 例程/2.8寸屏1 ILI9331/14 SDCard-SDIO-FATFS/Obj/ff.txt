; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\ff.o --depend=.\Obj\ff.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\FWlib\inc -I.\user -I.\fatfs -I.\fatfs -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\Obj\ff.crf fatfs\ff.c]
                          THUMB

                          AREA ||i.auto_mount||, CODE, READONLY, ALIGN=2

                  auto_mount PROC
;;;1446   static
;;;1447   FRESULT auto_mount (	/* FR_OK(0): successful, !=0: any error occured */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1448   	const XCHAR **path,	/* Pointer to pointer to the path name (drive number) */
;;;1449   	FATFS **rfs,		/* Pointer to pointer to the found file system object */
;;;1450   	BYTE chk_wp			/* !=0: Check media write protection for write access */
;;;1451   )
;;;1452   {
000004  460e              MOV      r6,r1
;;;1453   	FRESULT res;
;;;1454   	BYTE fmt, *tbl;
;;;1455   	UINT vol;
;;;1456   	DSTATUS stat;
;;;1457   	DWORD bsect, fsize, tsect, mclst;
;;;1458   	const XCHAR *p = *path;
;;;1459   	FATFS *fs;
;;;1460   
;;;1461   
;;;1462   	/* Get logical drive number from the path name */
;;;1463   	vol = p[0] - '0';				/* Is there a drive number? */
000006  6801              LDR      r1,[r0,#0]
000008  4615              MOV      r5,r2                 ;1452
00000a  780b              LDRB     r3,[r1,#0]
00000c  3b30              SUBS     r3,r3,#0x30
;;;1464   	if (vol <= 9 && p[1] == ':') {	/* Found a drive number, get and strip it */
00000e  2b09              CMP      r3,#9
000010  d808              BHI      |L1.36|
000012  784a              LDRB     r2,[r1,#1]
000014  2a3a              CMP      r2,#0x3a
000016  d105              BNE      |L1.36|
;;;1465   		p += 2; *path = p;			/* Return pointer to the path name */
000018  1c89              ADDS     r1,r1,#2
;;;1466   	} else {						/* No drive number is given */
;;;1467   #if _FS_RPATH
;;;1468   		vol = Drive;				/* Use current drive */
;;;1469   #else
;;;1470   		vol = 0;					/* Use drive 0 */
;;;1471   #endif
;;;1472   	}
;;;1473   
;;;1474   	/* Check if the logical drive is valid or not */
;;;1475   	if (vol >= _DRIVES) 			/* Is the drive number valid? */
00001a  6001              STR      r1,[r0,#0]
00001c  b113              CBZ      r3,|L1.36|
;;;1476   		return FR_INVALID_DRIVE;
00001e  200b              MOVS     r0,#0xb
                  |L1.32|
;;;1477   	*rfs = fs = FatFs[vol];			/* Returen pointer to the corresponding file system object */
;;;1478   	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object registered? */
;;;1479   
;;;1480   	ENTER_FF(fs);					/* Lock file system */
;;;1481   
;;;1482   	if (fs->fs_type) {				/* If the logical drive has been mounted */
;;;1483   		stat = disk_status(fs->drive);
;;;1484   		if (!(stat & STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed), */
;;;1485   #if !_FS_READONLY
;;;1486   			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
;;;1487   				return FR_WRITE_PROTECTED;
;;;1488   #endif
;;;1489   			return FR_OK;			/* The file system object is valid */
;;;1490   		}
;;;1491   	}
;;;1492   
;;;1493   	/* The logical drive must be mounted. Following code attempts to mount the volume */
;;;1494   
;;;1495   	fs->fs_type = 0;					/* Clear the file system object */
;;;1496   	fs->drive = (BYTE)LD2PD(vol);		/* Bind the logical drive and a physical drive */
;;;1497   	stat = disk_initialize(fs->drive);	/* Initialize low level disk I/O layer */
;;;1498   	if (stat & STA_NOINIT)				/* Check if the drive is ready */
;;;1499   		return FR_NOT_READY;
;;;1500   #if _MAX_SS != 512						/* Get disk sector size if needed */
;;;1501   	if (disk_ioctl(fs->drive, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
;;;1502   		return FR_NO_FILESYSTEM;
;;;1503   #endif
;;;1504   #if !_FS_READONLY
;;;1505   	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
;;;1506   		return FR_WRITE_PROTECTED;
;;;1507   #endif
;;;1508   	/* Search FAT partition on the drive */
;;;1509   	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 as an SFD format */
;;;1510   	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
;;;1511   		/* Check a partition listed in top of the partition table */
;;;1512   		tbl = &fs->win[MBR_Table + LD2PT(vol) * 16];	/* Partition table */
;;;1513   		if (tbl[4]) {									/* Is the partition existing? */
;;;1514   			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
;;;1515   			fmt = check_fs(fs, bsect);					/* Check the partition */
;;;1516   		}
;;;1517   	}
;;;1518   	if (fmt == 3) return FR_DISK_ERR;
;;;1519   	if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT patition is found */
;;;1520   		return FR_NO_FILESYSTEM;
;;;1521   
;;;1522   	/* Initialize the file system object */
;;;1523   	fsize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
;;;1524   	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
;;;1525   	fs->sects_fat = fsize;
;;;1526   	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
;;;1527   	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
;;;1528   	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
;;;1529   	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
;;;1530   	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Nmuber of root directory entries */
;;;1531   	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the file system */
;;;1532   	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
;;;1533   	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 */
;;;1534   		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
;;;1535   		) / fs->csize + 2;
;;;1536   
;;;1537   	fmt = FS_FAT12;										/* Determine the FAT sub type */
;;;1538   	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
;;;1539   	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
;;;1540   
;;;1541   	if (fmt == FS_FAT32)
;;;1542   		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
;;;1543   	else
;;;1544   		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
;;;1545   	fs->database = fs->fatbase + fsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
;;;1546   
;;;1547   #if !_FS_READONLY
;;;1548   	/* Initialize allocation information */
;;;1549   	fs->free_clust = 0xFFFFFFFF;
;;;1550   	fs->wflag = 0;
;;;1551   	/* Get fsinfo if needed */
;;;1552   	if (fmt == FS_FAT32) {
;;;1553   	 	fs->fsi_flag = 0;
;;;1554   		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
;;;1555   		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
;;;1556   			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
;;;1557   			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
;;;1558   			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
;;;1559   			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
;;;1560   			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
;;;1561   		}
;;;1562   	}
;;;1563   #endif
;;;1564   	fs->fs_type = fmt;		/* FAT sub-type */
;;;1565   	fs->winsect = 0;		/* Invalidate sector cache */
;;;1566   #if _FS_RPATH
;;;1567   	fs->cdir = 0;			/* Current directory (root dir) */
;;;1568   #endif
;;;1569   	fs->id = ++Fsid;		/* File system mount ID */
;;;1570   	res = FR_OK;
;;;1571   
;;;1572   	return res;
;;;1573   }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L1.36|
000024  4868              LDR      r0,|L1.456|
000026  6804              LDR      r4,[r0,#0]            ;1477
000028  6034              STR      r4,[r6,#0]            ;1478
00002a  b19c              CBZ      r4,|L1.84|
00002c  7820              LDRB     r0,[r4,#0]            ;1482
00002e  b120              CBZ      r0,|L1.58|
000030  7860              LDRB     r0,[r4,#1]            ;1483
000032  f7fffffe          BL       disk_status
000036  07c1              LSLS     r1,r0,#31             ;1484
000038  d00e              BEQ      |L1.88|
                  |L1.58|
00003a  f04f0800          MOV      r8,#0                 ;1495
00003e  f8848000          STRB     r8,[r4,#0]            ;1495
000042  4640              MOV      r0,r8                 ;1495
000044  f8848001          STRB     r8,[r4,#1]            ;1496
000048  f7fffffe          BL       disk_initialize
00004c  07c1              LSLS     r1,r0,#31             ;1498
00004e  d008              BEQ      |L1.98|
000050  2003              MOVS     r0,#3                 ;1499
000052  e7e5              B        |L1.32|
                  |L1.84|
000054  200c              MOVS     r0,#0xc               ;1478
000056  e7e3              B        |L1.32|
                  |L1.88|
000058  b10d              CBZ      r5,|L1.94|
00005a  0740              LSLS     r0,r0,#29             ;1486
00005c  d404              BMI      |L1.104|
                  |L1.94|
00005e  2000              MOVS     r0,#0                 ;1489
000060  e7de              B        |L1.32|
                  |L1.98|
000062  b11d              CBZ      r5,|L1.108|
000064  0740              LSLS     r0,r0,#29             ;1505
000066  d501              BPL      |L1.108|
                  |L1.104|
000068  200a              MOVS     r0,#0xa               ;1506
00006a  e7d9              B        |L1.32|
                  |L1.108|
00006c  2100              MOVS     r1,#0                 ;1509
00006e  460e              MOV      r6,r1                 ;1509
000070  4620              MOV      r0,r4                 ;1509
000072  f7fffffe          BL       check_fs
000076  2801              CMP      r0,#1                 ;1510
000078  d10c              BNE      |L1.148|
00007a  f50470f7          ADD      r0,r4,#0x1ee          ;1512
00007e  7901              LDRB     r1,[r0,#4]            ;1513
000080  b199              CBZ      r1,|L1.170|
000082  7a01              LDRB     r1,[r0,#8]            ;1514
000084  f8d00009          LDR      r0,[r0,#9]            ;1514
000088  ea412600          ORR      r6,r1,r0,LSL #8       ;1514
00008c  4631              MOV      r1,r6                 ;1515
00008e  4620              MOV      r0,r4                 ;1515
000090  f7fffffe          BL       check_fs
                  |L1.148|
000094  2803              CMP      r0,#3                 ;1518
000096  d001              BEQ      |L1.156|
000098  b938              CBNZ     r0,|L1.170|
00009a  e001              B        |L1.160|
                  |L1.156|
00009c  2001              MOVS     r0,#1                 ;1518
00009e  e7bf              B        |L1.32|
                  |L1.160|
0000a0  f8b4003b          LDRH     r0,[r4,#0x3b]         ;1519
0000a4  f5b07f00          CMP      r0,#0x200             ;1519
0000a8  d001              BEQ      |L1.174|
                  |L1.170|
0000aa  200d              MOVS     r0,#0xd               ;1520
0000ac  e7b8              B        |L1.32|
                  |L1.174|
0000ae  f8b41046          LDRH     r1,[r4,#0x46]         ;1523
0000b2  b929              CBNZ     r1,|L1.192|
0000b4  f8940054          LDRB     r0,[r4,#0x54]         ;1524
0000b8  f8d41055          LDR      r1,[r4,#0x55]         ;1524
0000bc  ea402101          ORR      r1,r0,r1,LSL #8       ;1524
                  |L1.192|
0000c0  61a1              STR      r1,[r4,#0x18]         ;1526
0000c2  f8942040          LDRB     r2,[r4,#0x40]         ;1526
0000c6  70e2              STRB     r2,[r4,#3]            ;1526
0000c8  f8b4c03e          LDRH     r12,[r4,#0x3e]        ;1528
0000cc  fb02f001          MUL      r0,r2,r1              ;1527
0000d0  eb0c0106          ADD      r1,r12,r6             ;1528
0000d4  6221              STR      r1,[r4,#0x20]         ;1529
0000d6  f894303d          LDRB     r3,[r4,#0x3d]         ;1529
0000da  70a3              STRB     r3,[r4,#2]            ;1529
0000dc  f8b42041          LDRH     r2,[r4,#0x41]         ;1530
0000e0  8122              STRH     r2,[r4,#8]            ;1530
0000e2  f8b45043          LDRH     r5,[r4,#0x43]         ;1531
0000e6  b92d              CBNZ     r5,|L1.244|
0000e8  f8945050          LDRB     r5,[r4,#0x50]         ;1532
0000ec  f8d47051          LDR      r7,[r4,#0x51]         ;1532
0000f0  ea452507          ORR      r5,r5,r7,LSL #8       ;1532
                  |L1.244|
0000f4  eba5050c          SUB      r5,r5,r12             ;1533
0000f8  1a2d              SUBS     r5,r5,r0              ;1533
0000fa  eba51512          SUB      r5,r5,r2,LSR #4       ;1533
0000fe  fbb5f3f3          UDIV     r3,r5,r3              ;1533
000102  1c9b              ADDS     r3,r3,#2              ;1533
000104  2501              MOVS     r5,#1                 ;1537
000106  f64077f7          MOV      r7,#0xff7             ;1538
00010a  61e3              STR      r3,[r4,#0x1c]         ;1538
00010c  42bb              CMP      r3,r7                 ;1538
00010e  d300              BCC      |L1.274|
000110  2502              MOVS     r5,#2                 ;1538
                  |L1.274|
000112  f64f77f7          MOV      r7,#0xfff7            ;1539
000116  42bb              CMP      r3,r7                 ;1539
000118  d301              BCC      |L1.286|
00011a  2503              MOVS     r5,#3                 ;1539
00011c  e010              B        |L1.320|
                  |L1.286|
00011e  2d03              CMP      r5,#3                 ;1541
000120  d00e              BEQ      |L1.320|
000122  180b              ADDS     r3,r1,r0              ;1544
                  |L1.292|
000124  eb001012          ADD      r0,r0,r2,LSR #4       ;1545
000128  4408              ADD      r0,r0,r1              ;1545
00012a  e9c43009          STRD     r3,r0,[r4,#0x24]      ;1549
00012e  f04f30ff          MOV      r0,#0xffffffff        ;1549
000132  6120              STR      r0,[r4,#0x10]         ;1550
000134  4647              MOV      r7,r8                 ;1550
000136  f8848004          STRB     r8,[r4,#4]            ;1550
00013a  2d03              CMP      r5,#3                 ;1552
00013c  d007              BEQ      |L1.334|
00013e  e038              B        |L1.434|
                  |L1.320|
000140  f894305c          LDRB     r3,[r4,#0x5c]         ;1542
000144  f8d4705d          LDR      r7,[r4,#0x5d]         ;1542
000148  ea432307          ORR      r3,r3,r7,LSL #8       ;1542
00014c  e7ea              B        |L1.292|
                  |L1.334|
00014e  72a7              STRB     r7,[r4,#0xa]          ;1553
000150  f8b40060          LDRH     r0,[r4,#0x60]         ;1554
000154  2301              MOVS     r3,#1                 ;1555
000156  1982              ADDS     r2,r0,r6              ;1554
000158  6162              STR      r2,[r4,#0x14]         ;1555
00015a  7860              LDRB     r0,[r4,#1]            ;1555
00015c  f1040130          ADD      r1,r4,#0x30           ;1555
000160  f7fffffe          BL       disk_read
000164  bb28              CBNZ     r0,|L1.434|
000166  f8b4022e          LDRH     r0,[r4,#0x22e]        ;1556
00016a  f5a0412a          SUB      r1,r0,#0xaa00         ;1556
00016e  3955              SUBS     r1,r1,#0x55           ;1556
000170  d11f              BNE      |L1.434|
000172  f8940030          LDRB     r0,[r4,#0x30]         ;1557
000176  f8d42031          LDR      r2,[r4,#0x31]         ;1557
00017a  4914              LDR      r1,|L1.460|
00017c  ea402002          ORR      r0,r0,r2,LSL #8       ;1557
000180  4288              CMP      r0,r1                 ;1557
000182  d116              BNE      |L1.434|
000184  f8940214          LDRB     r0,[r4,#0x214]        ;1558
000188  f8d42215          LDR      r2,[r4,#0x215]        ;1558
00018c  4910              LDR      r1,|L1.464|
00018e  ea402002          ORR      r0,r0,r2,LSL #8       ;1558
000192  4288              CMP      r0,r1                 ;1558
000194  d10d              BNE      |L1.434|
000196  f894021c          LDRB     r0,[r4,#0x21c]        ;1559
00019a  f8d4121d          LDR      r1,[r4,#0x21d]        ;1559
00019e  ea402001          ORR      r0,r0,r1,LSL #8       ;1559
0001a2  60e0              STR      r0,[r4,#0xc]          ;1560
0001a4  f8940218          LDRB     r0,[r4,#0x218]        ;1560
0001a8  f8d41219          LDR      r1,[r4,#0x219]        ;1560
0001ac  ea402001          ORR      r0,r0,r1,LSL #8       ;1560
0001b0  6120              STR      r0,[r4,#0x10]         ;1560
                  |L1.434|
0001b2  4a05              LDR      r2,|L1.456|
0001b4  7025              STRB     r5,[r4,#0]            ;1564
0001b6  1f12              SUBS     r2,r2,#4              ;1569
0001b8  62e7              STR      r7,[r4,#0x2c]         ;1569
0001ba  8811              LDRH     r1,[r2,#0]            ;1569  ; Fsid
0001bc  4638              MOV      r0,r7                 ;1565
0001be  1c49              ADDS     r1,r1,#1              ;1569
0001c0  8011              STRH     r1,[r2,#0]            ;1569
0001c2  80e1              STRH     r1,[r4,#6]            ;1569
0001c4  e72c              B        |L1.32|
;;;1574   
                          ENDP

0001c6  0000              DCW      0x0000
                  |L1.456|
                          DCD      ||.data||+0x4
                  |L1.460|
                          DCD      0x41615252
                  |L1.464|
                          DCD      0x61417272

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;1417   static
;;;1418   BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
000000  b510              PUSH     {r4,lr}
;;;1419   	FATFS *fs,	/* File system object */
;;;1420   	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
;;;1421   )
;;;1422   {
000002  4604              MOV      r4,r0
;;;1423   	static const char fatstr[] = "FAT";
;;;1424   
;;;1425   
;;;1426   	if (disk_read(fs->drive, fs->win, sect, 1) != RES_OK)	/* Load boot record */
000004  460a              MOV      r2,r1
000006  7840              LDRB     r0,[r0,#1]
000008  2301              MOVS     r3,#1
00000a  f1040130          ADD      r1,r4,#0x30
00000e  f7fffffe          BL       disk_read
000012  b108              CBZ      r0,|L2.24|
;;;1427   		return 3;
000014  2003              MOVS     r0,#3
;;;1428   	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
;;;1429   		return 2;
;;;1430   
;;;1431   	if (!mem_cmp(&fs->win[BS_FilSysType], fatstr, 3))	/* Check FAT signature */
;;;1432   		return 0;
;;;1433   	if (!mem_cmp(&fs->win[BS_FilSysType32], fatstr, 3) && !(fs->win[BPB_ExtFlags] & 0x80))
;;;1434   		return 0;
;;;1435   
;;;1436   	return 1;
;;;1437   }
000016  bd10              POP      {r4,pc}
                  |L2.24|
000018  f8b4022e          LDRH     r0,[r4,#0x22e]        ;1428
00001c  f5a0412a          SUB      r1,r0,#0xaa00         ;1428
000020  3955              SUBS     r1,r1,#0x55           ;1428
000022  d001              BEQ      |L2.40|
000024  2002              MOVS     r0,#2                 ;1429
                  |L2.38|
000026  bd10              POP      {r4,pc}
                  |L2.40|
000028  2203              MOVS     r2,#3                 ;1431
00002a  490b              LDR      r1,|L2.88|
00002c  f1040066          ADD      r0,r4,#0x66           ;1431
000030  f7fffffe          BL       mem_cmp
000034  2800              CMP      r0,#0                 ;1431
000036  d0f6              BEQ      |L2.38|
000038  2203              MOVS     r2,#3                 ;1433
00003a  4907              LDR      r1,|L2.88|
00003c  f1040082          ADD      r0,r4,#0x82           ;1433
000040  f7fffffe          BL       mem_cmp
000044  b928              CBNZ     r0,|L2.82|
000046  f8940058          LDRB     r0,[r4,#0x58]         ;1433
00004a  0600              LSLS     r0,r0,#24             ;1433
00004c  d401              BMI      |L2.82|
00004e  2000              MOVS     r0,#0                 ;1434
000050  bd10              POP      {r4,pc}
                  |L2.82|
000052  2001              MOVS     r0,#1                 ;1436
000054  bd10              POP      {r4,pc}
;;;1438   
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      ||.constdata||

                          AREA ||i.clust2sect||, CODE, READONLY, ALIGN=1

                  clust2sect PROC
;;;512    static
;;;513    DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
000000  69c2              LDR      r2,[r0,#0x1c]
;;;514    	FATFS *fs,		/* File system object */
;;;515    	DWORD clst		/* Cluster# to be converted */
;;;516    )
;;;517    {
;;;518    	clst -= 2;
000002  1e89              SUBS     r1,r1,#2
;;;519    	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
000004  1e92              SUBS     r2,r2,#2
000006  428a              CMP      r2,r1
000008  d801              BHI      |L3.14|
00000a  2000              MOVS     r0,#0
;;;520    	return clst * fs->csize + fs->database;
;;;521    }
00000c  4770              BX       lr
                  |L3.14|
00000e  6a82              LDR      r2,[r0,#0x28]         ;520
000010  7880              LDRB     r0,[r0,#2]            ;520
000012  fb012000          MLA      r0,r1,r0,r2           ;520
000016  4770              BX       lr
;;;522    
                          ENDP


                          AREA ||i.create_chain||, CODE, READONLY, ALIGN=1

                  create_chain PROC
;;;453    static
;;;454    DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;455    	FATFS *fs,			/* File system object */
;;;456    	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
;;;457    )
;;;458    {
;;;459    	DWORD cs, ncl, scl, mcl;
;;;460    
;;;461    
;;;462    	mcl = fs->max_clust;
;;;463    	if (clst == 0) {		/* Create new chain */
000004  69c7              LDR      r7,[r0,#0x1c]
000006  4606              MOV      r6,r0                 ;458
000008  ea5f0801          MOVS     r8,r1                 ;458
00000c  d008              BEQ      |L4.32|
;;;464    		scl = fs->last_clust;			/* Get suggested start point */
;;;465    		if (scl == 0 || scl >= mcl) scl = 1;
;;;466    	}
;;;467    	else {					/* Stretch existing chain */
;;;468    		cs = get_fat(fs, clst);			/* Check the cluster status */
00000e  4641              MOV      r1,r8
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       get_fat
;;;469    		if (cs < 2) return 1;			/* It is an invalid cluster */
000016  2802              CMP      r0,#2
000018  d208              BCS      |L4.44|
00001a  2001              MOVS     r0,#1
                  |L4.28|
;;;470    		if (cs < mcl) return cs;		/* It is already followed by next cluster */
;;;471    		scl = clst;
;;;472    	}
;;;473    
;;;474    	ncl = scl;				/* Start cluster */
;;;475    	for (;;) {
;;;476    		ncl++;							/* Next cluster */
;;;477    		if (ncl >= mcl) {				/* Wrap around */
;;;478    			ncl = 2;
;;;479    			if (ncl > scl) return 0;	/* No free custer */
;;;480    		}
;;;481    		cs = get_fat(fs, ncl);			/* Get the cluster status */
;;;482    		if (cs == 0) break;				/* Found a free cluster */
;;;483    		if (cs == 0xFFFFFFFF || cs == 1)/* An error occured */
;;;484    			return cs;
;;;485    		if (ncl == scl) return 0;		/* No free custer */
;;;486    	}
;;;487    
;;;488    	if (put_fat(fs, ncl, 0x0FFFFFFF))	/* Mark the new cluster "in use" */
;;;489    		return 0xFFFFFFFF;
;;;490    	if (clst != 0) {					/* Link it to the previous one if needed */
;;;491    		if (put_fat(fs, clst, ncl))
;;;492    			return 0xFFFFFFFF;
;;;493    	}
;;;494    
;;;495    	fs->last_clust = ncl;				/* Update FSINFO */
;;;496    	if (fs->free_clust != 0xFFFFFFFF) {
;;;497    		fs->free_clust--;
;;;498    		fs->fsi_flag = 1;
;;;499    	}
;;;500    
;;;501    	return ncl;		/* Return new cluster number */
;;;502    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L4.32|
000020  68f5              LDR      r5,[r6,#0xc]          ;465
000022  b10d              CBZ      r5,|L4.40|
000024  42bd              CMP      r5,r7                 ;465
000026  d304              BCC      |L4.50|
                  |L4.40|
000028  2501              MOVS     r5,#1                 ;465
00002a  e002              B        |L4.50|
                  |L4.44|
00002c  42b8              CMP      r0,r7                 ;470
00002e  d3f5              BCC      |L4.28|
000030  4645              MOV      r5,r8                 ;471
                  |L4.50|
000032  462c              MOV      r4,r5                 ;474
                  |L4.52|
000034  1c64              ADDS     r4,r4,#1              ;476
000036  42bc              CMP      r4,r7                 ;477
000038  d302              BCC      |L4.64|
00003a  2402              MOVS     r4,#2                 ;478
00003c  2d02              CMP      r5,#2                 ;479
00003e  d30a              BCC      |L4.86|
                  |L4.64|
000040  4621              MOV      r1,r4                 ;481
000042  4630              MOV      r0,r6                 ;481
000044  f7fffffe          BL       get_fat
000048  b138              CBZ      r0,|L4.90|
00004a  1c41              ADDS     r1,r0,#1              ;483
00004c  d0e6              BEQ      |L4.28|
00004e  2801              CMP      r0,#1                 ;483
000050  d0e4              BEQ      |L4.28|
000052  42ac              CMP      r4,r5                 ;485
000054  d1ee              BNE      |L4.52|
                  |L4.86|
000056  2000              MOVS     r0,#0                 ;485
000058  e7e0              B        |L4.28|
                  |L4.90|
00005a  f06f4270          MVN      r2,#0xf0000000        ;488
00005e  4621              MOV      r1,r4                 ;488
000060  4630              MOV      r0,r6                 ;488
000062  f7fffffe          BL       put_fat
000066  f04f35ff          MOV      r5,#0xffffffff        ;483
00006a  b940              CBNZ     r0,|L4.126|
00006c  ea5f0008          MOVS     r0,r8                 ;490
000070  d007              BEQ      |L4.130|
000072  4601              MOV      r1,r0                 ;491
000074  4622              MOV      r2,r4                 ;491
000076  4630              MOV      r0,r6                 ;491
000078  f7fffffe          BL       put_fat
00007c  b108              CBZ      r0,|L4.130|
                  |L4.126|
00007e  4628              MOV      r0,r5                 ;492
000080  e7cc              B        |L4.28|
                  |L4.130|
000082  60f4              STR      r4,[r6,#0xc]          ;496
000084  6930              LDR      r0,[r6,#0x10]         ;496
000086  1c41              ADDS     r1,r0,#1              ;496
000088  d003              BEQ      |L4.146|
00008a  1e40              SUBS     r0,r0,#1              ;497
00008c  6130              STR      r0,[r6,#0x10]         ;498
00008e  2001              MOVS     r0,#1                 ;498
000090  72b0              STRB     r0,[r6,#0xa]          ;498
                  |L4.146|
000092  4620              MOV      r0,r4                 ;501
000094  e7c2              B        |L4.28|
;;;503    #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;1077   static
;;;1078   FRESULT create_name (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1079   	DIR *dj,			/* Pointer to the directory object */
;;;1080   	const XCHAR **path	/* Pointer to pointer to the segment in the path string */
;;;1081   )
;;;1082   {
;;;1083   #ifdef _EXCVT
;;;1084   	static const BYTE cvt[] = _EXCVT;
;;;1085   #endif
;;;1086   #if _USE_LFN	/* LFN configuration */
;;;1087   	BYTE b, cf;
;;;1088   	WCHAR w, *lfn;
;;;1089   	int i, ni, si, di;
;;;1090   	const XCHAR *p;
;;;1091   
;;;1092   	/* Create LFN in Unicode */
;;;1093   	si = di = 0;
;;;1094   	p = *path;
;;;1095   	lfn = dj->lfn;
;;;1096   	for (;;) {
;;;1097   		w = p[si++];					/* Get a character */
;;;1098   		if (w < L' ' || w == L'/' || w == L'\\') break;	/* Break on end of segment */
;;;1099   		if (di >= _MAX_LFN)				/* Reject too long name */
;;;1100   			return FR_INVALID_NAME;
;;;1101   #if !_LFN_UNICODE
;;;1102   		w &= 0xFF;
;;;1103   		if (IsDBCS1(w)) {				/* If it is a DBC 1st byte */
;;;1104   			BYTE c = p[si++];			/* Get 2nd byte */
;;;1105   			if (!IsDBCS2(c))			/* Reject invalid code for DBC */
;;;1106   				return FR_INVALID_NAME;
;;;1107   			w = (w << 8) + c;
;;;1108   		}
;;;1109   		w = ff_convert(w, 1);			/* Convert OEM to Unicode */
;;;1110   		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
;;;1111   #endif
;;;1112   		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject unallowable chars for LFN */
;;;1113   			return FR_INVALID_NAME;
;;;1114   		lfn[di++] = w;					/* Store the Unicode char */
;;;1115   	}
;;;1116   	*path = &p[si];						/* Rerurn pointer to the next segment */
;;;1117   	cf = (w < L' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
;;;1118   #if _FS_RPATH
;;;1119   	if ((di == 1 && lfn[di - 1] == L'.') || /* Is this a dot entry? */
;;;1120   		(di == 2 && lfn[di - 1] == L'.' && lfn[di - 2] == L'.')) {
;;;1121   		lfn[di] = 0;
;;;1122   		for (i = 0; i < 11; i++)
;;;1123   			dj->fn[i] = (i < di) ? '.' : ' ';
;;;1124   		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
;;;1125   		return FR_OK;
;;;1126   	}
;;;1127   #endif
;;;1128   	while (di) {						/* Strip trailing spaces and dots */
;;;1129   		w = lfn[di - 1];
;;;1130   		if (w != L' ' && w != L'.') break;
;;;1131   		di--;
;;;1132   	}
;;;1133   	if (!di) return FR_INVALID_NAME;	/* Reject null string */
;;;1134   
;;;1135   	lfn[di] = 0;						/* LFN is created */
;;;1136   
;;;1137   	/* Create SFN in directory form */
;;;1138   	mem_set(dj->fn, ' ', 11);
;;;1139   	for (si = 0; lfn[si] == L' ' || lfn[si] == L'.'; si++) ;	/* Strip leading spaces and dots */
;;;1140   	if (si) cf |= NS_LOSS | NS_LFN;
;;;1141   	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
;;;1142   
;;;1143   	b = i = 0; ni = 8;
;;;1144   	for (;;) {
;;;1145   		w = lfn[si++];					/* Get an LFN char */
;;;1146   		if (!w) break;					/* Break when enf of the LFN */
;;;1147   		if (w == L' ' || (w == L'.' && si != di)) {	/* Remove spaces and dots */
;;;1148   			cf |= NS_LOSS | NS_LFN; continue;
;;;1149   		}
;;;1150   
;;;1151   		if (i >= ni || si == di) {		/* Extension or end of SFN */
;;;1152   			if (ni == 11) {				/* Long extension */
;;;1153   				cf |= NS_LOSS | NS_LFN; break;
;;;1154   			}
;;;1155   			if (si != di) cf |= NS_LOSS | NS_LFN;	/* File name is longer than 8 bytes */
;;;1156   			if (si > di) break;			/* No extension */
;;;1157   			si = di; i = 8; ni = 11;	/* Enter extension section */
;;;1158   			b <<= 2; continue;
;;;1159   		}
;;;1160   
;;;1161   		if (w >= 0x80) {				/* Non ASCII char */
;;;1162   #ifdef _EXCVT
;;;1163   			w = ff_convert(w, 0);		/* Unicode -> OEM code */
;;;1164   			if (w) w = cvt[w - 0x80];	/* Convert extend char (SBCS) */
;;;1165   #else
;;;1166   			w = ff_convert(ff_wtoupper(w), 0);	/* Unicode (Caps) -> OEM code */
;;;1167   #endif
;;;1168   			cf |= NS_LFN;				/* Force create an LFN */
;;;1169   		}
;;;1170   
;;;1171   		if (_DF1S && w >= 0x100) {		/* Double byte char */
;;;1172   			if (i >= ni - 1) {
;;;1173   				cf |= NS_LOSS | NS_LFN; i = ni; continue;
;;;1174   			}
;;;1175   			dj->fn[i++] = (BYTE)(w >> 8);
;;;1176   		} else {						/* Single byte char */
;;;1177   			if (!w || chk_chr("+,;[=]", w)) {	/* Replace unallowable chars for SFN */
;;;1178   				w = '_'; cf |= NS_LOSS | NS_LFN;	/* Lossy conversion */
;;;1179   			} else {
;;;1180   				if (IsUpper(w)) {		/* Large capital */
;;;1181   					b |= 2;
;;;1182   				} else {
;;;1183   					if (IsLower(w)) {	/* Small capital */
;;;1184   						b |= 1; w -= 0x20;
;;;1185   					}
;;;1186   				}
;;;1187   			}
;;;1188   		}
;;;1189   		dj->fn[i++] = (BYTE)w;
;;;1190   	}
;;;1191   
;;;1192   	if (dj->fn[0] == 0xE5) dj->fn[0] = 0x05;	/* If the first char collides with 0xE5, replace it with 0x05 */
;;;1193   
;;;1194   	if (ni == 8) b <<= 2;
;;;1195   	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
;;;1196   		cf |= NS_LFN;
;;;1197   	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
;;;1198   		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
;;;1199   		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
;;;1200   	}
;;;1201   
;;;1202   	dj->fn[11] = cf;	/* SFN is created */
;;;1203   
;;;1204   
;;;1205   #else	/* Non-LFN configuration */
;;;1206   	BYTE b, c, d, *sfn;
;;;1207   	int ni, si, i;
;;;1208   	const char *p;
;;;1209   
;;;1210   	/* Create file name in directory form */
;;;1211   	sfn = dj->fn;
;;;1212   	mem_set(sfn, ' ', 11);
000004  6984              LDR      r4,[r0,#0x18]
000006  468a              MOV      r10,r1                ;1082
000008  220b              MOVS     r2,#0xb
00000a  2120              MOVS     r1,#0x20
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       mem_set
;;;1213   	si = i = b = 0; ni = 8;
000012  2100              MOVS     r1,#0
;;;1214   	p = *path;
000014  f8da6000          LDR      r6,[r10,#0]
000018  468c              MOV      r12,r1                ;1213
00001a  460a              MOV      r2,r1                 ;1213
00001c  2008              MOVS     r0,#8                 ;1213
                  |L5.30|
;;;1215   #if _FS_RPATH
;;;1216   	if (p[si] == '.') { /* Is this a dot entry? */
;;;1217   		for (;;) {
;;;1218   			c = p[si++];
;;;1219   			if (c != '.' || si >= 3) break;
;;;1220   			sfn[i++] = c;
;;;1221   		}
;;;1222   		if (c != '/' && c != '\\' && c >= ' ') return FR_INVALID_NAME;
;;;1223   		*path = &p[si];									/* Rerurn pointer to the next segment */
;;;1224   		sfn[11] = (c < ' ') ? NS_LAST|NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
;;;1225   		return FR_OK;
;;;1226   	}
;;;1227   #endif
;;;1228   	for (;;) {
;;;1229   		c = p[si++];
00001e  5cb3              LDRB     r3,[r6,r2]
000020  1c52              ADDS     r2,r2,#1
;;;1230   		if (c < ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
000022  2b20              CMP      r3,#0x20
000024  d34d              BCC      |L5.194|
000026  2b2f              CMP      r3,#0x2f
000028  d04b              BEQ      |L5.194|
00002a  2b5c              CMP      r3,#0x5c
00002c  d049              BEQ      |L5.194|
;;;1231   		if (c == '.' || i >= ni) {
00002e  2b2e              CMP      r3,#0x2e
000030  d001              BEQ      |L5.54|
000032  4584              CMP      r12,r0
000034  db08              BLT      |L5.72|
                  |L5.54|
;;;1232   			if (ni != 8 || c != '.') return FR_INVALID_NAME;
000036  2808              CMP      r0,#8
000038  d151              BNE      |L5.222|
00003a  2b2e              CMP      r3,#0x2e
00003c  d14f              BNE      |L5.222|
;;;1233   			i = 8; ni = 11;
00003e  4684              MOV      r12,r0
000040  200b              MOVS     r0,#0xb
;;;1234   			b <<= 2; continue;
000042  0689              LSLS     r1,r1,#26
000044  0e09              LSRS     r1,r1,#24
000046  e7ea              B        |L5.30|
                  |L5.72|
;;;1235   		}
;;;1236   		if (c >= 0x80) {				/* Extended char */
000048  2b80              CMP      r3,#0x80
00004a  d301              BCC      |L5.80|
;;;1237   #ifdef _EXCVT
;;;1238   			c = cvt[c - 0x80];			/* Convert extend char (SBCS) */
;;;1239   #else
;;;1240   			b |= 3;						/* Eliminate NT flag if ext char is exist */
00004c  f0410103          ORR      r1,r1,#3
                  |L5.80|
;;;1241   #if !_DF1S	/* ASCII only cfg */
;;;1242   			return FR_INVALID_NAME;
;;;1243   #endif
;;;1244   #endif
;;;1245   		}
;;;1246   		if (IsDBCS1(c)) {				/* If it is DBC 1st byte */
000050  f1a30581          SUB      r5,r3,#0x81
000054  2d1e              CMP      r5,#0x1e
000056  d902              BLS      |L5.94|
000058  3d5f              SUBS     r5,r5,#0x5f
00005a  2d1c              CMP      r5,#0x1c
00005c  d815              BHI      |L5.138|
                  |L5.94|
;;;1247   			d = p[si++];				/* Get 2nd byte */
00005e  f8169002          LDRB     r9,[r6,r2]
000062  1c52              ADDS     r2,r2,#1
;;;1248   			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
000064  f1a90540          SUB      r5,r9,#0x40
000068  2d3f              CMP      r5,#0x3f
00006a  d303              BCC      |L5.116|
00006c  f1a90780          SUB      r7,r9,#0x80
000070  2f7d              CMP      r7,#0x7d
000072  d234              BCS      |L5.222|
                  |L5.116|
000074  f1a00801          SUB      r8,r0,#1
000078  45c4              CMP      r12,r8
00007a  da30              BGE      |L5.222|
;;;1249   				return FR_INVALID_NAME;
;;;1250   			sfn[i++] = c;
00007c  f804300c          STRB     r3,[r4,r12]
000080  f10c0c01          ADD      r12,r12,#1
;;;1251   			sfn[i++] = d;
000084  f804900c          STRB     r9,[r4,r12]
000088  e018              B        |L5.188|
                  |L5.138|
;;;1252   		} else {
;;;1253   			if (chk_chr(" \"*+,[=]|\x7F", c))	/* Reject unallowable chrs for SFN */
00008a  a521              ADR      r5,|L5.272|
00008c  e000              B        |L5.144|
                  |L5.142|
00008e  1c6d              ADDS     r5,r5,#1
                  |L5.144|
000090  782f              LDRB     r7,[r5,#0]
000092  b117              CBZ      r7,|L5.154|
000094  429f              CMP      r7,r3
000096  d1fa              BNE      |L5.142|
000098  e021              B        |L5.222|
                  |L5.154|
;;;1254   				return FR_INVALID_NAME;
;;;1255   			if (IsUpper(c)) {
00009a  f1a30541          SUB      r5,r3,#0x41
00009e  2d19              CMP      r5,#0x19
0000a0  d802              BHI      |L5.168|
;;;1256   				b |= 2;
0000a2  f0410102          ORR      r1,r1,#2
0000a6  e007              B        |L5.184|
                  |L5.168|
;;;1257   			} else {
;;;1258   				if (IsLower(c)) {
0000a8  f1a30561          SUB      r5,r3,#0x61
0000ac  2d19              CMP      r5,#0x19
0000ae  d803              BHI      |L5.184|
;;;1259   					b |= 1; c -= 0x20;
0000b0  3b20              SUBS     r3,r3,#0x20
0000b2  f0410101          ORR      r1,r1,#1
0000b6  b2db              UXTB     r3,r3
                  |L5.184|
;;;1260   				}
;;;1261   			}
;;;1262   			sfn[i++] = c;
0000b8  f804300c          STRB     r3,[r4,r12]
                  |L5.188|
0000bc  f10c0c01          ADD      r12,r12,#1
0000c0  e7ad              B        |L5.30|
                  |L5.194|
;;;1263   		}
;;;1264   	}
;;;1265   	*path = &p[si];						/* Rerurn pointer to the next segment */
0000c2  18b5              ADDS     r5,r6,r2
;;;1266   	c = (c < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
0000c4  2204              MOVS     r2,#4
0000c6  f8ca5000          STR      r5,[r10,#0]
0000ca  2b20              CMP      r3,#0x20
0000cc  d300              BCC      |L5.208|
0000ce  2200              MOVS     r2,#0
                  |L5.208|
;;;1267   
;;;1268   	if (!i) return FR_INVALID_NAME;		/* Reject null string */
0000d0  f1bc0f00          CMP      r12,#0
0000d4  d003              BEQ      |L5.222|
;;;1269   	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
0000d6  7823              LDRB     r3,[r4,#0]
0000d8  2be5              CMP      r3,#0xe5
0000da  d003              BEQ      |L5.228|
0000dc  e004              B        |L5.232|
                  |L5.222|
0000de  2006              MOVS     r0,#6                 ;1268
                  |L5.224|
;;;1270   
;;;1271   	if (ni == 8) b <<= 2;
;;;1272   	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Extension has only small capital) */
;;;1273   	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
;;;1274   
;;;1275   	sfn[11] = c;		/* Store NT flag, File name is created */
;;;1276   #endif
;;;1277   
;;;1278   	return FR_OK;
;;;1279   }
0000e0  e8bd87f0          POP      {r4-r10,pc}
                  |L5.228|
0000e4  2305              MOVS     r3,#5                 ;1269
0000e6  7023              STRB     r3,[r4,#0]            ;1269
                  |L5.232|
0000e8  2808              CMP      r0,#8                 ;1271
0000ea  d101              BNE      |L5.240|
0000ec  0688              LSLS     r0,r1,#26             ;1271
0000ee  0e01              LSRS     r1,r0,#24             ;1271
                  |L5.240|
0000f0  f0010003          AND      r0,r1,#3              ;1272
0000f4  2801              CMP      r0,#1                 ;1272
0000f6  d101              BNE      |L5.252|
0000f8  f0420210          ORR      r2,r2,#0x10           ;1272
                  |L5.252|
0000fc  f3c10081          UBFX     r0,r1,#2,#2           ;1273
000100  2801              CMP      r0,#1                 ;1273
000102  d101              BNE      |L5.264|
000104  f0420208          ORR      r2,r2,#8              ;1273
                  |L5.264|
000108  72e2              STRB     r2,[r4,#0xb]          ;1275
00010a  2000              MOVS     r0,#0                 ;1278
00010c  e7e8              B        |L5.224|
;;;1280   
                          ENDP

00010e  0000              DCW      0x0000
                  |L5.272|
000110  20222a2b          DCB      " ""*+,[=]|",127,0
000114  2c5b3d5d
000118  7c7f00  
00011b  00                DCB      0

                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=2

                  dir_next PROC
;;;578    static
;;;579    FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not streach */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;580    	DIR *dj,		/* Pointer to directory object */
;;;581    	bool streach	/* FALSE: Do not streach table, TRUE: Streach table if needed */
;;;582    )
;;;583    {
000004  4604              MOV      r4,r0
;;;584    	DWORD clst;
;;;585    	WORD i;
;;;586    
;;;587    
;;;588    	i = dj->index + 1;
000006  88c0              LDRH     r0,[r0,#6]
000008  460f              MOV      r7,r1                 ;583
00000a  1c40              ADDS     r0,r0,#1
00000c  0406              LSLS     r6,r0,#16
00000e  0c36              LSRS     r6,r6,#16
;;;589    	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
000010  d02d              BEQ      |L6.110|
000012  6920              LDR      r0,[r4,#0x10]
000014  b358              CBZ      r0,|L6.110|
;;;590    		return FR_NO_FILE;
;;;591    
;;;592    	if (!(i % (SS(dj->fs) / 32))) {	/* Sector changed? */
000016  0731              LSLS     r1,r6,#28
000018  d15e              BNE      |L6.216|
;;;593    		dj->sect++;					/* Next sector */
00001a  1c40              ADDS     r0,r0,#1
;;;594    
;;;595    		if (dj->clust == 0) {	/* Static table */
00001c  6120              STR      r0,[r4,#0x10]
00001e  68e1              LDR      r1,[r4,#0xc]
000020  6820              LDR      r0,[r4,#0]
000022  b129              CBZ      r1,|L6.48|
;;;596    			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
;;;597    				return FR_NO_FILE;
;;;598    		}
;;;599    		else {					/* Dynamic table */
;;;600    			if (((i / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
000024  7882              LDRB     r2,[r0,#2]
000026  1e52              SUBS     r2,r2,#1
000028  ea121f16          TST      r2,r6,LSR #4
00002c  d004              BEQ      |L6.56|
00002e  e053              B        |L6.216|
                  |L6.48|
000030  8900              LDRH     r0,[r0,#8]            ;596
000032  42b0              CMP      r0,r6                 ;596
000034  d91b              BLS      |L6.110|
000036  e04f              B        |L6.216|
                  |L6.56|
;;;601    				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
000038  f7fffffe          BL       get_fat
00003c  4605              MOV      r5,r0
;;;602    				if (clst <= 1) return FR_INT_ERR;
00003e  2801              CMP      r0,#1
000040  d91a              BLS      |L6.120|
;;;603    				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
000042  1c68              ADDS     r0,r5,#1
000044  d033              BEQ      |L6.174|
;;;604    				if (clst >= dj->fs->max_clust) {				/* When it reached end of dynamic table */
000046  6820              LDR      r0,[r4,#0]
000048  69c1              LDR      r1,[r0,#0x1c]
00004a  42a9              CMP      r1,r5
00004c  d83e              BHI      |L6.204|
;;;605    #if !_FS_READONLY
;;;606    					BYTE c;
;;;607    					if (!streach) return FR_NO_FILE;			/* When do not streach, report EOT */
00004e  b177              CBZ      r7,|L6.110|
;;;608    					clst = create_chain(dj->fs, dj->clust);		/* Streach cluster chain */
000050  68e1              LDR      r1,[r4,#0xc]
000052  f7fffffe          BL       create_chain
000056  0005              MOVS     r5,r0
;;;609    					if (clst == 0) return FR_DENIED;			/* No free cluster */
000058  d00c              BEQ      |L6.116|
;;;610    					if (clst == 1) return FR_INT_ERR;
00005a  2d01              CMP      r5,#1
00005c  d00c              BEQ      |L6.120|
;;;611    					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
00005e  1c68              ADDS     r0,r5,#1
000060  d025              BEQ      |L6.174|
;;;612    					/* Clean-up streached table */
;;;613    					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
000062  2100              MOVS     r1,#0
000064  6820              LDR      r0,[r4,#0]
000066  f7fffffe          BL       move_window
00006a  bb00              CBNZ     r0,|L6.174|
00006c  e006              B        |L6.124|
                  |L6.110|
00006e  2004              MOVS     r0,#4                 ;607
                  |L6.112|
;;;614    					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
;;;615    					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
;;;616    					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
;;;617    						dj->fs->wflag = 1;
;;;618    						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
;;;619    						dj->fs->winsect++;
;;;620    					}
;;;621    					dj->fs->winsect -= c;						/* Rewind window address */
;;;622    #else
;;;623    					return FR_NO_FILE;			/* Report EOT */
;;;624    #endif
;;;625    				}
;;;626    				dj->clust = clst;				/* Initialize data for new cluster */
;;;627    				dj->sect = clust2sect(dj->fs, clst);
;;;628    			}
;;;629    		}
;;;630    	}
;;;631    
;;;632    	dj->index = i;
;;;633    	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
;;;634    
;;;635    	return FR_OK;
;;;636    }
000070  e8bd81f0          POP      {r4-r8,pc}
                  |L6.116|
000074  2007              MOVS     r0,#7                 ;609
000076  e7fb              B        |L6.112|
                  |L6.120|
000078  2002              MOVS     r0,#2                 ;610
00007a  e7f9              B        |L6.112|
                  |L6.124|
00007c  6820              LDR      r0,[r4,#0]            ;614
00007e  f44f7200          MOV      r2,#0x200             ;614
000082  3030              ADDS     r0,r0,#0x30           ;614
000084  2100              MOVS     r1,#0                 ;614
000086  f7fffffe          BL       mem_set
00008a  4629              MOV      r1,r5                 ;615
00008c  6820              LDR      r0,[r4,#0]            ;615
00008e  f7fffffe          BL       clust2sect
000092  6821              LDR      r1,[r4,#0]            ;615
000094  2700              MOVS     r7,#0                 ;616
000096  f04f0801          MOV      r8,#1                 ;603
00009a  62c8              STR      r0,[r1,#0x2c]         ;616
00009c  e00f              B        |L6.190|
00009e  bf00              NOP                            ;617
                  |L6.160|
0000a0  f8808004          STRB     r8,[r0,#4]            ;617
0000a4  2100              MOVS     r1,#0                 ;618
0000a6  6820              LDR      r0,[r4,#0]            ;618
0000a8  f7fffffe          BL       move_window
0000ac  b108              CBZ      r0,|L6.178|
                  |L6.174|
0000ae  2001              MOVS     r0,#1                 ;618
0000b0  e7de              B        |L6.112|
                  |L6.178|
0000b2  6820              LDR      r0,[r4,#0]            ;619
0000b4  1c7f              ADDS     r7,r7,#1              ;616
0000b6  b2ff              UXTB     r7,r7                 ;616
0000b8  6ac1              LDR      r1,[r0,#0x2c]         ;619
0000ba  1c49              ADDS     r1,r1,#1              ;619
0000bc  62c1              STR      r1,[r0,#0x2c]         ;619
                  |L6.190|
0000be  6820              LDR      r0,[r4,#0]            ;616
0000c0  7881              LDRB     r1,[r0,#2]            ;616
0000c2  42b9              CMP      r1,r7                 ;616
0000c4  d8ec              BHI      |L6.160|
0000c6  6ac1              LDR      r1,[r0,#0x2c]         ;621
0000c8  1bc9              SUBS     r1,r1,r7              ;621
0000ca  62c1              STR      r1,[r0,#0x2c]         ;621
                  |L6.204|
0000cc  60e5              STR      r5,[r4,#0xc]          ;627
0000ce  4629              MOV      r1,r5                 ;627
0000d0  6820              LDR      r0,[r4,#0]            ;627
0000d2  f7fffffe          BL       clust2sect
0000d6  6120              STR      r0,[r4,#0x10]         ;627
                  |L6.216|
0000d8  80e6              STRH     r6,[r4,#6]            ;632
0000da  f006010f          AND      r1,r6,#0xf            ;633
0000de  2230              MOVS     r2,#0x30              ;633
0000e0  6820              LDR      r0,[r4,#0]            ;633
0000e2  eb021141          ADD      r1,r2,r1,LSL #5       ;633
0000e6  4408              ADD      r0,r0,r1              ;633
0000e8  6160              STR      r0,[r4,#0x14]         ;635
0000ea  2000              MOVS     r0,#0                 ;635
0000ec  e7c0              B        |L6.112|
;;;637    
                          ENDP


                          AREA ||i.dir_read||, CODE, READONLY, ALIGN=1

                  dir_read PROC
;;;870    static
;;;871    FRESULT dir_read (
000000  b510              PUSH     {r4,lr}
;;;872    	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
;;;873    )
;;;874    {
000002  4604              MOV      r4,r0
;;;875    	FRESULT res;
;;;876    	BYTE c, *dir;
;;;877    #if _USE_LFN
;;;878    	BYTE a, ord = 0xFF, sum = 0xFF;
;;;879    #endif
;;;880    
;;;881    	res = FR_NO_FILE;
000004  2004              MOVS     r0,#4
;;;882    	while (dj->sect) {
000006  e015              B        |L7.52|
                  |L7.8|
;;;883    		res = move_window(dj->fs, dj->sect);
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       move_window
;;;884    		if (res != FR_OK) break;
00000e  b9b0              CBNZ     r0,|L7.62|
;;;885    		dir = dj->dir;					/* Ptr to the directory entry of current index */
;;;886    		c = dir[DIR_Name];
000010  6962              LDR      r2,[r4,#0x14]
000012  7811              LDRB     r1,[r2,#0]
;;;887    		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
000014  b161              CBZ      r1,|L7.48|
;;;888    #if _USE_LFN	/* LFN configuration */
;;;889    		a = dir[DIR_Attr] & AM_MASK;
;;;890    		if (c == 0xE5 || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
;;;891    			ord = 0xFF;
;;;892    		} else {
;;;893    			if (a == AM_LFN) {			/* An LFN entry is found */
;;;894    				if (c & 0x40) {			/* Is it start of LFN sequence? */
;;;895    					sum = dir[LDIR_Chksum];
;;;896    					c &= 0xBF; ord = c;
;;;897    					dj->lfn_idx = dj->index;
;;;898    				}
;;;899    				/* Check LFN validity and capture it */
;;;900    				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
;;;901    			} else {					/* An SFN entry is found */
;;;902    				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN entry? */
;;;903    					dj->lfn_idx = 0xFFFF;		/* No LFN. */
;;;904    				break;
;;;905    			}
;;;906    		}
;;;907    #else		/* Non LFN configuration */
;;;908    		if (c != 0xE5 && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
000016  29e5              CMP      r1,#0xe5
000018  d004              BEQ      |L7.36|
00001a  292e              CMP      r1,#0x2e
00001c  d002              BEQ      |L7.36|
00001e  7ad1              LDRB     r1,[r2,#0xb]
000020  0709              LSLS     r1,r1,#28
000022  d50e              BPL      |L7.66|
                  |L7.36|
;;;909    			break;
;;;910    #endif
;;;911    		res = dir_next(dj, FALSE);				/* Next entry */
000024  2100              MOVS     r1,#0
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       dir_next
;;;912    		if (res != FR_OK) break;
00002c  b110              CBZ      r0,|L7.52|
00002e  e006              B        |L7.62|
                  |L7.48|
000030  2004              MOVS     r0,#4                 ;887
000032  e004              B        |L7.62|
                  |L7.52|
000034  6921              LDR      r1,[r4,#0x10]         ;882
000036  2900              CMP      r1,#0                 ;882
000038  d1e6              BNE      |L7.8|
;;;913    	}
;;;914    
;;;915    	if (res != FR_OK) dj->sect = 0;
00003a  2800              CMP      r0,#0
00003c  d001              BEQ      |L7.66|
                  |L7.62|
00003e  2100              MOVS     r1,#0
000040  6121              STR      r1,[r4,#0x10]
                  |L7.66|
;;;916    
;;;917    	return res;
;;;918    }
000042  bd10              POP      {r4,pc}
;;;919    #endif
                          ENDP


                          AREA ||i.dir_register||, CODE, READONLY, ALIGN=1

                  dir_register PROC
;;;927    static
;;;928    FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;929    	DIR *dj				/* Target directory with object name to be created */
;;;930    )
;;;931    {
000002  4604              MOV      r4,r0
;;;932    	FRESULT res;
;;;933    	BYTE c, *dir;
;;;934    #if _USE_LFN	/* LFN configuration */
;;;935    	WORD n, ne, is;
;;;936    	BYTE sn[12], *fn, sum;
;;;937    	WCHAR *lfn;
;;;938    
;;;939    
;;;940    	fn = dj->fn; lfn = dj->lfn;
;;;941    	mem_cpy(sn, fn, 12);
;;;942    
;;;943    	if (_FS_RPATH && (sn[11] & NS_DOT)) return FR_INVALID_NAME;	/* Cannot create dot entry */
;;;944    
;;;945    	if (sn[11] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
;;;946    		fn[11] = 0; dj->lfn = NULL;			/* Find only SFN */
;;;947    		for (n = 1; n < 100; n++) {
;;;948    			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
;;;949    			res = dir_find(dj);				/* Check if the name collides with existing SFN */
;;;950    			if (res != FR_OK) break;
;;;951    		}
;;;952    		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
;;;953    		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
;;;954    		fn[11] = sn[11]; dj->lfn = lfn;
;;;955    	}
;;;956    
;;;957    	if (sn[11] & NS_LFN) {			/* When LFN is to be created, reserve reserve an SFN + LFN entries. */
;;;958    		for (ne = 0; lfn[ne]; ne++) ;
;;;959    		ne = (ne + 25) / 13;
;;;960    	} else {						/* Otherwise reserve only an SFN entry. */
;;;961    		ne = 1;
;;;962    	}
;;;963    
;;;964    	/* Reserve contiguous entries */
;;;965    	res = dir_seek(dj, 0);
;;;966    	if (res != FR_OK) return res;
;;;967    	n = is = 0;
;;;968    	do {
;;;969    		res = move_window(dj->fs, dj->sect);
;;;970    		if (res != FR_OK) break;
;;;971    		c = *dj->dir;				/* Check the entry status */
;;;972    		if (c == 0xE5 || c == 0) {	/* Is it a blank entry? */
;;;973    			if (n == 0) is = dj->index;	/* First index of the contigulus entry */
;;;974    			if (++n == ne) break;	/* A contiguous entry that requiered count is found */
;;;975    		} else {
;;;976    			n = 0;					/* Not a blank entry. Restart to search */
;;;977    		}
;;;978    		res = dir_next(dj, TRUE);	/* Next entry with table streach */
;;;979    	} while (res == FR_OK);
;;;980    
;;;981    	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
;;;982    		res = dir_seek(dj, is);
;;;983    		if (res == FR_OK) {
;;;984    			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
;;;985    			ne--;
;;;986    			do {					/* Store LFN entries in bottom first */
;;;987    				res = move_window(dj->fs, dj->sect);
;;;988    				if (res != FR_OK) break;
;;;989    				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
;;;990    				dj->fs->wflag = 1;
;;;991    				res = dir_next(dj, FALSE);	/* Next entry */
;;;992    			} while (res == FR_OK && --ne);
;;;993    		}
;;;994    	}
;;;995    
;;;996    #else	/* Non LFN configuration */
;;;997    	res = dir_seek(dj, 0);
000004  2100              MOVS     r1,#0
000006  f7fffffe          BL       dir_seek
;;;998    	if (res == FR_OK) {
00000a  e00e              B        |L8.42|
                  |L8.12|
;;;999    		do {	/* Find a blank entry for the SFN */
;;;1000   			res = move_window(dj->fs, dj->sect);
00000c  6921              LDR      r1,[r4,#0x10]
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       move_window
000014  0005              MOVS     r5,r0
;;;1001   			if (res != FR_OK) break;
000016  d124              BNE      |L8.98|
;;;1002   			c = *dj->dir;
000018  6960              LDR      r0,[r4,#0x14]
00001a  7800              LDRB     r0,[r0,#0]
;;;1003   			if (c == 0xE5 || c == 0) break;	/* Is it a blank entry? */
00001c  28e5              CMP      r0,#0xe5
00001e  d007              BEQ      |L8.48|
000020  b130              CBZ      r0,|L8.48|
;;;1004   			res = dir_next(dj, TRUE);		/* Next entry with table streach */
000022  2101              MOVS     r1,#1
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       dir_next
                  |L8.42|
00002a  0005              MOVS     r5,r0                 ;997
00002c  d0ee              BEQ      |L8.12|
00002e  e018              B        |L8.98|
                  |L8.48|
;;;1005   		} while (res == FR_OK);
;;;1006   	}
;;;1007   #endif
;;;1008   
;;;1009   	if (res == FR_OK) {		/* Initialize the SFN entry */
;;;1010   		res = move_window(dj->fs, dj->sect);
000030  6921              LDR      r1,[r4,#0x10]
000032  6820              LDR      r0,[r4,#0]
000034  f7fffffe          BL       move_window
000038  0005              MOVS     r5,r0
;;;1011   		if (res == FR_OK) {
00003a  d112              BNE      |L8.98|
;;;1012   			dir = dj->dir;
;;;1013   			mem_set(dir, 0, 32);		/* Clean the entry */
00003c  6966              LDR      r6,[r4,#0x14]
00003e  2220              MOVS     r2,#0x20
000040  2100              MOVS     r1,#0
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       mem_set
;;;1014   			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
000048  220b              MOVS     r2,#0xb
00004a  4630              MOV      r0,r6
00004c  69a1              LDR      r1,[r4,#0x18]
00004e  f7fffffe          BL       mem_cpy
;;;1015   			dir[DIR_NTres] = *(dj->fn+11) & 0x18;	/* Put NT flag */
000052  69a0              LDR      r0,[r4,#0x18]
000054  7ac0              LDRB     r0,[r0,#0xb]
000056  f0000018          AND      r0,r0,#0x18
00005a  7330              STRB     r0,[r6,#0xc]
;;;1016   			dj->fs->wflag = 1;
00005c  6821              LDR      r1,[r4,#0]
00005e  2001              MOVS     r0,#1
000060  7108              STRB     r0,[r1,#4]
                  |L8.98|
;;;1017   		}
;;;1018   	}
;;;1019   
;;;1020   	return res;
000062  4628              MOV      r0,r5
;;;1021   }
000064  bd70              POP      {r4-r6,pc}
;;;1022   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_remove||, CODE, READONLY, ALIGN=1

                  dir_remove PROC
;;;1031   static
;;;1032   FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
000000  b510              PUSH     {r4,lr}
;;;1033   	DIR *dj				/* Directory object pointing the entry to be removed */
;;;1034   )
;;;1035   {
000002  4604              MOV      r4,r0
;;;1036   	FRESULT res;
;;;1037   #if _USE_LFN	/* LFN configuration */
;;;1038   	WORD i;
;;;1039   
;;;1040   	i = dj->index;	/* SFN index */
;;;1041   	res = dir_seek(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
;;;1042   	if (res == FR_OK) {
;;;1043   		do {
;;;1044   			res = move_window(dj->fs, dj->sect);
;;;1045   			if (res != FR_OK) break;
;;;1046   			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
;;;1047   			dj->fs->wflag = 1;
;;;1048   			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
;;;1049   			res = dir_next(dj, FALSE);	/* Next entry */
;;;1050   		} while (res == FR_OK);
;;;1051   		if (res == FR_NO_FILE) res = FR_INT_ERR;
;;;1052   	}
;;;1053   
;;;1054   #else			/* Non LFN configuration */
;;;1055   	res = dir_seek(dj, dj->index);
000004  88c1              LDRH     r1,[r0,#6]
000006  f7fffffe          BL       dir_seek
;;;1056   	if (res == FR_OK) {
00000a  2800              CMP      r0,#0
00000c  d10b              BNE      |L9.38|
;;;1057   		res = move_window(dj->fs, dj->sect);
00000e  6921              LDR      r1,[r4,#0x10]
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       move_window
;;;1058   		if (res == FR_OK) {
000016  2800              CMP      r0,#0
000018  d105              BNE      |L9.38|
;;;1059   			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
00001a  6963              LDR      r3,[r4,#0x14]
00001c  22e5              MOVS     r2,#0xe5
;;;1060   			dj->fs->wflag = 1;
00001e  2101              MOVS     r1,#1
000020  701a              STRB     r2,[r3,#0]            ;1059
000022  6822              LDR      r2,[r4,#0]
000024  7111              STRB     r1,[r2,#4]
                  |L9.38|
;;;1061   		}
;;;1062   	}
;;;1063   #endif
;;;1064   
;;;1065   	return res;
;;;1066   }
000026  bd10              POP      {r4,pc}
;;;1067   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_seek||, CODE, READONLY, ALIGN=1

                  dir_seek PROC
;;;530    static
;;;531    FRESULT dir_seek (
000000  b570              PUSH     {r4-r6,lr}
;;;532    	DIR *dj,		/* Pointer to directory object */
;;;533    	WORD idx		/* Directory index number */
;;;534    )
;;;535    {
000002  460d              MOV      r5,r1
;;;536    	DWORD clst;
;;;537    	WORD ic;
;;;538    
;;;539    
;;;540    	dj->index = idx;
000004  80c1              STRH     r1,[r0,#6]
;;;541    	clst = dj->sclust;
;;;542    	if (clst == 1 || clst >= dj->fs->max_clust)	/* Check start cluster range */
000006  6881              LDR      r1,[r0,#8]
000008  4604              MOV      r4,r0                 ;535
00000a  2901              CMP      r1,#1
00000c  d01e              BEQ      |L10.76|
00000e  6820              LDR      r0,[r4,#0]
000010  69c2              LDR      r2,[r0,#0x1c]
000012  428a              CMP      r2,r1
000014  d91a              BLS      |L10.76|
;;;543    		return FR_INT_ERR;
;;;544    	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
000016  b921              CBNZ     r1,|L10.34|
000018  7802              LDRB     r2,[r0,#0]
00001a  2a03              CMP      r2,#3
00001c  d104              BNE      |L10.40|
;;;545    		clst = dj->fs->dirbase;
;;;546    
;;;547    	if (clst == 0) {	/* Static table */
00001e  6a41              LDR      r1,[r0,#0x24]
000020  b111              CBZ      r1,|L10.40|
                  |L10.34|
;;;548    		dj->clust = clst;
;;;549    		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
;;;550    			return FR_INT_ERR;
;;;551    		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
;;;552    	}
;;;553    	else {				/* Dynamic table */
;;;554    		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
000022  7880              LDRB     r0,[r0,#2]
000024  0106              LSLS     r6,r0,#4
;;;555    		while (idx >= ic) {	/* Follow cluster chain */
000026  e017              B        |L10.88|
                  |L10.40|
000028  60e1              STR      r1,[r4,#0xc]          ;549
00002a  8901              LDRH     r1,[r0,#8]            ;549
00002c  42a9              CMP      r1,r5                 ;549
00002e  d90d              BLS      |L10.76|
000030  6a40              LDR      r0,[r0,#0x24]         ;551
000032  e017              B        |L10.100|
                  |L10.52|
;;;556    			clst = get_fat(dj->fs, clst);				/* Get next cluster */
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       get_fat
00003a  4601              MOV      r1,r0
;;;557    			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
00003c  1c40              ADDS     r0,r0,#1
00003e  d007              BEQ      |L10.80|
;;;558    			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
000040  2902              CMP      r1,#2
000042  d303              BCC      |L10.76|
000044  6820              LDR      r0,[r4,#0]
000046  69c0              LDR      r0,[r0,#0x1c]
000048  4288              CMP      r0,r1
00004a  d803              BHI      |L10.84|
                  |L10.76|
;;;559    				return FR_INT_ERR;
00004c  2002              MOVS     r0,#2
;;;560    			idx -= ic;
;;;561    		}
;;;562    		dj->clust = clst;
;;;563    		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
;;;564    	}
;;;565    
;;;566    	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / 32)) * 32;	/* Ptr to the entry in the sector */
;;;567    
;;;568    	return FR_OK;	/* Seek succeeded */
;;;569    }
00004e  bd70              POP      {r4-r6,pc}
                  |L10.80|
000050  2001              MOVS     r0,#1                 ;557
000052  bd70              POP      {r4-r6,pc}
                  |L10.84|
000054  1ba8              SUBS     r0,r5,r6              ;560
000056  b285              UXTH     r5,r0                 ;560
                  |L10.88|
000058  42b5              CMP      r5,r6                 ;555
00005a  d2eb              BCS      |L10.52|
00005c  60e1              STR      r1,[r4,#0xc]          ;563
00005e  6820              LDR      r0,[r4,#0]            ;563
000060  f7fffffe          BL       clust2sect
                  |L10.100|
000064  eb001015          ADD      r0,r0,r5,LSR #4       ;563
000068  6120              STR      r0,[r4,#0x10]         ;566
00006a  f005010f          AND      r1,r5,#0xf            ;566
00006e  2230              MOVS     r2,#0x30              ;566
000070  6820              LDR      r0,[r4,#0]            ;566
000072  eb021141          ADD      r1,r2,r1,LSL #5       ;566
000076  4408              ADD      r0,r0,r1              ;566
000078  6160              STR      r0,[r4,#0x14]         ;568
00007a  2000              MOVS     r0,#0                 ;568
00007c  bd70              POP      {r4-r6,pc}
;;;570    
                          ENDP


                          AREA ||i.f_chmod||, CODE, READONLY, ALIGN=1

                  f_chmod PROC
;;;2546   
;;;2547   FRESULT f_chmod (
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;2548   	const XCHAR *path,	/* Pointer to the file path */
;;;2549   	BYTE value,			/* Attribute bits */
;;;2550   	BYTE mask			/* Attribute mask to change */
;;;2551   )
;;;2552   {
000002  b08a              SUB      sp,sp,#0x28
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;2553   	FRESULT res;
;;;2554   	DIR dj;
;;;2555   	NAMEBUF(sfn, lfn);
;;;2556   	BYTE *dir;
;;;2557   
;;;2558   
;;;2559   	res = auto_mount(&path, &dj.fs, 1);
000008  2201              MOVS     r2,#1
00000a  4669              MOV      r1,sp
00000c  a80a              ADD      r0,sp,#0x28
00000e  f7fffffe          BL       auto_mount
;;;2560   	if (res == FR_OK) {
000012  2800              CMP      r0,#0
000014  d116              BNE      |L11.68|
;;;2561   		INITBUF(dj, sfn, lfn);
000016  a807              ADD      r0,sp,#0x1c
;;;2562   		res = follow_path(&dj, path);		/* Follow the file path */
000018  9006              STR      r0,[sp,#0x18]
00001a  4668              MOV      r0,sp
00001c  990a              LDR      r1,[sp,#0x28]
00001e  f7fffffe          BL       follow_path
;;;2563   		if (_FS_RPATH && res == FR_OK && (dj.fn[11] & NS_DOT))
;;;2564   			res = FR_INVALID_NAME;
;;;2565   		if (res == FR_OK) {
000022  2800              CMP      r0,#0
000024  d10e              BNE      |L11.68|
;;;2566   			dir = dj.dir;
;;;2567   			if (!dir) {						/* Is it a root directory? */
000026  9805              LDR      r0,[sp,#0x14]
000028  b170              CBZ      r0,|L11.72|
;;;2568   				res = FR_INVALID_NAME;
;;;2569   			} else {						/* File or sub directory */
;;;2570   				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
00002a  f0050127          AND      r1,r5,#0x27
;;;2571   				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
00002e  7ac2              LDRB     r2,[r0,#0xb]
000030  400c              ANDS     r4,r4,r1
000032  438a              BICS     r2,r2,r1
000034  4314              ORRS     r4,r4,r2
000036  72c4              STRB     r4,[r0,#0xb]
;;;2572   				dj.fs->wflag = 1;
000038  9900              LDR      r1,[sp,#0]
00003a  2001              MOVS     r0,#1
00003c  7108              STRB     r0,[r1,#4]
;;;2573   				res = sync(dj.fs);
00003e  9800              LDR      r0,[sp,#0]
000040  f7fffffe          BL       sync
                  |L11.68|
;;;2574   			}
;;;2575   		}
;;;2576   	}
;;;2577   
;;;2578   	LEAVE_FF(dj.fs, res);
;;;2579   }
000044  b00d              ADD      sp,sp,#0x34
000046  bd30              POP      {r4,r5,pc}
                  |L11.72|
000048  2006              MOVS     r0,#6                 ;2568
00004a  e7fb              B        |L11.68|
;;;2580   
                          ENDP


                          AREA ||i.f_close||, CODE, READONLY, ALIGN=1

                  f_close PROC
;;;2006   
;;;2007   FRESULT f_close (
000000  b510              PUSH     {r4,lr}
;;;2008   	FIL *fp		/* Pointer to the file object to be closed */
;;;2009   )
;;;2010   {
000002  4604              MOV      r4,r0
;;;2011   	FRESULT res;
;;;2012   
;;;2013   
;;;2014   #if _FS_READONLY
;;;2015   	res = validate(fp->fs, fp->id);
;;;2016   	if (res == FR_OK) fp->fs = NULL;
;;;2017   	LEAVE_FF(fp->fs, res);
;;;2018   #else
;;;2019   	res = f_sync(fp);
000004  f7fffffe          BL       f_sync
;;;2020   	if (res == FR_OK) fp->fs = NULL;
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L12.16|
00000c  2100              MOVS     r1,#0
00000e  6021              STR      r1,[r4,#0]
                  |L12.16|
;;;2021   	return res;
;;;2022   #endif
;;;2023   }
000010  bd10              POP      {r4,pc}
;;;2024   
                          ENDP


                          AREA ||i.f_getfree||, CODE, READONLY, ALIGN=1

                  f_getfree PROC
;;;2300   
;;;2301   FRESULT f_getfree (
000000  e92d43f7          PUSH     {r0-r2,r4-r9,lr}
;;;2302   	const XCHAR *path,	/* Pointer to the logical drive number (root dir) */
;;;2303   	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
;;;2304   	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
;;;2305   )
;;;2306   {
000004  4614              MOV      r4,r2
000006  4689              MOV      r9,r1
;;;2307   	FRESULT res;
;;;2308   	DWORD n, clst, sect, stat;
;;;2309   	UINT i;
;;;2310   	BYTE fat, *p;
;;;2311   
;;;2312   
;;;2313   	/* Get drive number */
;;;2314   	res = auto_mount(&path, fatfs, 0);
000008  2200              MOVS     r2,#0
00000a  4621              MOV      r1,r4
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       auto_mount
;;;2315   	if (res != FR_OK) LEAVE_FF(*fatfs, res);
000012  2800              CMP      r0,#0
000014  d11c              BNE      |L13.80|
;;;2316   
;;;2317   	/* If number of free cluster is valid, return it without cluster scan. */
;;;2318   	if ((*fatfs)->free_clust <= (*fatfs)->max_clust - 2) {
000016  6820              LDR      r0,[r4,#0]
000018  69c7              LDR      r7,[r0,#0x1c]
00001a  6901              LDR      r1,[r0,#0x10]
00001c  1eba              SUBS     r2,r7,#2
00001e  4291              CMP      r1,r2
000020  d802              BHI      |L13.40|
;;;2319   		*nclst = (*fatfs)->free_clust;
;;;2320   		LEAVE_FF(*fatfs, FR_OK);
000022  f8c91000          STR      r1,[r9,#0]
000026  e04b              B        |L13.192|
                  |L13.40|
;;;2321   	}
;;;2322   
;;;2323   	/* Get number of free clusters */
;;;2324   	fat = (*fatfs)->fs_type;
000028  f8908000          LDRB     r8,[r0,#0]
;;;2325   	n = 0;
00002c  2500              MOVS     r5,#0
;;;2326   	if (fat == FS_FAT12) {
00002e  f1b80f01          CMP      r8,#1
000032  d001              BEQ      |L13.56|
;;;2327   		clst = 2;
;;;2328   		do {
;;;2329   			stat = get_fat(*fatfs, clst);
;;;2330   			if (stat == 0xFFFFFFFF) LEAVE_FF(*fatfs, FR_DISK_ERR);
;;;2331   			if (stat == 1) LEAVE_FF(*fatfs, FR_INT_ERR);
;;;2332   			if (stat == 0) n++;
;;;2333   		} while (++clst < (*fatfs)->max_clust);
;;;2334   	} else {
;;;2335   		clst = (*fatfs)->max_clust;
;;;2336   		sect = (*fatfs)->fatbase;
;;;2337   		i = 0; p = 0;
;;;2338   		do {
000034  6a06              LDR      r6,[r0,#0x20]
000036  e019              B        |L13.108|
                  |L13.56|
000038  2602              MOVS     r6,#2                 ;2327
                  |L13.58|
00003a  4631              MOV      r1,r6                 ;2329
00003c  6820              LDR      r0,[r4,#0]            ;2329
00003e  f7fffffe          BL       get_fat
000042  1c41              ADDS     r1,r0,#1              ;2330
000044  d003              BEQ      |L13.78|
000046  2801              CMP      r0,#1                 ;2331
000048  d004              BEQ      |L13.84|
00004a  b128              CBZ      r0,|L13.88|
00004c  e005              B        |L13.90|
                  |L13.78|
00004e  2001              MOVS     r0,#1                 ;2330
                  |L13.80|
;;;2339   			if (!i) {
;;;2340   				res = move_window(*fatfs, sect++);
;;;2341   				if (res != FR_OK)
;;;2342   					LEAVE_FF(*fatfs, res);
;;;2343   				p = (*fatfs)->win;
;;;2344   				i = SS(*fatfs);
;;;2345   			}
;;;2346   			if (fat == FS_FAT16) {
;;;2347   				if (LD_WORD(p) == 0) n++;
;;;2348   				p += 2; i -= 2;
;;;2349   			} else {
;;;2350   				if (LD_DWORD(p) == 0) n++;
;;;2351   				p += 4; i -= 4;
;;;2352   			}
;;;2353   		} while (--clst);
;;;2354   	}
;;;2355   	(*fatfs)->free_clust = n;
;;;2356   	if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
;;;2357   	*nclst = n;
;;;2358   
;;;2359   	LEAVE_FF(*fatfs, FR_OK);
;;;2360   }
000050  e8bd83fe          POP      {r1-r9,pc}
                  |L13.84|
000054  2002              MOVS     r0,#2                 ;2331
000056  e7fb              B        |L13.80|
                  |L13.88|
000058  1c6d              ADDS     r5,r5,#1              ;2332
                  |L13.90|
00005a  6820              LDR      r0,[r4,#0]            ;2333
00005c  1c76              ADDS     r6,r6,#1              ;2333
00005e  69c0              LDR      r0,[r0,#0x1c]         ;2333
000060  4286              CMP      r6,r0                 ;2333
000062  d3ea              BCC      |L13.58|
000064  6821              LDR      r1,[r4,#0]            ;2355
000066  610d              STR      r5,[r1,#0x10]         ;2356
000068  e028              B        |L13.188|
                  |L13.106|
00006a  b951              CBNZ     r1,|L13.130|
                  |L13.108|
00006c  4631              MOV      r1,r6                 ;2340
00006e  1c76              ADDS     r6,r6,#1              ;2340
000070  6820              LDR      r0,[r4,#0]            ;2340
000072  f7fffffe          BL       move_window
000076  2800              CMP      r0,#0                 ;2341
000078  d1ea              BNE      |L13.80|
00007a  6820              LDR      r0,[r4,#0]            ;2343
00007c  f44f7100          MOV      r1,#0x200             ;2344
000080  3030              ADDS     r0,r0,#0x30           ;2343
                  |L13.130|
000082  f1b80f02          CMP      r8,#2                 ;2346
000086  d006              BEQ      |L13.150|
000088  7802              LDRB     r2,[r0,#0]            ;2350
00008a  f8d03001          LDR      r3,[r0,#1]            ;2350
00008e  ea522203          ORRS     r2,r2,r3,LSL #8       ;2350
000092  d006              BEQ      |L13.162|
000094  e006              B        |L13.164|
                  |L13.150|
000096  8802              LDRH     r2,[r0,#0]            ;2347
000098  b902              CBNZ     r2,|L13.156|
00009a  1c6d              ADDS     r5,r5,#1              ;2347
                  |L13.156|
00009c  1c80              ADDS     r0,r0,#2              ;2348
00009e  1e89              SUBS     r1,r1,#2              ;2348
0000a0  e002              B        |L13.168|
                  |L13.162|
0000a2  1c6d              ADDS     r5,r5,#1              ;2350
                  |L13.164|
0000a4  1d00              ADDS     r0,r0,#4              ;2351
0000a6  1f09              SUBS     r1,r1,#4              ;2351
                  |L13.168|
0000a8  1e7f              SUBS     r7,r7,#1              ;2353
0000aa  d1de              BNE      |L13.106|
0000ac  6821              LDR      r1,[r4,#0]            ;2356
0000ae  f1b80f03          CMP      r8,#3                 ;2356
0000b2  610d              STR      r5,[r1,#0x10]         ;2356
0000b4  d102              BNE      |L13.188|
0000b6  6821              LDR      r1,[r4,#0]            ;2356
0000b8  2001              MOVS     r0,#1                 ;2356
0000ba  7288              STRB     r0,[r1,#0xa]          ;2356
                  |L13.188|
0000bc  f8c95000          STR      r5,[r9,#0]            ;2357
                  |L13.192|
0000c0  2000              MOVS     r0,#0                 ;2359
0000c2  e7c5              B        |L13.80|
;;;2361   
                          ENDP


                          AREA ||i.f_lseek||, CODE, READONLY, ALIGN=1

                  f_lseek PROC
;;;2087   
;;;2088   FRESULT f_lseek (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2089   	FIL *fp,		/* Pointer to the file object */
;;;2090   	DWORD ofs		/* File pointer from top of file */
;;;2091   )
;;;2092   {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;2093   	FRESULT res;
;;;2094   	DWORD clst, bcs, nsect, ifptr;
;;;2095   
;;;2096   
;;;2097   	res = validate(fp->fs, fp->id);		/* Check validity of the object */
000008  8881              LDRH     r1,[r0,#4]
00000a  6800              LDR      r0,[r0,#0]
00000c  f7fffffe          BL       validate
000010  ea5f0800          MOVS     r8,r0
;;;2098   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000014  d103              BNE      |L14.30|
;;;2099   	if (fp->flag & FA__ERROR)			/* Check abort flag */
000016  79a1              LDRB     r1,[r4,#6]
000018  0608              LSLS     r0,r1,#24
00001a  d502              BPL      |L14.34|
                  |L14.28|
;;;2100   		LEAVE_FF(fp->fs, FR_INT_ERR);
00001c  2002              MOVS     r0,#2
                  |L14.30|
;;;2101   	if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
;;;2102   #if !_FS_READONLY
;;;2103   		 && !(fp->flag & FA_WRITE)
;;;2104   #endif
;;;2105   		) ofs = fp->fsize;
;;;2106   
;;;2107   	ifptr = fp->fptr;
;;;2108   	fp->fptr = nsect = 0; fp->csect = 255;
;;;2109   	if (ofs > 0) {
;;;2110   		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
;;;2111   		if (ifptr > 0 &&
;;;2112   			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
;;;2113   			fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
;;;2114   			ofs -= fp->fptr;
;;;2115   			clst = fp->curr_clust;
;;;2116   		} else {									/* When seek to back cluster, */
;;;2117   			clst = fp->org_clust;					/* start from the first cluster */
;;;2118   #if !_FS_READONLY
;;;2119   			if (clst == 0) {						/* If no cluster chain, create a new chain */
;;;2120   				clst = create_chain(fp->fs, 0);
;;;2121   				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;2122   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2123   				fp->org_clust = clst;
;;;2124   			}
;;;2125   #endif
;;;2126   			fp->curr_clust = clst;
;;;2127   		}
;;;2128   		if (clst != 0) {
;;;2129   			while (ofs > bcs) {						/* Cluster following loop */
;;;2130   #if !_FS_READONLY
;;;2131   				if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
;;;2132   					clst = create_chain(fp->fs, clst);	/* Force streached if in write mode */
;;;2133   					if (clst == 0) {				/* When disk gets full, clip file size */
;;;2134   						ofs = bcs; break;
;;;2135   					}
;;;2136   				} else
;;;2137   #endif
;;;2138   					clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
;;;2139   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2140   				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
;;;2141   				fp->curr_clust = clst;
;;;2142   				fp->fptr += bcs;
;;;2143   				ofs -= bcs;
;;;2144   			}
;;;2145   			fp->fptr += ofs;
;;;2146   			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
;;;2147   			if (ofs % SS(fp->fs)) {
;;;2148   				nsect = clust2sect(fp->fs, clst);	/* Current sector */
;;;2149   				if (!nsect) ABORT(fp->fs, FR_INT_ERR);
;;;2150   				nsect += fp->csect;
;;;2151   				fp->csect++;
;;;2152   			}
;;;2153   		}
;;;2154   	}
;;;2155   	if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {
;;;2156   #if !_FS_TINY
;;;2157   #if !_FS_READONLY
;;;2158   		if (fp->flag & FA__DIRTY) {			/* Write-back dirty buffer if needed */
;;;2159   			if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
;;;2160   				ABORT(fp->fs, FR_DISK_ERR);
;;;2161   			fp->flag &= ~FA__DIRTY;
;;;2162   		}
;;;2163   #endif
;;;2164   		if (disk_read(fp->fs->drive, fp->buf, nsect, 1) != RES_OK)
;;;2165   			ABORT(fp->fs, FR_DISK_ERR);
;;;2166   #endif
;;;2167   		fp->dsect = nsect;
;;;2168   	}
;;;2169   #if !_FS_READONLY
;;;2170   	if (fp->fptr > fp->fsize) {			/* Set changed flag if the file size is extended */
;;;2171   		fp->fsize = fp->fptr;
;;;2172   		fp->flag |= FA__WRITTEN;
;;;2173   	}
;;;2174   #endif
;;;2175   
;;;2176   	LEAVE_FF(fp->fs, res);
;;;2177   }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L14.34|
000022  68e0              LDR      r0,[r4,#0xc]          ;2101
000024  42a8              CMP      r0,r5                 ;2101
000026  d202              BCS      |L14.46|
000028  0789              LSLS     r1,r1,#30             ;2103
00002a  d400              BMI      |L14.46|
00002c  4605              MOV      r5,r0                 ;2105
                  |L14.46|
00002e  2700              MOVS     r7,#0                 ;2108
000030  68a0              LDR      r0,[r4,#8]            ;2108
000032  21ff              MOVS     r1,#0xff              ;2108
000034  60a7              STR      r7,[r4,#8]            ;2108
000036  71e1              STRB     r1,[r4,#7]            ;2108
000038  b305              CBZ      r5,|L14.124|
00003a  6822              LDR      r2,[r4,#0]            ;2110
00003c  7891              LDRB     r1,[r2,#2]            ;2110
00003e  ea4f2641          LSL      r6,r1,#9              ;2110
000042  b168              CBZ      r0,|L14.96|
000044  1e69              SUBS     r1,r5,#1              ;2112
000046  1e40              SUBS     r0,r0,#1              ;2112
000048  fbb1f1f6          UDIV     r1,r1,r6              ;2112
00004c  fbb0f3f6          UDIV     r3,r0,r6              ;2112
000050  4299              CMP      r1,r3                 ;2112
000052  d305              BCC      |L14.96|
000054  1e71              SUBS     r1,r6,#1              ;2113
000056  4388              BICS     r0,r0,r1              ;2113
000058  60a0              STR      r0,[r4,#8]            ;2115
00005a  1a2d              SUBS     r5,r5,r0              ;2114
00005c  6961              LDR      r1,[r4,#0x14]         ;2115
00005e  e00c              B        |L14.122|
                  |L14.96|
000060  6921              LDR      r1,[r4,#0x10]         ;2119
000062  b949              CBNZ     r1,|L14.120|
000064  2100              MOVS     r1,#0                 ;2120
000066  4610              MOV      r0,r2                 ;2120
000068  f7fffffe          BL       create_chain
00006c  4601              MOV      r1,r0                 ;2120
00006e  2801              CMP      r0,#1                 ;2121
000070  d043              BEQ      |L14.250|
000072  1c48              ADDS     r0,r1,#1              ;2122
000074  d052              BEQ      |L14.284|
000076  6121              STR      r1,[r4,#0x10]         ;2123
                  |L14.120|
000078  6161              STR      r1,[r4,#0x14]         ;2126
                  |L14.122|
00007a  b9d1              CBNZ     r1,|L14.178|
                  |L14.124|
00007c  e02a              B        |L14.212|
                  |L14.126|
00007e  79a0              LDRB     r0,[r4,#6]            ;2131
000080  0780              LSLS     r0,r0,#30             ;2131
000082  6820              LDR      r0,[r4,#0]            ;2131
000084  d505              BPL      |L14.146|
000086  f7fffffe          BL       create_chain
00008a  0001              MOVS     r1,r0                 ;2132
00008c  d104              BNE      |L14.152|
00008e  4635              MOV      r5,r6                 ;2134
000090  e011              B        |L14.182|
                  |L14.146|
000092  f7fffffe          BL       get_fat
000096  4601              MOV      r1,r0                 ;2138
                  |L14.152|
000098  1c48              ADDS     r0,r1,#1              ;2139
00009a  d03f              BEQ      |L14.284|
00009c  2901              CMP      r1,#1                 ;2140
00009e  d92c              BLS      |L14.250|
0000a0  6820              LDR      r0,[r4,#0]            ;2140
0000a2  69c0              LDR      r0,[r0,#0x1c]         ;2140
0000a4  4288              CMP      r0,r1                 ;2140
0000a6  d928              BLS      |L14.250|
0000a8  6161              STR      r1,[r4,#0x14]         ;2142
0000aa  68a0              LDR      r0,[r4,#8]            ;2142
0000ac  1bad              SUBS     r5,r5,r6              ;2143
0000ae  4430              ADD      r0,r0,r6              ;2142
0000b0  60a0              STR      r0,[r4,#8]            ;2142
                  |L14.178|
0000b2  42b5              CMP      r5,r6                 ;2129
0000b4  d8e3              BHI      |L14.126|
                  |L14.182|
0000b6  68a0              LDR      r0,[r4,#8]            ;2145
0000b8  0a6a              LSRS     r2,r5,#9              ;2146
0000ba  4428              ADD      r0,r0,r5              ;2145
0000bc  60a0              STR      r0,[r4,#8]            ;2146
0000be  71e2              STRB     r2,[r4,#7]            ;2146
0000c0  05e8              LSLS     r0,r5,#23             ;2147
0000c2  d007              BEQ      |L14.212|
0000c4  6820              LDR      r0,[r4,#0]            ;2148
0000c6  f7fffffe          BL       clust2sect
0000ca  b1b0              CBZ      r0,|L14.250|
0000cc  79e1              LDRB     r1,[r4,#7]            ;2150
0000ce  1c4a              ADDS     r2,r1,#1              ;2151
0000d0  71e2              STRB     r2,[r4,#7]            ;2151
0000d2  180f              ADDS     r7,r1,r0              ;2150
                  |L14.212|
0000d4  68a0              LDR      r0,[r4,#8]            ;2155
0000d6  05c0              LSLS     r0,r0,#23             ;2155
0000d8  d027              BEQ      |L14.298|
0000da  69a2              LDR      r2,[r4,#0x18]         ;2155
0000dc  42ba              CMP      r2,r7                 ;2155
0000de  d024              BEQ      |L14.298|
0000e0  79a0              LDRB     r0,[r4,#6]            ;2158
0000e2  f1040524          ADD      r5,r4,#0x24           ;2159
0000e6  0640              LSLS     r0,r0,#25             ;2158
0000e8  d510              BPL      |L14.268|
0000ea  6820              LDR      r0,[r4,#0]            ;2159
0000ec  2301              MOVS     r3,#1                 ;2159
0000ee  4629              MOV      r1,r5                 ;2159
0000f0  7840              LDRB     r0,[r0,#1]            ;2159
0000f2  f7fffffe          BL       disk_write
0000f6  b988              CBNZ     r0,|L14.284|
0000f8  e004              B        |L14.260|
                  |L14.250|
0000fa  79a0              LDRB     r0,[r4,#6]            ;2149
0000fc  f0400080          ORR      r0,r0,#0x80           ;2149
000100  71a0              STRB     r0,[r4,#6]            ;2149
000102  e78b              B        |L14.28|
                  |L14.260|
000104  79a0              LDRB     r0,[r4,#6]            ;2161
000106  f0200040          BIC      r0,r0,#0x40           ;2161
00010a  71a0              STRB     r0,[r4,#6]            ;2161
                  |L14.268|
00010c  6820              LDR      r0,[r4,#0]            ;2164
00010e  2301              MOVS     r3,#1                 ;2164
000110  463a              MOV      r2,r7                 ;2164
000112  7840              LDRB     r0,[r0,#1]            ;2164
000114  4629              MOV      r1,r5                 ;2164
000116  f7fffffe          BL       disk_read
00011a  b128              CBZ      r0,|L14.296|
                  |L14.284|
00011c  79a0              LDRB     r0,[r4,#6]            ;2165
00011e  f0400080          ORR      r0,r0,#0x80           ;2165
000122  71a0              STRB     r0,[r4,#6]            ;2165
000124  2001              MOVS     r0,#1                 ;2165
000126  e77a              B        |L14.30|
                  |L14.296|
000128  61a7              STR      r7,[r4,#0x18]         ;2167
                  |L14.298|
00012a  e9d40102          LDRD     r0,r1,[r4,#8]         ;2167
00012e  4288              CMP      r0,r1                 ;2170
000130  d904              BLS      |L14.316|
000132  60e0              STR      r0,[r4,#0xc]          ;2172
000134  79a0              LDRB     r0,[r4,#6]            ;2172
000136  f0400020          ORR      r0,r0,#0x20           ;2172
00013a  71a0              STRB     r0,[r4,#6]            ;2172
                  |L14.316|
00013c  4640              MOV      r0,r8                 ;2176
00013e  e76e              B        |L14.30|
;;;2178   
                          ENDP


                          AREA ||i.f_mkdir||, CODE, READONLY, ALIGN=1

                  f_mkdir PROC
;;;2467   
;;;2468   FRESULT f_mkdir (
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;2469   	const XCHAR *path		/* Pointer to the directory path */
;;;2470   )
;;;2471   {
000004  b08e              SUB      sp,sp,#0x38
;;;2472   	FRESULT res;
;;;2473   	DIR dj;
;;;2474   	NAMEBUF(sfn, lfn);
;;;2475   	BYTE *dir, n;
;;;2476   	DWORD dsect, dclst, pclst, tim;
;;;2477   
;;;2478   
;;;2479   	res = auto_mount(&path, &dj.fs, 1);
000006  2201              MOVS     r2,#1
000008  4669              MOV      r1,sp
00000a  a80e              ADD      r0,sp,#0x38
00000c  f7fffffe          BL       auto_mount
;;;2480   	if (res != FR_OK) LEAVE_FF(dj.fs, res);
000010  2800              CMP      r0,#0
000012  d114              BNE      |L15.62|
;;;2481   
;;;2482   	INITBUF(dj, sfn, lfn);
000014  a80b              ADD      r0,sp,#0x2c
;;;2483   	res = follow_path(&dj, path);			/* Follow the file path */
000016  9006              STR      r0,[sp,#0x18]
000018  4668              MOV      r0,sp
00001a  990e              LDR      r1,[sp,#0x38]
00001c  f7fffffe          BL       follow_path
;;;2484   	if (res == FR_OK) res = FR_EXIST;		/* Any file or directory is already existing */
000020  b160              CBZ      r0,|L15.60|
;;;2485   	if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[11] & NS_DOT))
;;;2486   		res = FR_INVALID_NAME;
;;;2487   	if (res != FR_NO_FILE)					/* Any error occured */
000022  2804              CMP      r0,#4
000024  d10b              BNE      |L15.62|
;;;2488   		LEAVE_FF(dj.fs, res);
;;;2489   
;;;2490   	dclst = create_chain(dj.fs, 0);			/* Allocate a new cluster for new directory table */
000026  2100              MOVS     r1,#0
000028  9800              LDR      r0,[sp,#0]
00002a  f7fffffe          BL       create_chain
00002e  0005              MOVS     r5,r0
;;;2491   	res = FR_OK;
000030  f04f0000          MOV      r0,#0
;;;2492   	if (dclst == 0) res = FR_DENIED;
000034  d006              BEQ      |L15.68|
;;;2493   	if (dclst == 1) res = FR_INT_ERR;
000036  2d01              CMP      r5,#1
000038  d053              BEQ      |L15.226|
00003a  e004              B        |L15.70|
                  |L15.60|
00003c  2008              MOVS     r0,#8                 ;2484
                  |L15.62|
;;;2494   	if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
;;;2495   	if (res == FR_OK)
;;;2496   		res = move_window(dj.fs, 0);
;;;2497   	if (res != FR_OK) LEAVE_FF(dj.fs, res);
;;;2498   	dsect = clust2sect(dj.fs, dclst);
;;;2499   
;;;2500   	dir = dj.fs->win;						/* Initialize the new directory table */
;;;2501   	mem_set(dir, 0, SS(dj.fs));
;;;2502   	mem_set(dir+DIR_Name, ' ', 8+3);		/* Create "." entry */
;;;2503   	dir[DIR_Name] = '.';
;;;2504   	dir[DIR_Attr] = AM_DIR;
;;;2505   	tim = get_fattime();
;;;2506   	ST_DWORD(dir+DIR_WrtTime, tim);
;;;2507   	ST_WORD(dir+DIR_FstClusLO, dclst);
;;;2508   	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
;;;2509   	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
;;;2510   	dir[33] = '.';
;;;2511   	pclst = dj.sclust;
;;;2512   	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
;;;2513   		pclst = 0;
;;;2514   	ST_WORD(dir+32+DIR_FstClusLO, pclst);
;;;2515   	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
;;;2516   	for (n = 0; n < dj.fs->csize; n++) {	/* Write dot entries and clear left sectors */
;;;2517   		dj.fs->winsect = dsect++;
;;;2518   		dj.fs->wflag = 1;
;;;2519   		res = move_window(dj.fs, 0);
;;;2520   		if (res) LEAVE_FF(dj.fs, res);
;;;2521   		mem_set(dir, 0, SS(dj.fs));
;;;2522   	}
;;;2523   
;;;2524   	res = dir_register(&dj);
;;;2525   	if (res != FR_OK) {
;;;2526   		remove_chain(dj.fs, dclst);
;;;2527   	} else {
;;;2528   		dir = dj.dir;
;;;2529   		dir[DIR_Attr] = AM_DIR;					/* Attribute */
;;;2530   		ST_DWORD(dir+DIR_WrtTime, tim);			/* Crated time */
;;;2531   		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
;;;2532   		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
;;;2533   		dj.fs->wflag = 1;
;;;2534   		res = sync(dj.fs);
;;;2535   	}
;;;2536   
;;;2537   	LEAVE_FF(dj.fs, res);
;;;2538   }
00003e  b00f              ADD      sp,sp,#0x3c
000040  e8bd8ff0          POP      {r4-r11,pc}
                  |L15.68|
000044  2007              MOVS     r0,#7                 ;2492
                  |L15.70|
000046  1c69              ADDS     r1,r5,#1              ;2494
000048  d04d              BEQ      |L15.230|
00004a  2800              CMP      r0,#0                 ;2495
00004c  d1f7              BNE      |L15.62|
00004e  2100              MOVS     r1,#0                 ;2496
000050  9800              LDR      r0,[sp,#0]            ;2496
000052  f7fffffe          BL       move_window
000056  2800              CMP      r0,#0                 ;2497
000058  d1f1              BNE      |L15.62|
00005a  4629              MOV      r1,r5                 ;2498
00005c  9800              LDR      r0,[sp,#0]            ;2498
00005e  f7fffffe          BL       clust2sect
000062  9c00              LDR      r4,[sp,#0]            ;2500
000064  4606              MOV      r6,r0                 ;2498
000066  3430              ADDS     r4,r4,#0x30           ;2500
000068  f44f7200          MOV      r2,#0x200             ;2501
00006c  2100              MOVS     r1,#0                 ;2501
00006e  4620              MOV      r0,r4                 ;2501
000070  f7fffffe          BL       mem_set
000074  220b              MOVS     r2,#0xb               ;2502
000076  2120              MOVS     r1,#0x20              ;2502
000078  4620              MOV      r0,r4                 ;2502
00007a  f7fffffe          BL       mem_set
00007e  272e              MOVS     r7,#0x2e              ;2503
000080  7027              STRB     r7,[r4,#0]            ;2503
000082  2010              MOVS     r0,#0x10              ;2504
000084  72e0              STRB     r0,[r4,#0xb]          ;2504
000086  f7fffffe          BL       get_fattime
00008a  f0000bff          AND      r11,r0,#0xff          ;2506
00008e  f3c02807          UBFX     r8,r0,#8,#8           ;2506
000092  f884b016          STRB     r11,[r4,#0x16]        ;2506
000096  f3c04107          UBFX     r1,r0,#16,#8          ;2506
00009a  f8848017          STRB     r8,[r4,#0x17]         ;2506
00009e  9107              STR      r1,[sp,#0x1c]         ;2506
0000a0  7621              STRB     r1,[r4,#0x18]         ;2506
0000a2  0e00              LSRS     r0,r0,#24             ;2506
0000a4  9008              STR      r0,[sp,#0x20]         ;2506
0000a6  7660              STRB     r0,[r4,#0x19]         ;2506
0000a8  b2e8              UXTB     r0,r5                 ;2507
0000aa  9009              STR      r0,[sp,#0x24]         ;2507
0000ac  76a0              STRB     r0,[r4,#0x1a]         ;2507
0000ae  f3c52007          UBFX     r0,r5,#8,#8           ;2507
0000b2  900a              STR      r0,[sp,#0x28]         ;2507
0000b4  76e0              STRB     r0,[r4,#0x1b]         ;2507
0000b6  f3c54a07          UBFX     r10,r5,#16,#8         ;2508
0000ba  f884a014          STRB     r10,[r4,#0x14]        ;2508
0000be  ea4f6915          LSR      r9,r5,#24             ;2508
0000c2  f8849015          STRB     r9,[r4,#0x15]         ;2508
0000c6  2220              MOVS     r2,#0x20              ;2509
0000c8  4621              MOV      r1,r4                 ;2509
0000ca  f1040020          ADD      r0,r4,#0x20           ;2509
0000ce  f7fffffe          BL       mem_cpy
0000d2  f8847021          STRB     r7,[r4,#0x21]         ;2510
0000d6  9900              LDR      r1,[sp,#0]            ;2512
0000d8  9802              LDR      r0,[sp,#8]            ;2512
0000da  7809              LDRB     r1,[r1,#0]            ;2512
0000dc  2903              CMP      r1,#3                 ;2512
0000de  d004              BEQ      |L15.234|
0000e0  e008              B        |L15.244|
                  |L15.226|
0000e2  2002              MOVS     r0,#2                 ;2493
0000e4  e7ab              B        |L15.62|
                  |L15.230|
0000e6  2001              MOVS     r0,#1                 ;2494
0000e8  e7a9              B        |L15.62|
                  |L15.234|
0000ea  9900              LDR      r1,[sp,#0]            ;2512
0000ec  6a49              LDR      r1,[r1,#0x24]         ;2512
0000ee  4281              CMP      r1,r0                 ;2512
0000f0  d100              BNE      |L15.244|
0000f2  2000              MOVS     r0,#0                 ;2513
                  |L15.244|
0000f4  f1040434          ADD      r4,r4,#0x34           ;2513
0000f8  ea4f2110          LSR      r1,r0,#8              ;2514
0000fc  71a0              STRB     r0,[r4,#6]            ;2514
0000fe  71e1              STRB     r1,[r4,#7]            ;2514
000100  ea4f4110          LSR      r1,r0,#16             ;2515
000104  7021              STRB     r1,[r4,#0]            ;2515
000106  ea4f6010          LSR      r0,r0,#24             ;2515
00010a  7060              STRB     r0,[r4,#1]            ;2515
00010c  f1a40434          SUB      r4,r4,#0x34           ;2515
000110  f04f0700          MOV      r7,#0                 ;2516
000114  e013              B        |L15.318|
                  |L15.278|
000116  9800              LDR      r0,[sp,#0]            ;2517
000118  62c6              STR      r6,[r0,#0x2c]         ;2517
00011a  9900              LDR      r1,[sp,#0]            ;2518
00011c  2001              MOVS     r0,#1                 ;2518
00011e  1c76              ADDS     r6,r6,#1              ;2517
000120  7108              STRB     r0,[r1,#4]            ;2518
000122  2100              MOVS     r1,#0                 ;2519
000124  9800              LDR      r0,[sp,#0]            ;2519
000126  f7fffffe          BL       move_window
00012a  2800              CMP      r0,#0                 ;2520
00012c  d187              BNE      |L15.62|
00012e  f44f7200          MOV      r2,#0x200             ;2521
000132  2100              MOVS     r1,#0                 ;2521
000134  4620              MOV      r0,r4                 ;2521
000136  f7fffffe          BL       mem_set
00013a  1c7f              ADDS     r7,r7,#1              ;2516
00013c  b2ff              UXTB     r7,r7                 ;2516
                  |L15.318|
00013e  9800              LDR      r0,[sp,#0]            ;2516
000140  7880              LDRB     r0,[r0,#2]            ;2516
000142  42b8              CMP      r0,r7                 ;2516
000144  d8e7              BHI      |L15.278|
000146  4668              MOV      r0,sp                 ;2524
000148  f7fffffe          BL       dir_register
00014c  0004              MOVS     r4,r0                 ;2524
00014e  d004              BEQ      |L15.346|
000150  4629              MOV      r1,r5                 ;2526
000152  9800              LDR      r0,[sp,#0]            ;2526
000154  f7fffffe          BL       remove_chain
000158  e019              B        |L15.398|
                  |L15.346|
00015a  9805              LDR      r0,[sp,#0x14]         ;2529
00015c  2110              MOVS     r1,#0x10              ;2529
00015e  72c1              STRB     r1,[r0,#0xb]          ;2529
000160  f880b016          STRB     r11,[r0,#0x16]        ;2530
000164  f8808017          STRB     r8,[r0,#0x17]         ;2530
000168  9907              LDR      r1,[sp,#0x1c]         ;2530
00016a  7601              STRB     r1,[r0,#0x18]         ;2530
00016c  9908              LDR      r1,[sp,#0x20]         ;2530
00016e  7641              STRB     r1,[r0,#0x19]         ;2530
000170  9909              LDR      r1,[sp,#0x24]         ;2531
000172  7681              STRB     r1,[r0,#0x1a]         ;2531
000174  990a              LDR      r1,[sp,#0x28]         ;2531
000176  76c1              STRB     r1,[r0,#0x1b]         ;2531
000178  f880a014          STRB     r10,[r0,#0x14]        ;2532
00017c  f8809015          STRB     r9,[r0,#0x15]         ;2532
000180  9900              LDR      r1,[sp,#0]            ;2533
000182  2001              MOVS     r0,#1                 ;2533
000184  7108              STRB     r0,[r1,#4]            ;2533
000186  9800              LDR      r0,[sp,#0]            ;2534
000188  f7fffffe          BL       sync
00018c  4604              MOV      r4,r0                 ;2534
                  |L15.398|
00018e  4620              MOV      r0,r4                 ;2537
000190  e755              B        |L15.62|
;;;2539   
                          ENDP


                          AREA ||i.f_mount||, CODE, READONLY, ALIGN=2

                  f_mount PROC
;;;1613   
;;;1614   FRESULT f_mount (
000000  b108              CBZ      r0,|L16.6|
;;;1615   	BYTE vol,		/* Logical drive number to be mounted/unmounted */
;;;1616   	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
;;;1617   )
;;;1618   {
;;;1619   	FATFS *rfs;
;;;1620   
;;;1621   
;;;1622   	if (vol >= _DRIVES)				/* Check if the drive number is valid */
;;;1623   		return FR_INVALID_DRIVE;
000002  200b              MOVS     r0,#0xb
;;;1624   	rfs = FatFs[vol];				/* Get current fs object */
;;;1625   
;;;1626   	if (rfs) {
;;;1627   #if _FS_REENTRANT					/* Discard sync object of the current volume */
;;;1628   		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
;;;1629   #endif
;;;1630   		rfs->fs_type = 0;			/* Clear old fs object */
;;;1631   	}
;;;1632   
;;;1633   	if (fs) {
;;;1634   		fs->fs_type = 0;			/* Clear new fs object */
;;;1635   #if _FS_REENTRANT					/* Create sync object for the new volume */
;;;1636   		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
;;;1637   #endif
;;;1638   	}
;;;1639   	FatFs[vol] = fs;				/* Register new fs object */
;;;1640   
;;;1641   	return FR_OK;
;;;1642   }
000004  4770              BX       lr
                  |L16.6|
000006  4a05              LDR      r2,|L16.28|
000008  2300              MOVS     r3,#0                 ;1618
00000a  6810              LDR      r0,[r2,#0]            ;1626
00000c  b100              CBZ      r0,|L16.16|
00000e  7003              STRB     r3,[r0,#0]            ;1630
                  |L16.16|
000010  b101              CBZ      r1,|L16.20|
000012  700b              STRB     r3,[r1,#0]            ;1634
                  |L16.20|
000014  2000              MOVS     r0,#0                 ;1641
000016  6011              STR      r1,[r2,#0]            ;1641
000018  4770              BX       lr
;;;1643   
                          ENDP

00001a  0000              DCW      0x0000
                  |L16.28|
                          DCD      ||.data||+0x4

                          AREA ||i.f_open||, CODE, READONLY, ALIGN=1

                  f_open PROC
;;;1650   
;;;1651   FRESULT f_open (
000000  e92d47f7          PUSH     {r0-r2,r4-r10,lr}
;;;1652   	FIL *fp,			/* Pointer to the blank file object */
;;;1653   	const XCHAR *path,	/* Pointer to the file name */
;;;1654   	BYTE mode			/* Access mode and file open mode flags */
;;;1655   )
;;;1656   {
000004  b08b              SUB      sp,sp,#0x2c
;;;1657   	FRESULT res;
;;;1658   	DIR dj;
;;;1659   	NAMEBUF(sfn, lfn);
;;;1660   	BYTE *dir;
;;;1661   
;;;1662   
;;;1663   	fp->fs = NULL;		/* Clear file object */
000006  f04f0800          MOV      r8,#0
00000a  4606              MOV      r6,r0                 ;1656
;;;1664   #if !_FS_READONLY
;;;1665   	mode &= (FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW);
00000c  f002051f          AND      r5,r2,#0x1f
;;;1666   	res = auto_mount(&path, &dj.fs, (BYTE)(mode & (FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)));
000010  f8c08000          STR      r8,[r0,#0]
000014  f005021e          AND      r2,r5,#0x1e
000018  4669              MOV      r1,sp
00001a  a80c              ADD      r0,sp,#0x30
00001c  f7fffffe          BL       auto_mount
;;;1667   #else
;;;1668   	mode &= FA_READ;
;;;1669   	res = auto_mount(&path, &dj.fs, 0);
;;;1670   #endif
;;;1671   	if (res != FR_OK) LEAVE_FF(dj.fs, res);
000020  2800              CMP      r0,#0
000022  d11b              BNE      |L17.92|
;;;1672   	INITBUF(dj, sfn, lfn);
000024  a807              ADD      r0,sp,#0x1c
;;;1673   	res = follow_path(&dj, path);	/* Follow the file path */
000026  9006              STR      r0,[sp,#0x18]
000028  4668              MOV      r0,sp
00002a  990c              LDR      r1,[sp,#0x30]
00002c  f7fffffe          BL       follow_path
;;;1674   
;;;1675   #if !_FS_READONLY
;;;1676   	/* Create or Open a file */
;;;1677   	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
000030  f0150f1c          TST      r5,#0x1c
000034  d05d              BEQ      |L17.242|
;;;1678   		DWORD ps, cl;
;;;1679   
;;;1680   		if (res != FR_OK) {			/* No file, create new */
;;;1681   			if (res == FR_NO_FILE)	/* There is no file to open, create a new entry */
;;;1682   				res = dir_register(&dj);
;;;1683   			if (res != FR_OK) LEAVE_FF(dj.fs, res);
;;;1684   			mode |= FA_CREATE_ALWAYS;
;;;1685   			dir = dj.dir;			/* Created entry (SFN entry) */
;;;1686   		}
;;;1687   		else {						/* Any object is already existing */
;;;1688   			if (mode & FA_CREATE_NEW)			/* Cannot create new */
;;;1689   				LEAVE_FF(dj.fs, FR_EXIST);
;;;1690   			dir = dj.dir;
;;;1691   			if (!dir || (dir[DIR_Attr] & (AM_RDO | AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
;;;1692   				LEAVE_FF(dj.fs, FR_DENIED);
;;;1693   			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero on over write mode */
;;;1694   				cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);	/* Get start cluster */
;;;1695   				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
;;;1696   				ST_WORD(dir+DIR_FstClusLO, 0);
;;;1697   				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
;;;1698   				dj.fs->wflag = 1;
000036  f04f0901          MOV      r9,#1
00003a  b160              CBZ      r0,|L17.86|
00003c  2804              CMP      r0,#4                 ;1681
00003e  d10d              BNE      |L17.92|
000040  4668              MOV      r0,sp                 ;1682
000042  f7fffffe          BL       dir_register
000046  2800              CMP      r0,#0                 ;1683
000048  d108              BNE      |L17.92|
00004a  f0450508          ORR      r5,r5,#8              ;1684
;;;1699   				ps = dj.fs->winsect;			/* Remove the cluster chain */
;;;1700   				if (cl) {
;;;1701   					res = remove_chain(dj.fs, cl);
;;;1702   					if (res) LEAVE_FF(dj.fs, res);
;;;1703   					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
;;;1704   				}
;;;1705   				res = move_window(dj.fs, ps);
;;;1706   				if (res != FR_OK) LEAVE_FF(dj.fs, res);
;;;1707   			}
;;;1708   		}
;;;1709   		if (mode & FA_CREATE_ALWAYS) {
00004e  9c05              LDR      r4,[sp,#0x14]
000050  0728              LSLS     r0,r5,#28
000052  d438              BMI      |L17.198|
000054  e05c              B        |L17.272|
                  |L17.86|
000056  0768              LSLS     r0,r5,#29             ;1688
000058  d503              BPL      |L17.98|
00005a  2008              MOVS     r0,#8                 ;1689
                  |L17.92|
;;;1710   			dir[DIR_Attr] = 0;					/* Reset attribute */
;;;1711   			ps = get_fattime();
;;;1712   			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
;;;1713   			dj.fs->wflag = 1;
;;;1714   			mode |= FA__WRITTEN;				/* Set file changed flag */
;;;1715   		}
;;;1716   	}
;;;1717   	/* Open an existing file */
;;;1718   	else {
;;;1719   #endif /* !_FS_READONLY */
;;;1720   		if (res != FR_OK) LEAVE_FF(dj.fs, res);	/* Follow failed */
;;;1721   		dir = dj.dir;
;;;1722   		if (!dir || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
;;;1723   			LEAVE_FF(dj.fs, FR_NO_FILE);
;;;1724   #if !_FS_READONLY
;;;1725   		if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
;;;1726   			LEAVE_FF(dj.fs, FR_DENIED);
;;;1727   	}
;;;1728   	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
;;;1729   	fp->dir_ptr = dj.dir;
;;;1730   #endif
;;;1731   	fp->flag = mode;					/* File access mode */
;;;1732   	fp->org_clust =						/* File start cluster */
;;;1733   		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
;;;1734   	fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
;;;1735   	fp->fptr = 0; fp->csect = 255;		/* File pointer */
;;;1736   	fp->dsect = 0;
;;;1737   	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
;;;1738   
;;;1739   	LEAVE_FF(dj.fs, FR_OK);
;;;1740   }
00005c  b00e              ADD      sp,sp,#0x38
00005e  e8bd87f0          POP      {r4-r10,pc}
                  |L17.98|
000062  9c05              LDR      r4,[sp,#0x14]         ;1691
000064  b3f4              CBZ      r4,|L17.228|
000066  7ae0              LDRB     r0,[r4,#0xb]          ;1691
000068  f0100f11          TST      r0,#0x11              ;1691
00006c  d14e              BNE      |L17.268|
00006e  0728              LSLS     r0,r5,#28             ;1693
000070  d54e              BPL      |L17.272|
000072  8aa0              LDRH     r0,[r4,#0x14]         ;1694
000074  8b67              LDRH     r7,[r4,#0x1a]         ;1694
000076  f8848014          STRB     r8,[r4,#0x14]         ;1695
00007a  f8848015          STRB     r8,[r4,#0x15]         ;1695
00007e  f884801a          STRB     r8,[r4,#0x1a]         ;1696
000082  f884801b          STRB     r8,[r4,#0x1b]         ;1696
000086  f884801c          STRB     r8,[r4,#0x1c]         ;1697
00008a  f884801d          STRB     r8,[r4,#0x1d]         ;1697
00008e  f884801e          STRB     r8,[r4,#0x1e]         ;1697
000092  f884801f          STRB     r8,[r4,#0x1f]         ;1697
000096  9900              LDR      r1,[sp,#0]            ;1698
000098  f360471f          BFI      r7,r0,#16,#16         ;1694
00009c  f8819004          STRB     r9,[r1,#4]            ;1698
0000a0  9800              LDR      r0,[sp,#0]            ;1699
0000a2  f8d0a02c          LDR      r10,[r0,#0x2c]        ;1700
0000a6  b147              CBZ      r7,|L17.186|
0000a8  4639              MOV      r1,r7                 ;1701
0000aa  9800              LDR      r0,[sp,#0]            ;1701
0000ac  f7fffffe          BL       remove_chain
0000b0  2800              CMP      r0,#0                 ;1702
0000b2  d1d3              BNE      |L17.92|
0000b4  9800              LDR      r0,[sp,#0]            ;1703
0000b6  1e7f              SUBS     r7,r7,#1              ;1703
0000b8  60c7              STR      r7,[r0,#0xc]          ;1703
                  |L17.186|
0000ba  4651              MOV      r1,r10                ;1705
0000bc  9800              LDR      r0,[sp,#0]            ;1705
0000be  f7fffffe          BL       move_window
0000c2  2800              CMP      r0,#0                 ;1706
0000c4  d1ca              BNE      |L17.92|
                  |L17.198|
0000c6  f884800b          STRB     r8,[r4,#0xb]          ;1710
0000ca  f7fffffe          BL       get_fattime
0000ce  73a0              STRB     r0,[r4,#0xe]          ;1712
0000d0  ea4f2110          LSR      r1,r0,#8              ;1712
0000d4  73e1              STRB     r1,[r4,#0xf]          ;1712
0000d6  ea4f4110          LSR      r1,r0,#16             ;1712
0000da  7421              STRB     r1,[r4,#0x10]         ;1712
0000dc  ea4f6010          LSR      r0,r0,#24             ;1712
0000e0  7460              STRB     r0,[r4,#0x11]         ;1712
0000e2  e000              B        |L17.230|
                  |L17.228|
0000e4  e012              B        |L17.268|
                  |L17.230|
0000e6  9900              LDR      r1,[sp,#0]            ;1713
0000e8  f0450520          ORR      r5,r5,#0x20           ;1714
0000ec  f8819004          STRB     r9,[r1,#4]            ;1713
0000f0  e00e              B        |L17.272|
                  |L17.242|
0000f2  2800              CMP      r0,#0                 ;1720
0000f4  d1b2              BNE      |L17.92|
0000f6  9c05              LDR      r4,[sp,#0x14]         ;1722
0000f8  b114              CBZ      r4,|L17.256|
0000fa  7ae0              LDRB     r0,[r4,#0xb]          ;1722
0000fc  06c1              LSLS     r1,r0,#27             ;1722
0000fe  d501              BPL      |L17.260|
                  |L17.256|
000100  2004              MOVS     r0,#4                 ;1723
000102  e7ab              B        |L17.92|
                  |L17.260|
000104  07a9              LSLS     r1,r5,#30             ;1725
000106  d503              BPL      |L17.272|
000108  07c0              LSLS     r0,r0,#31             ;1725
00010a  d001              BEQ      |L17.272|
                  |L17.268|
00010c  2007              MOVS     r0,#7                 ;1726
00010e  e7a5              B        |L17.92|
                  |L17.272|
000110  9800              LDR      r0,[sp,#0]            ;1728
000112  6ac0              LDR      r0,[r0,#0x2c]         ;1728
000114  61f0              STR      r0,[r6,#0x1c]         ;1729
000116  9805              LDR      r0,[sp,#0x14]         ;1729
000118  6230              STR      r0,[r6,#0x20]         ;1731
00011a  71b5              STRB     r5,[r6,#6]            ;1731
00011c  8aa1              LDRH     r1,[r4,#0x14]         ;1732
00011e  8b60              LDRH     r0,[r4,#0x1a]         ;1732
000120  f361401f          BFI      r0,r1,#16,#16         ;1732
000124  6130              STR      r0,[r6,#0x10]         ;1734
000126  7f20              LDRB     r0,[r4,#0x1c]         ;1734
000128  f8d4101d          LDR      r1,[r4,#0x1d]         ;1734
00012c  ea402001          ORR      r0,r0,r1,LSL #8       ;1734
000130  e9c68002          STRD     r8,r0,[r6,#8]         ;1735
000134  21ff              MOVS     r1,#0xff              ;1735
000136  71f1              STRB     r1,[r6,#7]            ;1735
000138  f8c68018          STR      r8,[r6,#0x18]         ;1737
00013c  9800              LDR      r0,[sp,#0]            ;1737
00013e  6030              STR      r0,[r6,#0]            ;1737
000140  9800              LDR      r0,[sp,#0]            ;1737
000142  88c0              LDRH     r0,[r0,#6]            ;1737
000144  80b0              STRH     r0,[r6,#4]            ;1737
000146  2000              MOVS     r0,#0                 ;1739
000148  e788              B        |L17.92|
;;;1741   
                          ENDP


                          AREA ||i.f_opendir||, CODE, READONLY, ALIGN=1

                  f_opendir PROC
;;;2186   
;;;2187   FRESULT f_opendir (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;2188   	DIR *dj,			/* Pointer to directory object to create */
;;;2189   	const XCHAR *path	/* Pointer to the directory path */
;;;2190   )
;;;2191   {
000002  b084              SUB      sp,sp,#0x10
000004  4604              MOV      r4,r0
;;;2192   	FRESULT res;
;;;2193   	NAMEBUF(sfn, lfn);
;;;2194   	BYTE *dir;
;;;2195   
;;;2196   
;;;2197   	res = auto_mount(&path, &dj->fs, 0);
000006  4601              MOV      r1,r0
000008  2200              MOVS     r2,#0
00000a  a805              ADD      r0,sp,#0x14
00000c  f7fffffe          BL       auto_mount
;;;2198   	if (res == FR_OK) {
000010  2800              CMP      r0,#0
000012  d11a              BNE      |L18.74|
;;;2199   		INITBUF((*dj), sfn, lfn);
000014  f8c4d018          STR      sp,[r4,#0x18]
;;;2200   		res = follow_path(dj, path);			/* Follow the path to the directory */
000018  4620              MOV      r0,r4
00001a  9905              LDR      r1,[sp,#0x14]
00001c  f7fffffe          BL       follow_path
;;;2201   		if (res == FR_OK) {						/* Follow completed */
000020  b980              CBNZ     r0,|L18.68|
;;;2202   			dir = dj->dir;
;;;2203   			if (dir) {							/* It is not the root dir */
000022  6960              LDR      r0,[r4,#0x14]
000024  b138              CBZ      r0,|L18.54|
;;;2204   				if (dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
000026  7ac1              LDRB     r1,[r0,#0xb]
000028  06c9              LSLS     r1,r1,#27
00002a  d50d              BPL      |L18.72|
;;;2205   					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
00002c  8a81              LDRH     r1,[r0,#0x14]
00002e  8b40              LDRH     r0,[r0,#0x1a]
000030  f361401f          BFI      r0,r1,#16,#16
000034  60a0              STR      r0,[r4,#8]
                  |L18.54|
;;;2206   				} else {						/* The object is not a directory */
;;;2207   					res = FR_NO_PATH;
;;;2208   				}
;;;2209   			}
;;;2210   			if (res == FR_OK) {
;;;2211   				dj->id = dj->fs->id;
000036  6820              LDR      r0,[r4,#0]
;;;2212   				res = dir_seek(dj, 0);			/* Rewind dir */
000038  2100              MOVS     r1,#0
00003a  88c0              LDRH     r0,[r0,#6]            ;2211
00003c  80a0              STRH     r0,[r4,#4]            ;2211
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       dir_seek
                  |L18.68|
;;;2213   			}
;;;2214   		}
;;;2215   		if (res == FR_NO_FILE) res = FR_NO_PATH;
000044  2804              CMP      r0,#4
000046  d100              BNE      |L18.74|
                  |L18.72|
000048  2005              MOVS     r0,#5
                  |L18.74|
;;;2216   	}
;;;2217   
;;;2218   	LEAVE_FF(dj->fs, res);
;;;2219   }
00004a  b006              ADD      sp,sp,#0x18
00004c  bd10              POP      {r4,pc}
;;;2220   
                          ENDP


                          AREA ||i.f_read||, CODE, READONLY, ALIGN=1

                  f_read PROC
;;;1748   
;;;1749   FRESULT f_read (
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1750   	FIL *fp, 		/* Pointer to the file object */
;;;1751   	void *buff,		/* Pointer to data buffer */
;;;1752   	UINT btr,		/* Number of bytes to read */
;;;1753   	UINT *br		/* Pointer to number of bytes read */
;;;1754   )
;;;1755   {
;;;1756   	FRESULT res;
;;;1757   	DWORD clst, sect, remain;
;;;1758   	UINT rcnt, cc;
;;;1759   	BYTE *rbuff = buff;
;;;1760   
;;;1761   
;;;1762   	*br = 0;
000004  f04f0900          MOV      r9,#0
000008  460f              MOV      r7,r1                 ;1759
;;;1763   
;;;1764   	res = validate(fp->fs, fp->id);					/* Check validity of the object */
00000a  f8c39000          STR      r9,[r3,#0]
00000e  4604              MOV      r4,r0                 ;1755
000010  8881              LDRH     r1,[r0,#4]
000012  4615              MOV      r5,r2                 ;1755
000014  4698              MOV      r8,r3                 ;1755
000016  6800              LDR      r0,[r0,#0]
000018  f7fffffe          BL       validate
;;;1765   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
00001c  2800              CMP      r0,#0
00001e  d103              BNE      |L19.40|
;;;1766   	if (fp->flag & FA__ERROR)						/* Check abort flag */
000020  79a0              LDRB     r0,[r4,#6]
000022  0601              LSLS     r1,r0,#24
000024  d502              BPL      |L19.44|
                  |L19.38|
;;;1767   		LEAVE_FF(fp->fs, FR_INT_ERR);
000026  2002              MOVS     r0,#2
                  |L19.40|
;;;1768   	if (!(fp->flag & FA_READ)) 						/* Check access mode */
;;;1769   		LEAVE_FF(fp->fs, FR_DENIED);
;;;1770   	remain = fp->fsize - fp->fptr;
;;;1771   	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
;;;1772   
;;;1773   	for ( ;  btr;									/* Repeat until all data transferred */
;;;1774   		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
;;;1775   		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
;;;1776   			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
;;;1777   				clst = (fp->fptr == 0) ?			/* On the top of the file? */
;;;1778   					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
;;;1779   				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
;;;1780   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;1781   				fp->curr_clust = clst;				/* Update current cluster */
;;;1782   				fp->csect = 0;						/* Reset sector offset in the cluster */
;;;1783   			}
;;;1784   			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
;;;1785   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;1786   			sect += fp->csect;
;;;1787   			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
;;;1788   			if (cc) {								/* Read maximum contiguous sectors directly */
;;;1789   				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;1790   					cc = fp->fs->csize - fp->csect;
;;;1791   				if (disk_read(fp->fs->drive, rbuff, sect, (BYTE)cc) != RES_OK)
;;;1792   					ABORT(fp->fs, FR_DISK_ERR);
;;;1793   #if !_FS_READONLY && _FS_MINIMIZE <= 2
;;;1794   #if _FS_TINY
;;;1795   				if (fp->fs->wflag && fp->fs->winsect - sect < cc)		/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;1796   					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
;;;1797   #else
;;;1798   				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)	/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;1799   					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
;;;1800   #endif
;;;1801   #endif
;;;1802   				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
;;;1803   				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
;;;1804   				continue;
;;;1805   			}
;;;1806   #if !_FS_TINY
;;;1807   #if !_FS_READONLY
;;;1808   			if (fp->flag & FA__DIRTY) {			/* Write sector I/O buffer if needed */
;;;1809   				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
;;;1810   					ABORT(fp->fs, FR_DISK_ERR);
;;;1811   				fp->flag &= ~FA__DIRTY;
;;;1812   			}
;;;1813   #endif
;;;1814   			if (fp->dsect != sect) {			/* Fill sector buffer with file data */
;;;1815   				if (disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
;;;1816   					ABORT(fp->fs, FR_DISK_ERR);
;;;1817   			}
;;;1818   #endif
;;;1819   			fp->dsect = sect;
;;;1820   			fp->csect++;							/* Next sector address in the cluster */
;;;1821   		}
;;;1822   		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
;;;1823   		if (rcnt > btr) rcnt = btr;
;;;1824   #if _FS_TINY
;;;1825   		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
;;;1826   			ABORT(fp->fs, FR_DISK_ERR);
;;;1827   		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;1828   #else
;;;1829   		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;1830   #endif
;;;1831   	}
;;;1832   
;;;1833   	LEAVE_FF(fp->fs, FR_OK);
;;;1834   }
000028  e8bd8ff8          POP      {r3-r11,pc}
                  |L19.44|
00002c  07c0              LSLS     r0,r0,#31             ;1768
00002e  d008              BEQ      |L19.66|
000030  e9d41202          LDRD     r1,r2,[r4,#8]         ;1768
000034  1a50              SUBS     r0,r2,r1              ;1770
000036  f1040a24          ADD      r10,r4,#0x24          ;1799
00003a  4285              CMP      r5,r0                 ;1771
00003c  d900              BLS      |L19.64|
00003e  4605              MOV      r5,r0                 ;1771
                  |L19.64|
000040  e087              B        |L19.338|
                  |L19.66|
000042  2007              MOVS     r0,#7                 ;1769
000044  e7f0              B        |L19.40|
                  |L19.70|
000046  68a1              LDR      r1,[r4,#8]            ;1775
000048  05c8              LSLS     r0,r1,#23             ;1775
00004a  d16a              BNE      |L19.290|
00004c  6820              LDR      r0,[r4,#0]            ;1776
00004e  79e2              LDRB     r2,[r4,#7]            ;1776
000050  7883              LDRB     r3,[r0,#2]            ;1776
000052  429a              CMP      r2,r3                 ;1776
000054  d30a              BCC      |L19.108|
000056  b311              CBZ      r1,|L19.158|
000058  6961              LDR      r1,[r4,#0x14]         ;1778
00005a  f7fffffe          BL       get_fat
                  |L19.94|
00005e  2801              CMP      r0,#1                 ;1779
000060  d91f              BLS      |L19.162|
000062  1c41              ADDS     r1,r0,#1              ;1780
000064  d052              BEQ      |L19.268|
000066  6160              STR      r0,[r4,#0x14]         ;1782
000068  f8849007          STRB     r9,[r4,#7]            ;1782
                  |L19.108|
00006c  6961              LDR      r1,[r4,#0x14]         ;1784
00006e  6820              LDR      r0,[r4,#0]            ;1784
000070  f7fffffe          BL       clust2sect
000074  b1a8              CBZ      r0,|L19.162|
000076  79e1              LDRB     r1,[r4,#7]            ;1786
000078  0a6e              LSRS     r6,r5,#9              ;1787
00007a  eb010b00          ADD      r11,r1,r0             ;1786
00007e  d02b              BEQ      |L19.216|
000080  6822              LDR      r2,[r4,#0]            ;1789
000082  198b              ADDS     r3,r1,r6              ;1789
000084  7890              LDRB     r0,[r2,#2]            ;1789
000086  4283              CMP      r3,r0                 ;1789
000088  d900              BLS      |L19.140|
00008a  1a46              SUBS     r6,r0,r1              ;1790
                  |L19.140|
00008c  7850              LDRB     r0,[r2,#1]            ;1791
00008e  b2f3              UXTB     r3,r6                 ;1791
000090  465a              MOV      r2,r11                ;1791
000092  4639              MOV      r1,r7                 ;1791
000094  9300              STR      r3,[sp,#0]            ;1791
000096  f7fffffe          BL       disk_read
00009a  bbb8              CBNZ     r0,|L19.268|
00009c  e006              B        |L19.172|
                  |L19.158|
00009e  6920              LDR      r0,[r4,#0x10]         ;1778
0000a0  e7dd              B        |L19.94|
                  |L19.162|
0000a2  79a0              LDRB     r0,[r4,#6]            ;1785
0000a4  f0400080          ORR      r0,r0,#0x80           ;1785
0000a8  71a0              STRB     r0,[r4,#6]            ;1785
0000aa  e7bc              B        |L19.38|
                  |L19.172|
0000ac  79a0              LDRB     r0,[r4,#6]            ;1798
0000ae  0640              LSLS     r0,r0,#25             ;1798
0000b0  d50b              BPL      |L19.202|
0000b2  69a1              LDR      r1,[r4,#0x18]         ;1798
0000b4  eba1000b          SUB      r0,r1,r11             ;1798
0000b8  42b0              CMP      r0,r6                 ;1798
0000ba  d206              BCS      |L19.202|
0000bc  eb072040          ADD      r0,r7,r0,LSL #9       ;1799
0000c0  f44f7200          MOV      r2,#0x200             ;1799
0000c4  4651              MOV      r1,r10                ;1799
0000c6  f7fffffe          BL       mem_cpy
                  |L19.202|
0000ca  79e1              LDRB     r1,[r4,#7]            ;1802
0000cc  9800              LDR      r0,[sp,#0]            ;1802
0000ce  ea4f2646          LSL      r6,r6,#9              ;1803
0000d2  4408              ADD      r0,r0,r1              ;1802
0000d4  71e0              STRB     r0,[r4,#7]            ;1802
0000d6  e032              B        |L19.318|
                  |L19.216|
0000d8  79a0              LDRB     r0,[r4,#6]            ;1808
0000da  0640              LSLS     r0,r0,#25             ;1808
0000dc  d50b              BPL      |L19.246|
0000de  6820              LDR      r0,[r4,#0]            ;1809
0000e0  2301              MOVS     r3,#1                 ;1809
0000e2  4651              MOV      r1,r10                ;1809
0000e4  7840              LDRB     r0,[r0,#1]            ;1809
0000e6  69a2              LDR      r2,[r4,#0x18]         ;1809
0000e8  f7fffffe          BL       disk_write
0000ec  b970              CBNZ     r0,|L19.268|
0000ee  79a0              LDRB     r0,[r4,#6]            ;1811
0000f0  f0200040          BIC      r0,r0,#0x40           ;1811
0000f4  71a0              STRB     r0,[r4,#6]            ;1811
                  |L19.246|
0000f6  69a1              LDR      r1,[r4,#0x18]         ;1814
0000f8  4559              CMP      r1,r11                ;1814
0000fa  d00d              BEQ      |L19.280|
0000fc  6820              LDR      r0,[r4,#0]            ;1815
0000fe  2301              MOVS     r3,#1                 ;1815
000100  465a              MOV      r2,r11                ;1815
000102  7840              LDRB     r0,[r0,#1]            ;1815
000104  4651              MOV      r1,r10                ;1815
000106  f7fffffe          BL       disk_read
00010a  b128              CBZ      r0,|L19.280|
                  |L19.268|
00010c  79a0              LDRB     r0,[r4,#6]            ;1816
00010e  f0400080          ORR      r0,r0,#0x80           ;1816
000112  71a0              STRB     r0,[r4,#6]            ;1816
000114  2001              MOVS     r0,#1                 ;1816
000116  e787              B        |L19.40|
                  |L19.280|
000118  f8c4b018          STR      r11,[r4,#0x18]        ;1820
00011c  79e0              LDRB     r0,[r4,#7]            ;1820
00011e  1c40              ADDS     r0,r0,#1              ;1820
000120  71e0              STRB     r0,[r4,#7]            ;1820
                  |L19.290|
000122  68a0              LDR      r0,[r4,#8]            ;1822
000124  f3c00008          UBFX     r0,r0,#0,#9           ;1822
000128  f5c07600          RSB      r6,r0,#0x200          ;1822
00012c  42ae              CMP      r6,r5                 ;1823
00012e  d900              BLS      |L19.306|
000130  462e              MOV      r6,r5                 ;1823
                  |L19.306|
000132  1901              ADDS     r1,r0,r4              ;1829
000134  3124              ADDS     r1,r1,#0x24           ;1829
000136  4632              MOV      r2,r6                 ;1829
000138  4638              MOV      r0,r7                 ;1829
00013a  f7fffffe          BL       mem_cpy
                  |L19.318|
00013e  68a1              LDR      r1,[r4,#8]            ;1774
000140  4437              ADD      r7,r7,r6              ;1774
000142  4431              ADD      r1,r1,r6              ;1774
000144  60a1              STR      r1,[r4,#8]            ;1774
000146  f8d81000          LDR      r1,[r8,#0]            ;1774
00014a  1bad              SUBS     r5,r5,r6              ;1774
00014c  4431              ADD      r1,r1,r6              ;1774
00014e  f8c81000          STR      r1,[r8,#0]            ;1774
                  |L19.338|
000152  2d00              CMP      r5,#0                 ;1773
000154  f47faf77          BNE      |L19.70|
000158  2000              MOVS     r0,#0                 ;1833
00015a  e765              B        |L19.40|
;;;1835   
                          ENDP


                          AREA ||i.f_readdir||, CODE, READONLY, ALIGN=1

                  f_readdir PROC
;;;2227   
;;;2228   FRESULT f_readdir (
000000  b5fe              PUSH     {r1-r7,lr}
;;;2229   	DIR *dj,			/* Pointer to the open directory object */
;;;2230   	FILINFO *fno		/* Pointer to file information to return */
;;;2231   )
;;;2232   {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;2233   	FRESULT res;
;;;2234   	NAMEBUF(sfn, lfn);
;;;2235   
;;;2236   
;;;2237   	res = validate(dj->fs, dj->id);			/* Check validity of the object */
000006  8881              LDRH     r1,[r0,#4]
000008  6800              LDR      r0,[r0,#0]
00000a  f7fffffe          BL       validate
;;;2238   	if (res == FR_OK) {
00000e  2800              CMP      r0,#0
000010  d116              BNE      |L20.64|
;;;2239   		INITBUF((*dj), sfn, lfn);
000012  f8c4d018          STR      sp,[r4,#0x18]
;;;2240   		if (!fno) {
000016  b1a6              CBZ      r6,|L20.66|
;;;2241   			res = dir_seek(dj, 0);
;;;2242   		} else {
;;;2243   			res = dir_read(dj);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       dir_read
00001e  2500              MOVS     r5,#0                 ;2233
;;;2244   			if (res == FR_NO_FILE) {
000020  2804              CMP      r0,#4
000022  d013              BEQ      |L20.76|
;;;2245   				dj->sect = 0;
;;;2246   				res = FR_OK;
;;;2247   			}
;;;2248   			if (res == FR_OK) {				/* A valid entry is found */
000024  2800              CMP      r0,#0
000026  d10b              BNE      |L20.64|
                  |L20.40|
;;;2249   				get_fileinfo(dj, fno);		/* Get the object information */
000028  4631              MOV      r1,r6
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       get_fileinfo
;;;2250   				res = dir_next(dj, FALSE);	/* Increment index for next */
000030  2100              MOVS     r1,#0
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       dir_next
;;;2251   				if (res == FR_NO_FILE) {
000038  2804              CMP      r0,#4
00003a  d101              BNE      |L20.64|
;;;2252   					dj->sect = 0;
;;;2253   					res = FR_OK;
00003c  2000              MOVS     r0,#0
00003e  6125              STR      r5,[r4,#0x10]
                  |L20.64|
;;;2254   				}
;;;2255   			}
;;;2256   		}
;;;2257   	}
;;;2258   
;;;2259   	LEAVE_FF(dj->fs, res);
;;;2260   }
000040  bdfe              POP      {r1-r7,pc}
                  |L20.66|
000042  2100              MOVS     r1,#0                 ;2241
000044  4620              MOV      r0,r4                 ;2241
000046  f7fffffe          BL       dir_seek
00004a  bdfe              POP      {r1-r7,pc}
                  |L20.76|
00004c  6125              STR      r5,[r4,#0x10]         ;2246
00004e  e7eb              B        |L20.40|
;;;2261   
                          ENDP


                          AREA ||i.f_rename||, CODE, READONLY, ALIGN=1

                  f_rename PROC
;;;2627   
;;;2628   FRESULT f_rename (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;2629   	const XCHAR *path_old,	/* Pointer to the old name */
;;;2630   	const XCHAR *path_new	/* Pointer to the new name */
;;;2631   )
;;;2632   {
000002  b097              SUB      sp,sp,#0x5c
;;;2633   	FRESULT res;
;;;2634   	DIR dj_old, dj_new;
;;;2635   	NAMEBUF(sfn, lfn);
;;;2636   	BYTE buf[21], *dir;
;;;2637   	DWORD dw;
;;;2638   
;;;2639   
;;;2640   	INITBUF(dj_old, sfn, lfn);
000004  a814              ADD      r0,sp,#0x50
000006  460c              MOV      r4,r1                 ;2632
;;;2641   	res = auto_mount(&path_old, &dj_old.fs, 1);
000008  9013              STR      r0,[sp,#0x4c]
00000a  2201              MOVS     r2,#1
00000c  a90d              ADD      r1,sp,#0x34
00000e  a817              ADD      r0,sp,#0x5c
000010  f7fffffe          BL       auto_mount
;;;2642   	if (res == FR_OK) {
000014  2800              CMP      r0,#0
000016  d149              BNE      |L21.172|
;;;2643   		dj_new.fs = dj_old.fs;
000018  980d              LDR      r0,[sp,#0x34]
;;;2644   		res = follow_path(&dj_old, path_old);	/* Check old object */
00001a  9000              STR      r0,[sp,#0]
00001c  a80d              ADD      r0,sp,#0x34
00001e  9917              LDR      r1,[sp,#0x5c]
000020  f7fffffe          BL       follow_path
;;;2645   		if (_FS_RPATH && res == FR_OK && (dj_old.fn[11] & NS_DOT))
;;;2646   			res = FR_INVALID_NAME;
;;;2647   	}
;;;2648   	if (res != FR_OK) LEAVE_FF(dj_old.fs, res);	/* The old object is not found */
000024  2800              CMP      r0,#0
000026  d141              BNE      |L21.172|
;;;2649   
;;;2650   	if (!dj_old.dir) LEAVE_FF(dj_old.fs, FR_NO_FILE);	/* Is root dir? */
000028  9812              LDR      r0,[sp,#0x48]
00002a  b3e0              CBZ      r0,|L21.166|
;;;2651   	mem_cpy(buf, dj_old.dir+DIR_Attr, 21);		/* Save the object information */
00002c  f100010b          ADD      r1,r0,#0xb
000030  2215              MOVS     r2,#0x15
000032  a807              ADD      r0,sp,#0x1c
000034  f7fffffe          BL       mem_cpy
;;;2652   
;;;2653   	mem_cpy(&dj_new, &dj_old, sizeof(DIR));
000038  221c              MOVS     r2,#0x1c
00003a  a90d              ADD      r1,sp,#0x34
00003c  4668              MOV      r0,sp
00003e  f7fffffe          BL       mem_cpy
;;;2654   	res = follow_path(&dj_new, path_new);		/* Check new object */
000042  4621              MOV      r1,r4
000044  4668              MOV      r0,sp
000046  f7fffffe          BL       follow_path
;;;2655   	if (res == FR_OK) res = FR_EXIST;			/* The new object name is already existing */
00004a  b368              CBZ      r0,|L21.168|
;;;2656   	if (res == FR_NO_FILE) { 					/* Is it a valid path and no name collision? */
00004c  2804              CMP      r0,#4
00004e  d12d              BNE      |L21.172|
;;;2657   		res = dir_register(&dj_new);			/* Register the new object */
000050  4668              MOV      r0,sp
000052  f7fffffe          BL       dir_register
;;;2658   		if (res == FR_OK) {
000056  2800              CMP      r0,#0
000058  d128              BNE      |L21.172|
;;;2659   			dir = dj_new.dir;					/* Copy object information into new entry */
;;;2660   			mem_cpy(dir+13, buf+2, 19);
00005a  9c05              LDR      r4,[sp,#0x14]
00005c  2213              MOVS     r2,#0x13
00005e  f10d011e          ADD      r1,sp,#0x1e
000062  f104000d          ADD      r0,r4,#0xd
000066  f7fffffe          BL       mem_cpy
;;;2661   			dir[DIR_Attr] = buf[0] | AM_ARC;
00006a  f89d001c          LDRB     r0,[sp,#0x1c]
;;;2662   			dj_old.fs->wflag = 1;
00006e  2501              MOVS     r5,#1
000070  f0400020          ORR      r0,r0,#0x20           ;2661
000074  72e0              STRB     r0,[r4,#0xb]          ;2661
000076  980d              LDR      r0,[sp,#0x34]
000078  7105              STRB     r5,[r0,#4]
;;;2663   			if (dir[DIR_Attr] & AM_DIR) {		/* Update .. entry in the directory if needed */
00007a  7ae0              LDRB     r0,[r4,#0xb]
00007c  06c0              LSLS     r0,r0,#27
00007e  d52f              BPL      |L21.224|
;;;2664   				dw = clust2sect(dj_new.fs, (DWORD)LD_WORD(dir+DIR_FstClusHI) | LD_WORD(dir+DIR_FstClusLO));
000080  8aa1              LDRH     r1,[r4,#0x14]
000082  8b60              LDRH     r0,[r4,#0x1a]
000084  4301              ORRS     r1,r1,r0
000086  9800              LDR      r0,[sp,#0]
000088  f7fffffe          BL       clust2sect
00008c  0001              MOVS     r1,r0
;;;2665   				if (!dw) {
00008e  d011              BEQ      |L21.180|
;;;2666   					res = FR_INT_ERR;
;;;2667   				} else {
;;;2668   					res = move_window(dj_new.fs, dw);
000090  9800              LDR      r0,[sp,#0]
000092  f7fffffe          BL       move_window
;;;2669   					dir = dj_new.fs->win+32;
000096  9900              LDR      r1,[sp,#0]
000098  3150              ADDS     r1,r1,#0x50
;;;2670   					if (res == FR_OK && dir[1] == '.') {
00009a  2800              CMP      r0,#0
00009c  d106              BNE      |L21.172|
00009e  7848              LDRB     r0,[r1,#1]
0000a0  282e              CMP      r0,#0x2e
0000a2  d009              BEQ      |L21.184|
0000a4  e01c              B        |L21.224|
                  |L21.166|
0000a6  e000              B        |L21.170|
                  |L21.168|
0000a8  e002              B        |L21.176|
                  |L21.170|
0000aa  2004              MOVS     r0,#4                 ;2650
                  |L21.172|
;;;2671   						dw = (dj_new.fs->fs_type == FS_FAT32 && dj_new.sclust == dj_new.fs->dirbase) ? 0 : dj_new.sclust;
;;;2672   						ST_WORD(dir+DIR_FstClusLO, dw);
;;;2673   						ST_WORD(dir+DIR_FstClusHI, dw >> 16);
;;;2674   						dj_new.fs->wflag = 1;
;;;2675   					}
;;;2676   				}
;;;2677   			}
;;;2678   			if (res == FR_OK) {
;;;2679   				res = dir_remove(&dj_old);			/* Remove old entry */
;;;2680   				if (res == FR_OK)
;;;2681   					res = sync(dj_old.fs);
;;;2682   			}
;;;2683   		}
;;;2684   	}
;;;2685   
;;;2686   	LEAVE_FF(dj_old.fs, res);
;;;2687   }
0000ac  b019              ADD      sp,sp,#0x64
0000ae  bd30              POP      {r4,r5,pc}
                  |L21.176|
0000b0  2008              MOVS     r0,#8                 ;2655
0000b2  e7fb              B        |L21.172|
                  |L21.180|
0000b4  2002              MOVS     r0,#2                 ;2666
0000b6  e7f9              B        |L21.172|
                  |L21.184|
0000b8  9a00              LDR      r2,[sp,#0]            ;2671
0000ba  2000              MOVS     r0,#0                 ;2671
0000bc  7812              LDRB     r2,[r2,#0]            ;2671
0000be  2a03              CMP      r2,#3                 ;2671
0000c0  d104              BNE      |L21.204|
0000c2  9b00              LDR      r3,[sp,#0]            ;2671
0000c4  9a02              LDR      r2,[sp,#8]            ;2671
0000c6  6a5b              LDR      r3,[r3,#0x24]         ;2671
0000c8  429a              CMP      r2,r3                 ;2671
0000ca  d000              BEQ      |L21.206|
                  |L21.204|
0000cc  9802              LDR      r0,[sp,#8]            ;2671
                  |L21.206|
0000ce  7688              STRB     r0,[r1,#0x1a]         ;2672
0000d0  0a02              LSRS     r2,r0,#8              ;2672
0000d2  76ca              STRB     r2,[r1,#0x1b]         ;2672
0000d4  0c02              LSRS     r2,r0,#16             ;2673
0000d6  750a              STRB     r2,[r1,#0x14]         ;2673
0000d8  0e00              LSRS     r0,r0,#24             ;2673
0000da  7548              STRB     r0,[r1,#0x15]         ;2673
0000dc  9800              LDR      r0,[sp,#0]            ;2674
0000de  7105              STRB     r5,[r0,#4]            ;2674
                  |L21.224|
0000e0  a80d              ADD      r0,sp,#0x34           ;2679
0000e2  f7fffffe          BL       dir_remove
0000e6  2800              CMP      r0,#0                 ;2680
0000e8  d1e0              BNE      |L21.172|
0000ea  980d              LDR      r0,[sp,#0x34]         ;2681
0000ec  f7fffffe          BL       sync
0000f0  e7dc              B        |L21.172|
;;;2688   
                          ENDP


                          AREA ||i.f_stat||, CODE, READONLY, ALIGN=1

                  f_stat PROC
;;;2268   
;;;2269   FRESULT f_stat (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;2270   	const XCHAR *path,	/* Pointer to the file path */
;;;2271   	FILINFO *fno		/* Pointer to file information to return */
;;;2272   )
;;;2273   {
000002  b08b              SUB      sp,sp,#0x2c
000004  460d              MOV      r5,r1
;;;2274   	FRESULT res;
;;;2275   	DIR dj;
;;;2276   	NAMEBUF(sfn, lfn);
;;;2277   
;;;2278   
;;;2279   	res = auto_mount(&path, &dj.fs, 0);
000006  2200              MOVS     r2,#0
000008  4669              MOV      r1,sp
00000a  a80b              ADD      r0,sp,#0x2c
00000c  f7fffffe          BL       auto_mount
000010  0004              MOVS     r4,r0
;;;2280   	if (res == FR_OK) {
000012  d10f              BNE      |L22.52|
;;;2281   		INITBUF(dj, sfn, lfn);
000014  a807              ADD      r0,sp,#0x1c
;;;2282   		res = follow_path(&dj, path);	/* Follow the file path */
000016  9006              STR      r0,[sp,#0x18]
000018  4668              MOV      r0,sp
00001a  990b              LDR      r1,[sp,#0x2c]
00001c  f7fffffe          BL       follow_path
000020  0004              MOVS     r4,r0
;;;2283   		if (res == FR_OK) {				/* Follwo completed */
000022  d107              BNE      |L22.52|
;;;2284   			if (dj.dir)	/* Found an object */
000024  9805              LDR      r0,[sp,#0x14]
000026  b120              CBZ      r0,|L22.50|
;;;2285   				get_fileinfo(&dj, fno);
000028  4629              MOV      r1,r5
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       get_fileinfo
000030  e000              B        |L22.52|
                  |L22.50|
;;;2286   			else		/* It is root dir */
;;;2287   				res = FR_INVALID_NAME;
000032  2406              MOVS     r4,#6
                  |L22.52|
;;;2288   		}
;;;2289   	}
;;;2290   
;;;2291   	LEAVE_FF(dj.fs, res);
;;;2292   }
000034  b00d              ADD      sp,sp,#0x34
000036  4620              MOV      r0,r4                 ;2291
000038  bd30              POP      {r4,r5,pc}
;;;2293   
                          ENDP


                          AREA ||i.f_sync||, CODE, READONLY, ALIGN=1

                  f_sync PROC
;;;1958   
;;;1959   FRESULT f_sync (
000000  b570              PUSH     {r4-r6,lr}
;;;1960   	FIL *fp		/* Pointer to the file object */
;;;1961   )
;;;1962   {
000002  4604              MOV      r4,r0
;;;1963   	FRESULT res;
;;;1964   	DWORD tim;
;;;1965   	BYTE *dir;
;;;1966   
;;;1967   
;;;1968   	res = validate(fp->fs, fp->id);		/* Check validity of the object */
000004  8881              LDRH     r1,[r0,#4]
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       validate
;;;1969   	if (res == FR_OK) {
00000c  2800              CMP      r0,#0
00000e  d10e              BNE      |L23.46|
;;;1970   		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
000010  79a1              LDRB     r1,[r4,#6]
000012  068a              LSLS     r2,r1,#26
000014  d50b              BPL      |L23.46|
;;;1971   #if !_FS_TINY	/* Write-back dirty buffer */
;;;1972   			if (fp->flag & FA__DIRTY) {
000016  0648              LSLS     r0,r1,#25
000018  d50e              BPL      |L23.56|
;;;1973   				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
00001a  6820              LDR      r0,[r4,#0]
00001c  2301              MOVS     r3,#1
00001e  f1040124          ADD      r1,r4,#0x24
000022  7840              LDRB     r0,[r0,#1]
000024  69a2              LDR      r2,[r4,#0x18]
000026  f7fffffe          BL       disk_write
00002a  b108              CBZ      r0,|L23.48|
;;;1974   					LEAVE_FF(fp->fs, FR_DISK_ERR);
00002c  2001              MOVS     r0,#1
                  |L23.46|
;;;1975   				fp->flag &= ~FA__DIRTY;
;;;1976   			}
;;;1977   #endif
;;;1978   			/* Update the directory entry */
;;;1979   			res = move_window(fp->fs, fp->dir_sect);
;;;1980   			if (res == FR_OK) {
;;;1981   				dir = fp->dir_ptr;
;;;1982   				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
;;;1983   				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
;;;1984   				ST_WORD(dir+DIR_FstClusLO, fp->org_clust);	/* Update start cluster */
;;;1985   				ST_WORD(dir+DIR_FstClusHI, fp->org_clust >> 16);
;;;1986   				tim = get_fattime();			/* Updated time */
;;;1987   				ST_DWORD(dir+DIR_WrtTime, tim);
;;;1988   				fp->flag &= ~FA__WRITTEN;
;;;1989   				fp->fs->wflag = 1;
;;;1990   				res = sync(fp->fs);
;;;1991   			}
;;;1992   		}
;;;1993   	}
;;;1994   
;;;1995   	LEAVE_FF(fp->fs, res);
;;;1996   }
00002e  bd70              POP      {r4-r6,pc}
                  |L23.48|
000030  79a0              LDRB     r0,[r4,#6]            ;1975
000032  f0200040          BIC      r0,r0,#0x40           ;1975
000036  71a0              STRB     r0,[r4,#6]            ;1975
                  |L23.56|
000038  69e1              LDR      r1,[r4,#0x1c]         ;1979
00003a  6820              LDR      r0,[r4,#0]            ;1979
00003c  f7fffffe          BL       move_window
000040  2800              CMP      r0,#0                 ;1980
000042  d1f4              BNE      |L23.46|
000044  6a25              LDR      r5,[r4,#0x20]         ;1982
000046  7ae8              LDRB     r0,[r5,#0xb]          ;1982
000048  f0400020          ORR      r0,r0,#0x20           ;1982
00004c  72e8              STRB     r0,[r5,#0xb]          ;1982
00004e  68e0              LDR      r0,[r4,#0xc]          ;1983
000050  7728              STRB     r0,[r5,#0x1c]         ;1983
000052  68e0              LDR      r0,[r4,#0xc]          ;1983
000054  0a00              LSRS     r0,r0,#8              ;1983
000056  7768              STRB     r0,[r5,#0x1d]         ;1983
000058  68e0              LDR      r0,[r4,#0xc]          ;1983
00005a  0c00              LSRS     r0,r0,#16             ;1983
00005c  77a8              STRB     r0,[r5,#0x1e]         ;1983
00005e  68e0              LDR      r0,[r4,#0xc]          ;1983
000060  0e00              LSRS     r0,r0,#24             ;1983
000062  77e8              STRB     r0,[r5,#0x1f]         ;1983
000064  6920              LDR      r0,[r4,#0x10]         ;1984
000066  76a8              STRB     r0,[r5,#0x1a]         ;1984
000068  6920              LDR      r0,[r4,#0x10]         ;1984
00006a  0a00              LSRS     r0,r0,#8              ;1984
00006c  76e8              STRB     r0,[r5,#0x1b]         ;1984
00006e  6920              LDR      r0,[r4,#0x10]         ;1985
000070  0c00              LSRS     r0,r0,#16             ;1985
000072  7528              STRB     r0,[r5,#0x14]         ;1985
000074  6920              LDR      r0,[r4,#0x10]         ;1985
000076  0e00              LSRS     r0,r0,#24             ;1985
000078  7568              STRB     r0,[r5,#0x15]         ;1985
00007a  f7fffffe          BL       get_fattime
00007e  75a8              STRB     r0,[r5,#0x16]         ;1987
000080  0a01              LSRS     r1,r0,#8              ;1987
000082  75e9              STRB     r1,[r5,#0x17]         ;1987
000084  0c01              LSRS     r1,r0,#16             ;1987
000086  7629              STRB     r1,[r5,#0x18]         ;1987
000088  0e00              LSRS     r0,r0,#24             ;1987
00008a  7668              STRB     r0,[r5,#0x19]         ;1987
00008c  79a0              LDRB     r0,[r4,#6]            ;1988
00008e  f0200020          BIC      r0,r0,#0x20           ;1988
000092  71a0              STRB     r0,[r4,#6]            ;1988
000094  6821              LDR      r1,[r4,#0]            ;1989
000096  2001              MOVS     r0,#1                 ;1989
000098  7108              STRB     r0,[r1,#4]            ;1989
00009a  6820              LDR      r0,[r4,#0]            ;1990
00009c  e8bd4070          POP      {r4-r6,lr}            ;1990
0000a0  f7ffbffe          B.W      sync
;;;1997   
                          ENDP


                          AREA ||i.f_truncate||, CODE, READONLY, ALIGN=1

                  f_truncate PROC
;;;2368   
;;;2369   FRESULT f_truncate (
000000  b570              PUSH     {r4-r6,lr}
;;;2370   	FIL *fp		/* Pointer to the file object */
;;;2371   )
;;;2372   {
000002  4604              MOV      r4,r0
;;;2373   	FRESULT res;
;;;2374   	DWORD ncl;
;;;2375   
;;;2376   
;;;2377   	res = validate(fp->fs, fp->id);		/* Check validity of the object */
000004  8881              LDRH     r1,[r0,#4]
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       validate
00000c  0005              MOVS     r5,r0
;;;2378   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
00000e  d103              BNE      |L24.24|
;;;2379   	if (fp->flag & FA__ERROR)			/* Check abort flag */
000010  79a0              LDRB     r0,[r4,#6]
000012  0601              LSLS     r1,r0,#24
000014  d501              BPL      |L24.26|
;;;2380   		LEAVE_FF(fp->fs, FR_INT_ERR);
000016  2002              MOVS     r0,#2
                  |L24.24|
;;;2381   	if (!(fp->flag & FA_WRITE))			/* Check access mode */
;;;2382   		LEAVE_FF(fp->fs, FR_DENIED);
;;;2383   
;;;2384   	if (fp->fsize > fp->fptr) {
;;;2385   		fp->fsize = fp->fptr;	/* Set file size to current R/W point */
;;;2386   		fp->flag |= FA__WRITTEN;
;;;2387   		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
;;;2388   			res = remove_chain(fp->fs, fp->org_clust);
;;;2389   			fp->org_clust = 0;
;;;2390   		} else {				/* When truncate a part of the file, remove remaining clusters */
;;;2391   			ncl = get_fat(fp->fs, fp->curr_clust);
;;;2392   			res = FR_OK;
;;;2393   			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
;;;2394   			if (ncl == 1) res = FR_INT_ERR;
;;;2395   			if (res == FR_OK && ncl < fp->fs->max_clust) {
;;;2396   				res = put_fat(fp->fs, fp->curr_clust, 0x0FFFFFFF);
;;;2397   				if (res == FR_OK) res = remove_chain(fp->fs, ncl);
;;;2398   			}
;;;2399   		}
;;;2400   	}
;;;2401   	if (res != FR_OK) fp->flag |= FA__ERROR;
;;;2402   
;;;2403   	LEAVE_FF(fp->fs, res);
;;;2404   }
000018  bd70              POP      {r4-r6,pc}
                  |L24.26|
00001a  0781              LSLS     r1,r0,#30             ;2381
00001c  d401              BMI      |L24.34|
00001e  2007              MOVS     r0,#7                 ;2382
000020  bd70              POP      {r4-r6,pc}
                  |L24.34|
000022  e9d41202          LDRD     r1,r2,[r4,#8]
000026  428a              CMP      r2,r1                 ;2384
000028  d930              BLS      |L24.140|
00002a  f0400020          ORR      r0,r0,#0x20           ;2386
00002e  60e1              STR      r1,[r4,#0xc]          ;2386
000030  71a0              STRB     r0,[r4,#6]            ;2386
000032  b151              CBZ      r1,|L24.74|
000034  6961              LDR      r1,[r4,#0x14]         ;2391
000036  6820              LDR      r0,[r4,#0]            ;2391
000038  f7fffffe          BL       get_fat
00003c  4606              MOV      r6,r0                 ;2391
00003e  1c40              ADDS     r0,r0,#1              ;2393
000040  d00b              BEQ      |L24.90|
000042  2e01              CMP      r6,#1                 ;2394
000044  d00b              BEQ      |L24.94|
000046  b165              CBZ      r5,|L24.98|
000048  e01c              B        |L24.132|
                  |L24.74|
00004a  6921              LDR      r1,[r4,#0x10]         ;2388
00004c  6820              LDR      r0,[r4,#0]            ;2388
00004e  f7fffffe          BL       remove_chain
000052  4605              MOV      r5,r0                 ;2388
000054  2000              MOVS     r0,#0                 ;2389
000056  6120              STR      r0,[r4,#0x10]         ;2389
000058  e013              B        |L24.130|
                  |L24.90|
00005a  2501              MOVS     r5,#1                 ;2393
00005c  e012              B        |L24.132|
                  |L24.94|
00005e  2502              MOVS     r5,#2                 ;2394
000060  e010              B        |L24.132|
                  |L24.98|
000062  6820              LDR      r0,[r4,#0]            ;2395
000064  69c1              LDR      r1,[r0,#0x1c]         ;2395
000066  42b1              CMP      r1,r6                 ;2395
000068  d910              BLS      |L24.140|
00006a  f06f4270          MVN      r2,#0xf0000000        ;2396
00006e  6961              LDR      r1,[r4,#0x14]         ;2396
000070  f7fffffe          BL       put_fat
000074  0005              MOVS     r5,r0                 ;2396
000076  d105              BNE      |L24.132|
000078  4631              MOV      r1,r6                 ;2397
00007a  6820              LDR      r0,[r4,#0]            ;2397
00007c  f7fffffe          BL       remove_chain
000080  4605              MOV      r5,r0                 ;2397
                  |L24.130|
000082  b11d              CBZ      r5,|L24.140|
                  |L24.132|
000084  79a0              LDRB     r0,[r4,#6]            ;2401
000086  f0400080          ORR      r0,r0,#0x80           ;2401
00008a  71a0              STRB     r0,[r4,#6]            ;2401
                  |L24.140|
00008c  4628              MOV      r0,r5                 ;2403
00008e  bd70              POP      {r4-r6,pc}
;;;2405   
                          ENDP


                          AREA ||i.f_unlink||, CODE, READONLY, ALIGN=1

                  f_unlink PROC
;;;2412   
;;;2413   FRESULT f_unlink (
000000  b511              PUSH     {r0,r4,lr}
;;;2414   	const XCHAR *path		/* Pointer to the file or directory path */
;;;2415   )
;;;2416   {
000002  b091              SUB      sp,sp,#0x44
;;;2417   	FRESULT res;
;;;2418   	DIR dj, sdj;
;;;2419   	NAMEBUF(sfn, lfn);
;;;2420   	BYTE *dir;
;;;2421   	DWORD dclst;
;;;2422   
;;;2423   
;;;2424   	res = auto_mount(&path, &dj.fs, 1);
000004  2201              MOVS     r2,#1
000006  4669              MOV      r1,sp
000008  a811              ADD      r0,sp,#0x44
00000a  f7fffffe          BL       auto_mount
;;;2425   	if (res != FR_OK) LEAVE_FF(dj.fs, res);
00000e  2800              CMP      r0,#0
000010  d10e              BNE      |L25.48|
;;;2426   
;;;2427   	INITBUF(dj, sfn, lfn);
000012  a80e              ADD      r0,sp,#0x38
;;;2428   	res = follow_path(&dj, path);			/* Follow the file path */
000014  9006              STR      r0,[sp,#0x18]
000016  4668              MOV      r0,sp
000018  9911              LDR      r1,[sp,#0x44]
00001a  f7fffffe          BL       follow_path
;;;2429   	if (_FS_RPATH && res == FR_OK && (dj.fn[11] & NS_DOT))
;;;2430   		res = FR_INVALID_NAME;
;;;2431   	if (res != FR_OK) LEAVE_FF(dj.fs, res); /* Follow failed */
00001e  2800              CMP      r0,#0
000020  d106              BNE      |L25.48|
;;;2432   
;;;2433   	dir = dj.dir;
;;;2434   	if (!dir)								/* Is it the root directory? */
000022  9805              LDR      r0,[sp,#0x14]
000024  b118              CBZ      r0,|L25.46|
;;;2435   		LEAVE_FF(dj.fs, FR_INVALID_NAME);
;;;2436   	if (dir[DIR_Attr] & AM_RDO)				/* Is it a R/O object? */
000026  7ac1              LDRB     r1,[r0,#0xb]
000028  07ca              LSLS     r2,r1,#31
00002a  d12f              BNE      |L25.140|
00002c  e002              B        |L25.52|
                  |L25.46|
00002e  2006              MOVS     r0,#6                 ;2435
                  |L25.48|
;;;2437   		LEAVE_FF(dj.fs, FR_DENIED);
;;;2438   	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
;;;2439   
;;;2440   	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
;;;2441   		if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
;;;2442   		mem_cpy(&sdj, &dj, sizeof(DIR));		/* Check if the sub-dir is empty or not */
;;;2443   		sdj.sclust = dclst;
;;;2444   		res = dir_seek(&sdj, 0);
;;;2445   		if (res != FR_OK) LEAVE_FF(dj.fs, res);
;;;2446   		res = dir_read(&sdj);
;;;2447   		if (res == FR_OK) res = FR_DENIED;	/* Not empty sub-dir */
;;;2448   		if (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
;;;2449   	}
;;;2450   
;;;2451   	res = dir_remove(&dj);					/* Remove directory entry */
;;;2452   	if (res == FR_OK) {
;;;2453   		if (dclst)
;;;2454   			res = remove_chain(dj.fs, dclst);	/* Remove the cluster chain */
;;;2455   		if (res == FR_OK) res = sync(dj.fs);
;;;2456   	}
;;;2457   
;;;2458   	LEAVE_FF(dj.fs, res);
;;;2459   }
000030  b012              ADD      sp,sp,#0x48
000032  bd10              POP      {r4,pc}
                  |L25.52|
000034  8a82              LDRH     r2,[r0,#0x14]         ;2438
000036  8b44              LDRH     r4,[r0,#0x1a]         ;2438
000038  06c8              LSLS     r0,r1,#27             ;2440
00003a  f362441f          BFI      r4,r2,#16,#16         ;2438
00003e  d515              BPL      |L25.108|
000040  2c02              CMP      r4,#2                 ;2441
000042  d201              BCS      |L25.72|
000044  2002              MOVS     r0,#2                 ;2441
000046  e7f3              B        |L25.48|
                  |L25.72|
000048  221c              MOVS     r2,#0x1c              ;2442
00004a  4669              MOV      r1,sp                 ;2442
00004c  a807              ADD      r0,sp,#0x1c           ;2442
00004e  f7fffffe          BL       mem_cpy
000052  2100              MOVS     r1,#0                 ;2444
000054  a807              ADD      r0,sp,#0x1c           ;2444
000056  9409              STR      r4,[sp,#0x24]         ;2444
000058  f7fffffe          BL       dir_seek
00005c  2800              CMP      r0,#0                 ;2445
00005e  d1e7              BNE      |L25.48|
000060  a807              ADD      r0,sp,#0x1c           ;2446
000062  f7fffffe          BL       dir_read
000066  b188              CBZ      r0,|L25.140|
000068  2804              CMP      r0,#4                 ;2448
00006a  d1e1              BNE      |L25.48|
                  |L25.108|
00006c  4668              MOV      r0,sp                 ;2451
00006e  f7fffffe          BL       dir_remove
000072  2800              CMP      r0,#0                 ;2452
000074  d1dc              BNE      |L25.48|
000076  b12c              CBZ      r4,|L25.132|
000078  4621              MOV      r1,r4                 ;2454
00007a  9800              LDR      r0,[sp,#0]            ;2454
00007c  f7fffffe          BL       remove_chain
000080  2800              CMP      r0,#0                 ;2455
000082  d1d5              BNE      |L25.48|
                  |L25.132|
000084  9800              LDR      r0,[sp,#0]            ;2455
000086  f7fffffe          BL       sync
00008a  e7d1              B        |L25.48|
                  |L25.140|
00008c  2007              MOVS     r0,#7                 ;2447
00008e  e7cf              B        |L25.48|
;;;2460   
                          ENDP


                          AREA ||i.f_utime||, CODE, READONLY, ALIGN=1

                  f_utime PROC
;;;2587   
;;;2588   FRESULT f_utime (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;2589   	const XCHAR *path,	/* Pointer to the file/directory name */
;;;2590   	const FILINFO *fno	/* Pointer to the timestamp to be set */
;;;2591   )
;;;2592   {
000002  b08a              SUB      sp,sp,#0x28
000004  460c              MOV      r4,r1
;;;2593   	FRESULT res;
;;;2594   	DIR dj;
;;;2595   	NAMEBUF(sfn, lfn);
;;;2596   	BYTE *dir;
;;;2597   
;;;2598   
;;;2599   	res = auto_mount(&path, &dj.fs, 1);
000006  2201              MOVS     r2,#1
000008  4669              MOV      r1,sp
00000a  a80a              ADD      r0,sp,#0x28
00000c  f7fffffe          BL       auto_mount
;;;2600   	if (res == FR_OK) {
000010  2800              CMP      r0,#0
000012  d119              BNE      |L26.72|
;;;2601   		INITBUF(dj, sfn, lfn);
000014  a807              ADD      r0,sp,#0x1c
;;;2602   		res = follow_path(&dj, path);	/* Follow the file path */
000016  9006              STR      r0,[sp,#0x18]
000018  4668              MOV      r0,sp
00001a  990a              LDR      r1,[sp,#0x28]
00001c  f7fffffe          BL       follow_path
;;;2603   		if (_FS_RPATH && res == FR_OK && (dj.fn[11] & NS_DOT))
;;;2604   			res = FR_INVALID_NAME;
;;;2605   		if (res == FR_OK) {
000020  2800              CMP      r0,#0
000022  d111              BNE      |L26.72|
;;;2606   			dir = dj.dir;
;;;2607   			if (!dir) {				/* Root directory */
000024  9805              LDR      r0,[sp,#0x14]
000026  b188              CBZ      r0,|L26.76|
;;;2608   				res = FR_INVALID_NAME;
;;;2609   			} else {				/* File or sub-directory */
;;;2610   				ST_WORD(dir+DIR_WrtTime, fno->ftime);
000028  88e1              LDRH     r1,[r4,#6]
00002a  7581              STRB     r1,[r0,#0x16]
00002c  88e1              LDRH     r1,[r4,#6]
00002e  0a09              LSRS     r1,r1,#8
000030  75c1              STRB     r1,[r0,#0x17]
;;;2611   				ST_WORD(dir+DIR_WrtDate, fno->fdate);
000032  88a1              LDRH     r1,[r4,#4]
000034  7601              STRB     r1,[r0,#0x18]
000036  88a1              LDRH     r1,[r4,#4]
000038  0a09              LSRS     r1,r1,#8
00003a  7641              STRB     r1,[r0,#0x19]
;;;2612   				dj.fs->wflag = 1;
00003c  9900              LDR      r1,[sp,#0]
00003e  2001              MOVS     r0,#1
000040  7108              STRB     r0,[r1,#4]
;;;2613   				res = sync(dj.fs);
000042  9800              LDR      r0,[sp,#0]
000044  f7fffffe          BL       sync
                  |L26.72|
;;;2614   			}
;;;2615   		}
;;;2616   	}
;;;2617   
;;;2618   	LEAVE_FF(dj.fs, res);
;;;2619   }
000048  b00c              ADD      sp,sp,#0x30
00004a  bd10              POP      {r4,pc}
                  |L26.76|
00004c  2006              MOVS     r0,#6                 ;2608
00004e  e7fb              B        |L26.72|
;;;2620   
                          ENDP


                          AREA ||i.f_write||, CODE, READONLY, ALIGN=1

                  f_write PROC
;;;1843   
;;;1844   FRESULT f_write (
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1845   	FIL *fp,			/* Pointer to the file object */
;;;1846   	const void *buff,	/* Pointer to the data to be written */
;;;1847   	UINT btw,			/* Number of bytes to write */
;;;1848   	UINT *bw			/* Pointer to number of bytes written */
;;;1849   )
;;;1850   {
;;;1851   	FRESULT res;
;;;1852   	DWORD clst, sect;
;;;1853   	UINT wcnt, cc;
;;;1854   	const BYTE *wbuff = buff;
;;;1855   
;;;1856   
;;;1857   	*bw = 0;
000004  f04f0900          MOV      r9,#0
000008  460f              MOV      r7,r1                 ;1854
;;;1858   
;;;1859   	res = validate(fp->fs, fp->id);					/* Check validity of the object */
00000a  f8c39000          STR      r9,[r3,#0]
00000e  4604              MOV      r4,r0                 ;1850
000010  8881              LDRH     r1,[r0,#4]
000012  4616              MOV      r6,r2                 ;1850
000014  4698              MOV      r8,r3                 ;1850
000016  6800              LDR      r0,[r0,#0]
000018  f7fffffe          BL       validate
;;;1860   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
00001c  2800              CMP      r0,#0
00001e  d103              BNE      |L27.40|
;;;1861   	if (fp->flag & FA__ERROR)						/* Check abort flag */
000020  79a1              LDRB     r1,[r4,#6]
000022  0608              LSLS     r0,r1,#24
000024  d502              BPL      |L27.44|
                  |L27.38|
;;;1862   		LEAVE_FF(fp->fs, FR_INT_ERR);
000026  2002              MOVS     r0,#2
                  |L27.40|
;;;1863   	if (!(fp->flag & FA_WRITE))						/* Check access mode */
;;;1864   		LEAVE_FF(fp->fs, FR_DENIED);
;;;1865   	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */
;;;1866   
;;;1867   	for ( ;  btw;									/* Repeat until all data transferred */
;;;1868   		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
;;;1869   		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
;;;1870   			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
;;;1871   				if (fp->fptr == 0) {				/* On the top of the file? */
;;;1872   					clst = fp->org_clust;			/* Follow from the origin */
;;;1873   					if (clst == 0)					/* When there is no cluster chain, */
;;;1874   						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
;;;1875   				} else {							/* Middle or end of the file */
;;;1876   					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or streach cluster chain */
;;;1877   				}
;;;1878   				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
;;;1879   				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;1880   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;1881   				fp->curr_clust = clst;				/* Update current cluster */
;;;1882   				fp->csect = 0;						/* Reset sector address in the cluster */
;;;1883   			}
;;;1884   #if _FS_TINY
;;;1885   			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write back data buffer prior to following direct transfer */
;;;1886   				ABORT(fp->fs, FR_DISK_ERR);
;;;1887   #else
;;;1888   			if (fp->flag & FA__DIRTY) {		/* Write back data buffer prior to following direct transfer */
;;;1889   				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
;;;1890   					ABORT(fp->fs, FR_DISK_ERR);
;;;1891   				fp->flag &= ~FA__DIRTY;
;;;1892   			}
;;;1893   #endif
;;;1894   			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
;;;1895   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;1896   			sect += fp->csect;
;;;1897   			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
;;;1898   			if (cc) {								/* Write maximum contiguous sectors directly */
;;;1899   				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;1900   					cc = fp->fs->csize - fp->csect;
;;;1901   				if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)
;;;1902   					ABORT(fp->fs, FR_DISK_ERR);
;;;1903   #if _FS_TINY
;;;1904   				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets dirty by the direct write */
;;;1905   					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;1906   					fp->fs->wflag = 0;
;;;1907   				}
;;;1908   #else
;;;1909   				if (fp->dsect - sect < cc) {		/* Refill sector cache if it gets dirty by the direct write */
;;;1910   					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;1911   					fp->flag &= ~FA__DIRTY;
;;;1912   				}
;;;1913   #endif
;;;1914   				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
;;;1915   				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
;;;1916   				continue;
;;;1917   			}
;;;1918   #if _FS_TINY
;;;1919   			if (fp->fptr >= fp->fsize) {			/* Avoid silly buffer filling at growing edge */
;;;1920   				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
;;;1921   				fp->fs->winsect = sect;
;;;1922   			}
;;;1923   #else
;;;1924   			if (fp->dsect != sect) {				/* Fill sector buffer with file data */
;;;1925   				if (fp->fptr < fp->fsize &&
;;;1926   					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
;;;1927   						ABORT(fp->fs, FR_DISK_ERR);
;;;1928   			}
;;;1929   #endif
;;;1930   			fp->dsect = sect;
;;;1931   			fp->csect++;							/* Next sector address in the cluster */
;;;1932   		}
;;;1933   		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Put partial sector into file I/O buffer */
;;;1934   		if (wcnt > btw) wcnt = btw;
;;;1935   #if _FS_TINY
;;;1936   		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
;;;1937   			ABORT(fp->fs, FR_DISK_ERR);
;;;1938   		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;1939   		fp->fs->wflag = 1;
;;;1940   #else
;;;1941   		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;1942   		fp->flag |= FA__DIRTY;
;;;1943   #endif
;;;1944   	}
;;;1945   
;;;1946   	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
;;;1947   	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
;;;1948   
;;;1949   	LEAVE_FF(fp->fs, FR_OK);
;;;1950   }
000028  e8bd8ff8          POP      {r3-r11,pc}
                  |L27.44|
00002c  0788              LSLS     r0,r1,#30             ;1863
00002e  d401              BMI      |L27.52|
000030  2007              MOVS     r0,#7                 ;1864
000032  e7f9              B        |L27.40|
                  |L27.52|
000034  68e1              LDR      r1,[r4,#0xc]          ;1865
000036  f1040a24          ADD      r10,r4,#0x24          ;1889
00003a  198a              ADDS     r2,r1,r6              ;1865
00003c  428a              CMP      r2,r1                 ;1865
00003e  d347              BCC      |L27.208|
000040  e09a              B        |L27.376|
                  |L27.66|
000042  68a0              LDR      r0,[r4,#8]            ;1869
000044  05c1              LSLS     r1,r0,#23             ;1869
000046  d17b              BNE      |L27.320|
000048  6822              LDR      r2,[r4,#0]            ;1870
00004a  79e1              LDRB     r1,[r4,#7]            ;1870
00004c  7893              LDRB     r3,[r2,#2]            ;1870
00004e  4299              CMP      r1,r3                 ;1870
000050  d30c              BCC      |L27.108|
000052  b1b8              CBZ      r0,|L27.132|
000054  4610              MOV      r0,r2                 ;1876
000056  6961              LDR      r1,[r4,#0x14]         ;1876
000058  f7fffffe          BL       create_chain
                  |L27.92|
00005c  b3c0              CBZ      r0,|L27.208|
                  |L27.94|
00005e  2801              CMP      r0,#1                 ;1879
000060  d038              BEQ      |L27.212|
000062  1c41              ADDS     r1,r0,#1              ;1880
000064  d060              BEQ      |L27.296|
000066  6160              STR      r0,[r4,#0x14]         ;1882
000068  f8849007          STRB     r9,[r4,#7]            ;1882
                  |L27.108|
00006c  79a0              LDRB     r0,[r4,#6]            ;1888
00006e  0640              LSLS     r0,r0,#25             ;1888
000070  d515              BPL      |L27.158|
000072  6820              LDR      r0,[r4,#0]            ;1889
000074  2301              MOVS     r3,#1                 ;1889
000076  4651              MOV      r1,r10                ;1889
000078  7840              LDRB     r0,[r0,#1]            ;1889
00007a  69a2              LDR      r2,[r4,#0x18]         ;1889
00007c  f7fffffe          BL       disk_write
000080  bb38              CBNZ     r0,|L27.210|
000082  e008              B        |L27.150|
                  |L27.132|
000084  6920              LDR      r0,[r4,#0x10]         ;1873
000086  2800              CMP      r0,#0                 ;1873
000088  d1e9              BNE      |L27.94|
00008a  2100              MOVS     r1,#0                 ;1874
00008c  4610              MOV      r0,r2                 ;1874
00008e  f7fffffe          BL       create_chain
000092  6120              STR      r0,[r4,#0x10]         ;1874
000094  e7e2              B        |L27.92|
                  |L27.150|
000096  79a0              LDRB     r0,[r4,#6]            ;1891
000098  f0200040          BIC      r0,r0,#0x40           ;1891
00009c  71a0              STRB     r0,[r4,#6]            ;1891
                  |L27.158|
00009e  6961              LDR      r1,[r4,#0x14]         ;1894
0000a0  6820              LDR      r0,[r4,#0]            ;1894
0000a2  f7fffffe          BL       clust2sect
0000a6  b1a8              CBZ      r0,|L27.212|
0000a8  79e2              LDRB     r2,[r4,#7]            ;1896
0000aa  0a75              LSRS     r5,r6,#9              ;1897
0000ac  eb020b00          ADD      r11,r2,r0             ;1896
0000b0  d02b              BEQ      |L27.266|
0000b2  6820              LDR      r0,[r4,#0]            ;1899
0000b4  1953              ADDS     r3,r2,r5              ;1899
0000b6  7881              LDRB     r1,[r0,#2]            ;1899
0000b8  428b              CMP      r3,r1                 ;1899
0000ba  d900              BLS      |L27.190|
0000bc  1a8d              SUBS     r5,r1,r2              ;1900
                  |L27.190|
0000be  7840              LDRB     r0,[r0,#1]            ;1901
0000c0  b2eb              UXTB     r3,r5                 ;1901
0000c2  465a              MOV      r2,r11                ;1901
0000c4  4639              MOV      r1,r7                 ;1901
0000c6  9300              STR      r3,[sp,#0]            ;1901
0000c8  f7fffffe          BL       disk_write
0000cc  b908              CBNZ     r0,|L27.210|
0000ce  e006              B        |L27.222|
                  |L27.208|
0000d0  e055              B        |L27.382|
                  |L27.210|
0000d2  e029              B        |L27.296|
                  |L27.212|
0000d4  79a0              LDRB     r0,[r4,#6]            ;1895
0000d6  f0400080          ORR      r0,r0,#0x80           ;1895
0000da  71a0              STRB     r0,[r4,#6]            ;1895
0000dc  e7a3              B        |L27.38|
                  |L27.222|
0000de  69a1              LDR      r1,[r4,#0x18]         ;1909
0000e0  eba1000b          SUB      r0,r1,r11             ;1909
0000e4  42a8              CMP      r0,r5                 ;1909
0000e6  d20a              BCS      |L27.254|
0000e8  eb072140          ADD      r1,r7,r0,LSL #9       ;1910
0000ec  f44f7200          MOV      r2,#0x200             ;1910
0000f0  4650              MOV      r0,r10                ;1910
0000f2  f7fffffe          BL       mem_cpy
0000f6  79a0              LDRB     r0,[r4,#6]            ;1911
0000f8  f0200040          BIC      r0,r0,#0x40           ;1911
0000fc  71a0              STRB     r0,[r4,#6]            ;1911
                  |L27.254|
0000fe  79e1              LDRB     r1,[r4,#7]            ;1914
000100  9800              LDR      r0,[sp,#0]            ;1914
000102  026d              LSLS     r5,r5,#9              ;1915
000104  4408              ADD      r0,r0,r1              ;1914
000106  71e0              STRB     r0,[r4,#7]            ;1914
000108  e02c              B        |L27.356|
                  |L27.266|
00010a  69a1              LDR      r1,[r4,#0x18]         ;1924
00010c  4559              CMP      r1,r11                ;1924
00010e  d012              BEQ      |L27.310|
000110  e9d40102          LDRD     r0,r1,[r4,#8]         ;1924
000114  4288              CMP      r0,r1                 ;1925
000116  d20e              BCS      |L27.310|
000118  6820              LDR      r0,[r4,#0]            ;1926
00011a  2301              MOVS     r3,#1                 ;1926
00011c  465a              MOV      r2,r11                ;1926
00011e  7840              LDRB     r0,[r0,#1]            ;1926
000120  4651              MOV      r1,r10                ;1926
000122  f7fffffe          BL       disk_read
000126  b130              CBZ      r0,|L27.310|
                  |L27.296|
000128  79a0              LDRB     r0,[r4,#6]            ;1927
00012a  f0400080          ORR      r0,r0,#0x80           ;1927
00012e  71a0              STRB     r0,[r4,#6]            ;1927
000130  2001              MOVS     r0,#1                 ;1927
000132  e779              B        |L27.40|
000134  e004              B        |L27.320|
                  |L27.310|
000136  f8c4b018          STR      r11,[r4,#0x18]        ;1931
00013a  79e0              LDRB     r0,[r4,#7]            ;1931
00013c  1c40              ADDS     r0,r0,#1              ;1931
00013e  71e0              STRB     r0,[r4,#7]            ;1931
                  |L27.320|
000140  68a0              LDR      r0,[r4,#8]            ;1933
000142  f3c00008          UBFX     r0,r0,#0,#9           ;1933
000146  f5c07500          RSB      r5,r0,#0x200          ;1933
00014a  42b5              CMP      r5,r6                 ;1934
00014c  d900              BLS      |L27.336|
00014e  4635              MOV      r5,r6                 ;1934
                  |L27.336|
000150  4420              ADD      r0,r0,r4              ;1941
000152  3024              ADDS     r0,r0,#0x24           ;1941
000154  462a              MOV      r2,r5                 ;1941
000156  4639              MOV      r1,r7                 ;1941
000158  f7fffffe          BL       mem_cpy
00015c  79a0              LDRB     r0,[r4,#6]            ;1942
00015e  f0400040          ORR      r0,r0,#0x40           ;1942
000162  71a0              STRB     r0,[r4,#6]            ;1942
                  |L27.356|
000164  68a1              LDR      r1,[r4,#8]            ;1868
000166  442f              ADD      r7,r7,r5              ;1868
000168  4429              ADD      r1,r1,r5              ;1868
00016a  60a1              STR      r1,[r4,#8]            ;1868
00016c  f8d81000          LDR      r1,[r8,#0]            ;1868
000170  1b76              SUBS     r6,r6,r5              ;1868
000172  4429              ADD      r1,r1,r5              ;1868
000174  f8c81000          STR      r1,[r8,#0]            ;1868
                  |L27.376|
000178  2e00              CMP      r6,#0                 ;1867
00017a  f47faf62          BNE      |L27.66|
                  |L27.382|
00017e  e9d40102          LDRD     r0,r1,[r4,#8]         ;1867
000182  4288              CMP      r0,r1                 ;1946
000184  d900              BLS      |L27.392|
000186  60e0              STR      r0,[r4,#0xc]          ;1946
                  |L27.392|
000188  79a0              LDRB     r0,[r4,#6]            ;1947
00018a  f0400020          ORR      r0,r0,#0x20           ;1947
00018e  71a0              STRB     r0,[r4,#6]            ;1947
000190  2000              MOVS     r0,#0                 ;1949
000192  e749              B        |L27.40|
;;;1951   
                          ENDP


                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;1361   static
;;;1362   FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;1363   	DIR *dj,			/* Directory object to return last directory and found object */
;;;1364   	const XCHAR *path	/* Full-path string to find a file or directory */
;;;1365   )
;;;1366   {
000002  4605              MOV      r5,r0
;;;1367   	FRESULT res;
;;;1368   	BYTE *dir, last;
;;;1369   
;;;1370   
;;;1371   #if _FS_RPATH
;;;1372   	if (*path == '/' || *path == '\\') { /* There is a heading separator */
;;;1373   		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
;;;1374   	} else {							/* No heading saparator */
;;;1375   		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
;;;1376   	}
;;;1377   #else
;;;1378   	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
000004  9801              LDR      r0,[sp,#4]
000006  7801              LDRB     r1,[r0,#0]
000008  292f              CMP      r1,#0x2f
00000a  d001              BEQ      |L28.16|
00000c  295c              CMP      r1,#0x5c
00000e  d101              BNE      |L28.20|
                  |L28.16|
;;;1379   		path++;
000010  1c40              ADDS     r0,r0,#1
000012  9001              STR      r0,[sp,#4]
                  |L28.20|
;;;1380   	dj->sclust = 0;						/* Start from the root dir */
000014  2400              MOVS     r4,#0
;;;1381   #endif
;;;1382   
;;;1383   	if ((UINT)*path < ' ') {			/* Null path means the start directory itself */
000016  60ac              STR      r4,[r5,#8]
000018  9801              LDR      r0,[sp,#4]
00001a  7800              LDRB     r0,[r0,#0]
00001c  2820              CMP      r0,#0x20
00001e  d205              BCS      |L28.44|
;;;1384   		res = dir_seek(dj, 0);
000020  2100              MOVS     r1,#0
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       dir_seek
;;;1385   		dj->dir = NULL;
000028  616c              STR      r4,[r5,#0x14]
                  |L28.42|
;;;1386   
;;;1387   	} else {							/* Follow path */
;;;1388   		for (;;) {
;;;1389   			res = create_name(dj, &path);	/* Get a segment */
;;;1390   			if (res != FR_OK) break;
;;;1391   			res = dir_find(dj);				/* Find it */
;;;1392   			last = *(dj->fn+11) & NS_LAST;
;;;1393   			if (res != FR_OK) {				/* Could not find the object */
;;;1394   				if (res == FR_NO_FILE && !last)
;;;1395   					res = FR_NO_PATH;
;;;1396   				break;
;;;1397   			}
;;;1398   			if (last) break;				/* Last segment match. Function completed. */
;;;1399   			dir = dj->dir;					/* There is next segment. Follow the sub directory */
;;;1400   			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
;;;1401   				res = FR_NO_PATH; break;
;;;1402   			}
;;;1403   			dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
;;;1404   		}
;;;1405   	}
;;;1406   
;;;1407   	return res;
;;;1408   }
00002a  bd7c              POP      {r2-r6,pc}
                  |L28.44|
00002c  a901              ADD      r1,sp,#4              ;1389
00002e  4628              MOV      r0,r5                 ;1389
000030  f7fffffe          BL       create_name
000034  2800              CMP      r0,#0                 ;1390
000036  d1f8              BNE      |L28.42|
000038  2100              MOVS     r1,#0                 ;1390
00003a  4628              MOV      r0,r5                 ;1390
00003c  f7fffffe          BL       dir_seek
000040  b9b8              CBNZ     r0,|L28.114|
                  |L28.66|
000042  6929              LDR      r1,[r5,#0x10]         ;1390
000044  6828              LDR      r0,[r5,#0]            ;1390
000046  f7fffffe          BL       move_window
00004a  0004              MOVS     r4,r0                 ;1390
00004c  d110              BNE      |L28.112|
00004e  6968              LDR      r0,[r5,#0x14]         ;1390
000050  7801              LDRB     r1,[r0,#0]            ;1390
000052  b1c9              CBZ      r1,|L28.136|
000054  7ac1              LDRB     r1,[r0,#0xb]          ;1390
000056  0709              LSLS     r1,r1,#28             ;1390
000058  d404              BMI      |L28.100|
00005a  220b              MOVS     r2,#0xb               ;1390
00005c  69a9              LDR      r1,[r5,#0x18]         ;1390
00005e  f7fffffe          BL       mem_cmp
000062  b128              CBZ      r0,|L28.112|
                  |L28.100|
000064  2100              MOVS     r1,#0                 ;1390
000066  4628              MOV      r0,r5                 ;1390
000068  f7fffffe          BL       dir_next
00006c  0004              MOVS     r4,r0                 ;1390
00006e  d0e8              BEQ      |L28.66|
                  |L28.112|
000070  4620              MOV      r0,r4                 ;1390
                  |L28.114|
000072  69a9              LDR      r1,[r5,#0x18]         ;1392
000074  7ac9              LDRB     r1,[r1,#0xb]          ;1392
000076  f0010104          AND      r1,r1,#4              ;1392
00007a  b138              CBZ      r0,|L28.140|
00007c  2804              CMP      r0,#4                 ;1394
00007e  d1d4              BNE      |L28.42|
000080  2900              CMP      r1,#0                 ;1394
000082  d1d2              BNE      |L28.42|
                  |L28.132|
000084  2005              MOVS     r0,#5                 ;1395
                  |L28.134|
000086  bd7c              POP      {r2-r6,pc}
                  |L28.136|
000088  2404              MOVS     r4,#4
00008a  e7f1              B        |L28.112|
                  |L28.140|
00008c  2900              CMP      r1,#0                 ;1398
00008e  d1fa              BNE      |L28.134|
000090  6968              LDR      r0,[r5,#0x14]         ;1400
000092  7ac1              LDRB     r1,[r0,#0xb]          ;1400
000094  06c9              LSLS     r1,r1,#27             ;1400
000096  d5f5              BPL      |L28.132|
000098  8a81              LDRH     r1,[r0,#0x14]         ;1403
00009a  8b40              LDRH     r0,[r0,#0x1a]         ;1403
00009c  f361401f          BFI      r0,r1,#16,#16         ;1403
0000a0  60a8              STR      r0,[r5,#8]            ;1403
0000a2  e7c3              B        |L28.44|
;;;1409   
                          ENDP


                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=1

                  get_fat PROC
;;;308    static
;;;309    DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Interal error, Else:Cluster status */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;310    	FATFS *fs,	/* File system object */
;;;311    	DWORD clst	/* Cluster# to get the link information */
;;;312    )
;;;313    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;314    	UINT wc, bc;
;;;315    	DWORD fsect;
;;;316    
;;;317    
;;;318    	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
000008  2902              CMP      r1,#2
00000a  d302              BCC      |L29.18|
00000c  69e8              LDR      r0,[r5,#0x1c]
00000e  42a0              CMP      r0,r4
000010  d802              BHI      |L29.24|
                  |L29.18|
;;;319    		return 1;
000012  2001              MOVS     r0,#1
                  |L29.20|
;;;320    
;;;321    	fsect = fs->fatbase;
;;;322    	switch (fs->fs_type) {
;;;323    	case FS_FAT12 :
;;;324    		bc = clst; bc += bc / 2;
;;;325    		if (move_window(fs, fsect + (bc / SS(fs)))) break;
;;;326    		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
;;;327    		if (move_window(fs, fsect + (bc / SS(fs)))) break;
;;;328    		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
;;;329    		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
;;;330    
;;;331    	case FS_FAT16 :
;;;332    		if (move_window(fs, fsect + (clst / (SS(fs) / 2)))) break;
;;;333    		return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);
;;;334    
;;;335    	case FS_FAT32 :
;;;336    		if (move_window(fs, fsect + (clst / (SS(fs) / 4)))) break;
;;;337    		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
;;;338    	}
;;;339    
;;;340    	return 0xFFFFFFFF;	/* An error occured at the disk I/O layer */
;;;341    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L29.24|
000018  7828              LDRB     r0,[r5,#0]            ;322
00001a  6a2f              LDR      r7,[r5,#0x20]         ;322
00001c  2801              CMP      r0,#1                 ;322
00001e  d004              BEQ      |L29.42|
000020  2802              CMP      r0,#2                 ;322
000022  d023              BEQ      |L29.108|
000024  2803              CMP      r0,#3                 ;322
000026  d132              BNE      |L29.142|
000028  e02b              B        |L29.130|
                  |L29.42|
00002a  eb040654          ADD      r6,r4,r4,LSR #1       ;324
00002e  eb072156          ADD      r1,r7,r6,LSR #9       ;325
000032  4628              MOV      r0,r5                 ;325
000034  f7fffffe          BL       move_window
000038  bb48              CBNZ     r0,|L29.142|
00003a  f3c60008          UBFX     r0,r6,#0,#9           ;326
00003e  4428              ADD      r0,r0,r5              ;326
000040  1c76              ADDS     r6,r6,#1              ;326
000042  f8908030          LDRB     r8,[r0,#0x30]         ;326
000046  eb072156          ADD      r1,r7,r6,LSR #9       ;327
00004a  4628              MOV      r0,r5                 ;327
00004c  f7fffffe          BL       move_window
000050  b9e8              CBNZ     r0,|L29.142|
000052  f3c60008          UBFX     r0,r6,#0,#9           ;328
000056  4428              ADD      r0,r0,r5              ;328
000058  f8901030          LDRB     r1,[r0,#0x30]         ;328
00005c  ea482101          ORR      r1,r8,r1,LSL #8       ;328
000060  0908              LSRS     r0,r1,#4              ;329
000062  07e2              LSLS     r2,r4,#31             ;329
000064  d1d6              BNE      |L29.20|
000066  f3c1000b          UBFX     r0,r1,#0,#12          ;329
00006a  e7d3              B        |L29.20|
                  |L29.108|
00006c  eb072114          ADD      r1,r7,r4,LSR #8       ;332
000070  4628              MOV      r0,r5                 ;332
000072  f7fffffe          BL       move_window
000076  b950              CBNZ     r0,|L29.142|
000078  0620              LSLS     r0,r4,#24             ;333
00007a  eb0550d0          ADD      r0,r5,r0,LSR #23      ;333
00007e  8e00              LDRH     r0,[r0,#0x30]         ;333
000080  e7c8              B        |L29.20|
                  |L29.130|
000082  eb0711d4          ADD      r1,r7,r4,LSR #7       ;336
000086  4628              MOV      r0,r5                 ;336
000088  f7fffffe          BL       move_window
00008c  b110              CBZ      r0,|L29.148|
                  |L29.142|
00008e  f04f30ff          MOV      r0,#0xffffffff        ;340
000092  e7bf              B        |L29.20|
                  |L29.148|
000094  0660              LSLS     r0,r4,#25
000096  eb0550d0          ADD      r0,r5,r0,LSR #23      ;337
00009a  f8901030          LDRB     r1,[r0,#0x30]         ;337
00009e  f8d00031          LDR      r0,[r0,#0x31]         ;337
0000a2  ea412000          ORR      r0,r1,r0,LSL #8       ;337
0000a6  f0204070          BIC      r0,r0,#0xf0000000     ;337
0000aa  e7b3              B        |L29.20|
;;;342    
                          ENDP


                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;1288   static
;;;1289   void get_fileinfo (		/* No return code */
000000  b570              PUSH     {r4-r6,lr}
;;;1290   	DIR *dj,			/* Pointer to the directory object */
;;;1291   	FILINFO *fno	 	/* Pointer to store the file information */
;;;1292   )
;;;1293   {
;;;1294   	int i;
;;;1295   	BYTE c, nt, *dir;
;;;1296   	char *p;
;;;1297   #if _USE_LFN
;;;1298   	XCHAR *tp;
;;;1299   #endif
;;;1300   
;;;1301   
;;;1302   	p = fno->fname;
;;;1303   	if (dj->sect) {
000002  6903              LDR      r3,[r0,#0x10]
000004  f1010209          ADD      r2,r1,#9              ;1302
000008  b3c3              CBZ      r3,|L30.124|
;;;1304   		dir = dj->dir;
00000a  6940              LDR      r0,[r0,#0x14]
;;;1305   		nt = dir[DIR_NTres];		/* NT flag */
;;;1306   		for (i = 0; i < 8; i++) {	/* Copy name body */
00000c  2400              MOVS     r4,#0
00000e  7b05              LDRB     r5,[r0,#0xc]          ;1305
                  |L30.16|
;;;1307   			c = dir[i];
000010  5d03              LDRB     r3,[r0,r4]
;;;1308   			if (c == ' ') break;
000012  2b20              CMP      r3,#0x20
000014  d00f              BEQ      |L30.54|
;;;1309   			if (c == 0x05) c = 0xE5;
000016  2b05              CMP      r3,#5
000018  d100              BNE      |L30.28|
00001a  23e5              MOVS     r3,#0xe5
                  |L30.28|
;;;1310   			if ((nt & 0x08) && IsUpper(c)) c += 0x20;
00001c  072e              LSLS     r6,r5,#28
00001e  d505              BPL      |L30.44|
000020  f1a30641          SUB      r6,r3,#0x41
000024  2e19              CMP      r6,#0x19
000026  d801              BHI      |L30.44|
000028  3320              ADDS     r3,r3,#0x20
00002a  b2db              UXTB     r3,r3
                  |L30.44|
00002c  1c64              ADDS     r4,r4,#1              ;1306
;;;1311   			*p++ = c;
00002e  f8023b01          STRB     r3,[r2],#1
000032  2c08              CMP      r4,#8                 ;1306
000034  dbec              BLT      |L30.16|
                  |L30.54|
;;;1312   		}
;;;1313   		if (dir[8] != ' ') {		/* Copy name extension */
000036  7a03              LDRB     r3,[r0,#8]
000038  2b20              CMP      r3,#0x20
00003a  d013              BEQ      |L30.100|
;;;1314   			*p++ = '.';
00003c  232e              MOVS     r3,#0x2e
00003e  f8023b01          STRB     r3,[r2],#1
;;;1315   			for (i = 8; i < 11; i++) {
000042  2408              MOVS     r4,#8
                  |L30.68|
;;;1316   				c = dir[i];
000044  5d03              LDRB     r3,[r0,r4]
;;;1317   				if (c == ' ') break;
000046  2b20              CMP      r3,#0x20
000048  d00c              BEQ      |L30.100|
;;;1318   				if ((nt & 0x10) && IsUpper(c)) c += 0x20;
00004a  06ee              LSLS     r6,r5,#27
00004c  d505              BPL      |L30.90|
00004e  f1a30641          SUB      r6,r3,#0x41
000052  2e19              CMP      r6,#0x19
000054  d801              BHI      |L30.90|
000056  3320              ADDS     r3,r3,#0x20
000058  b2db              UXTB     r3,r3
                  |L30.90|
00005a  1c64              ADDS     r4,r4,#1              ;1315
;;;1319   				*p++ = c;
00005c  f8023b01          STRB     r3,[r2],#1
000060  2c0b              CMP      r4,#0xb               ;1315
000062  dbef              BLT      |L30.68|
                  |L30.100|
;;;1320   			}
;;;1321   		}
;;;1322   		fno->fattrib = dir[DIR_Attr];				/* Attribute */
000064  7ac3              LDRB     r3,[r0,#0xb]
000066  720b              STRB     r3,[r1,#8]
;;;1323   		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
000068  7f03              LDRB     r3,[r0,#0x1c]
00006a  f8d0401d          LDR      r4,[r0,#0x1d]
00006e  ea432304          ORR      r3,r3,r4,LSL #8
;;;1324   		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
000072  600b              STR      r3,[r1,#0]
000074  8b03              LDRH     r3,[r0,#0x18]
000076  808b              STRH     r3,[r1,#4]
;;;1325   		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
000078  8ac0              LDRH     r0,[r0,#0x16]
00007a  80c8              STRH     r0,[r1,#6]
                  |L30.124|
;;;1326   	}
;;;1327   	*p = 0;
00007c  2000              MOVS     r0,#0
00007e  7010              STRB     r0,[r2,#0]
;;;1328   
;;;1329   #if _USE_LFN
;;;1330   	tp = fno->lfname;
;;;1331   	if (tp) {
;;;1332   		WCHAR w, *lfn;
;;;1333   
;;;1334   		i = 0;
;;;1335   		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
;;;1336   			lfn = dj->lfn;
;;;1337   			while ((w = *lfn++) != 0) {			/* Get an LFN char */
;;;1338   #if !_LFN_UNICODE
;;;1339   				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
;;;1340   				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
;;;1341   				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC */
;;;1342   					tp[i++] = (XCHAR)(w >> 8);
;;;1343   				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overrun, no LFN */
;;;1344   #endif
;;;1345   				tp[i++] = (XCHAR)w;
;;;1346   			}
;;;1347   		}
;;;1348   		tp[i] = 0;	/* Terminator */
;;;1349   	}
;;;1350   #endif
;;;1351   }
000080  bd70              POP      {r4-r6,pc}
;;;1352   #endif /* _FS_MINIMIZE <= 1 */
                          ENDP


                          AREA ||i.mem_cmp||, CODE, READONLY, ALIGN=1

                  mem_cmp PROC
;;;176    static
;;;177    int mem_cmp (const void* dst, const void* src, int cnt) {
000000  b510              PUSH     {r4,lr}
;;;178    	const char *d = (const char *)dst, *s = (const char *)src;
;;;179    	int r = 0;
000002  2300              MOVS     r3,#0
                  |L31.4|
;;;180    	while (cnt-- && (r = *d++ - *s++) == 0) ;
000004  1e52              SUBS     r2,r2,#1
000006  d305              BCC      |L31.20|
000008  f8103b01          LDRB     r3,[r0],#1
00000c  f8114b01          LDRB     r4,[r1],#1
000010  1b1b              SUBS     r3,r3,r4
000012  d0f7              BEQ      |L31.4|
                  |L31.20|
;;;181    	return r;
000014  4618              MOV      r0,r3
;;;182    }
000016  bd10              POP      {r4,pc}
;;;183    
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=1

                  mem_cpy PROC
;;;161    static
;;;162    void mem_cpy (void* dst, const void* src, int cnt) {
000000  b510              PUSH     {r4,lr}
;;;163    	char *d = (char*)dst;
;;;164    	const char *s = (const char *)src;
;;;165    	while (cnt--) *d++ = *s++;
000002  e004              B        |L32.14|
                  |L32.4|
000004  f8113b01          LDRB     r3,[r1],#1
000008  1c44              ADDS     r4,r0,#1
00000a  7003              STRB     r3,[r0,#0]
00000c  4620              MOV      r0,r4
                  |L32.14|
00000e  1e52              SUBS     r2,r2,#1
000010  d2f8              BCS      |L32.4|
;;;166    }
000012  bd10              POP      {r4,pc}
;;;167    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;169    static
;;;170    void mem_set (void* dst, int val, int cnt) {
000000  b2c9              UXTB     r1,r1
;;;171    	char *d = (char*)dst;
;;;172    	while (cnt--) *d++ = (char)val;
000002  e001              B        |L33.8|
                  |L33.4|
000004  f8001b01          STRB     r1,[r0],#1
                  |L33.8|
000008  1e52              SUBS     r2,r2,#1
00000a  d2fb              BCS      |L33.4|
;;;173    }
00000c  4770              BX       lr
;;;174    
                          ENDP


                          AREA ||i.move_window||, CODE, READONLY, ALIGN=1

                  move_window PROC
;;;228    static
;;;229    FRESULT move_window (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;230    	FATFS *fs,		/* File system object */
;;;231    	DWORD sector	/* Sector number to make apperance in the fs->win[] */
;;;232    )					/* Move to zero only writes back dirty window */
;;;233    {
;;;234    	DWORD wsect;
;;;235    
;;;236    
;;;237    	wsect = fs->winsect;
;;;238    	if (wsect != sector) {	/* Changed current window */
000004  6ac5              LDR      r5,[r0,#0x2c]
000006  4604              MOV      r4,r0                 ;233
000008  460f              MOV      r7,r1                 ;233
00000a  428d              CMP      r5,r1
00000c  d02b              BEQ      |L34.102|
;;;239    #if !_FS_READONLY
;;;240    		if (fs->wflag) {	/* Write back dirty window if needed */
00000e  7921              LDRB     r1,[r4,#4]
;;;241    			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
000010  f1040830          ADD      r8,r4,#0x30
000014  b1d9              CBZ      r1,|L34.78|
000016  7860              LDRB     r0,[r4,#1]
000018  2301              MOVS     r3,#1
00001a  462a              MOV      r2,r5
00001c  4641              MOV      r1,r8
00001e  f7fffffe          BL       disk_write
000022  b9e0              CBNZ     r0,|L34.94|
;;;242    				return FR_DISK_ERR;
;;;243    			fs->wflag = 0;
000024  2000              MOVS     r0,#0
000026  7120              STRB     r0,[r4,#4]
;;;244    			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
000028  69a1              LDR      r1,[r4,#0x18]
00002a  6a20              LDR      r0,[r4,#0x20]
00002c  4408              ADD      r0,r0,r1
00002e  42a8              CMP      r0,r5
000030  d90d              BLS      |L34.78|
;;;245    				BYTE nf;
;;;246    				for (nf = fs->n_fats; nf > 1; nf--) {	/* Refrect the change to all FAT copies */
000032  78e6              LDRB     r6,[r4,#3]
000034  e009              B        |L34.74|
                  |L34.54|
;;;247    					wsect += fs->sects_fat;
000036  69a0              LDR      r0,[r4,#0x18]
;;;248    					disk_write(fs->drive, fs->win, wsect, 1);
000038  2301              MOVS     r3,#1
00003a  4405              ADD      r5,r5,r0              ;247
00003c  7860              LDRB     r0,[r4,#1]
00003e  462a              MOV      r2,r5
000040  4641              MOV      r1,r8
000042  f7fffffe          BL       disk_write
000046  1e76              SUBS     r6,r6,#1              ;246
000048  b2f6              UXTB     r6,r6                 ;246
                  |L34.74|
00004a  2e01              CMP      r6,#1                 ;246
00004c  d8f3              BHI      |L34.54|
                  |L34.78|
;;;249    				}
;;;250    			}
;;;251    		}
;;;252    #endif
;;;253    		if (sector) {
00004e  b157              CBZ      r7,|L34.102|
;;;254    			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
000050  7860              LDRB     r0,[r4,#1]
000052  2301              MOVS     r3,#1
000054  463a              MOV      r2,r7
000056  4641              MOV      r1,r8
000058  f7fffffe          BL       disk_read
00005c  b110              CBZ      r0,|L34.100|
                  |L34.94|
;;;255    				return FR_DISK_ERR;
00005e  2001              MOVS     r0,#1
                  |L34.96|
;;;256    			fs->winsect = sector;
;;;257    		}
;;;258    	}
;;;259    
;;;260    	return FR_OK;
;;;261    }
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L34.100|
000064  62e7              STR      r7,[r4,#0x2c]         ;256
                  |L34.102|
000066  2000              MOVS     r0,#0                 ;260
000068  e7fa              B        |L34.96|
;;;262    
                          ENDP


                          AREA ||i.put_fat||, CODE, READONLY, ALIGN=1

                  put_fat PROC
;;;350    static
;;;351    FRESULT put_fat (
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;352    	FATFS *fs,	/* File system object */
;;;353    	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->max_clust - 1 */
;;;354    	DWORD val	/* New value to mark the cluster */
;;;355    )
;;;356    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;357    	UINT bc;
;;;358    	BYTE *p;
;;;359    	DWORD fsect;
;;;360    	FRESULT res;
;;;361    
;;;362    
;;;363    	if (clst < 2 || clst >= fs->max_clust) {	/* Range check */
00000a  2902              CMP      r1,#2
00000c  d302              BCC      |L35.20|
00000e  69e8              LDR      r0,[r5,#0x1c]
000010  42a0              CMP      r0,r4
000012  d802              BHI      |L35.26|
                  |L35.20|
;;;364    		res = FR_INT_ERR;
000014  2002              MOVS     r0,#2
                  |L35.22|
;;;365    
;;;366    	} else {
;;;367    		fsect = fs->fatbase;
;;;368    		switch (fs->fs_type) {
;;;369    		case FS_FAT12 :
;;;370    			bc = clst; bc += bc / 2;
;;;371    			res = move_window(fs, fsect + (bc / SS(fs)));
;;;372    			if (res != FR_OK) break;
;;;373    			p = &fs->win[bc & (SS(fs) - 1)];
;;;374    			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
;;;375    			bc++;
;;;376    			fs->wflag = 1;
;;;377    			res = move_window(fs, fsect + (bc / SS(fs)));
;;;378    			if (res != FR_OK) break;
;;;379    			p = &fs->win[bc & (SS(fs) - 1)];
;;;380    			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
;;;381    			break;
;;;382    
;;;383    		case FS_FAT16 :
;;;384    			res = move_window(fs, fsect + (clst / (SS(fs) / 2)));
;;;385    			if (res != FR_OK) break;
;;;386    			ST_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)], (WORD)val);
;;;387    			break;
;;;388    
;;;389    		case FS_FAT32 :
;;;390    			res = move_window(fs, fsect + (clst / (SS(fs) / 4)));
;;;391    			if (res != FR_OK) break;
;;;392    			ST_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)], val);
;;;393    			break;
;;;394    
;;;395    		default :
;;;396    			res = FR_INT_ERR;
;;;397    		}
;;;398    		fs->wflag = 1;
;;;399    	}
;;;400    
;;;401    	return res;
;;;402    }
000016  e8bd9ff0          POP      {r4-r12,pc}
                  |L35.26|
00001a  7829              LDRB     r1,[r5,#0]            ;368
00001c  6a2f              LDR      r7,[r5,#0x20]         ;368
00001e  f00608ff          AND      r8,r6,#0xff           ;374
000022  f04f0b01          MOV      r11,#1                ;368
000026  2901              CMP      r1,#1                 ;368
000028  d00b              BEQ      |L35.66|
00002a  fa1ffa86          UXTH     r10,r6                ;386
00002e  ea4f291a          LSR      r9,r10,#8             ;386
000032  2902              CMP      r1,#2                 ;368
000034  d037              BEQ      |L35.166|
000036  2903              CMP      r1,#3                 ;368
000038  d044              BEQ      |L35.196|
00003a  2002              MOVS     r0,#2                 ;396
                  |L35.60|
00003c  f885b004          STRB     r11,[r5,#4]           ;398
000040  e7e9              B        |L35.22|
                  |L35.66|
000042  eb040954          ADD      r9,r4,r4,LSR #1       ;370
000046  eb072159          ADD      r1,r7,r9,LSR #9       ;371
00004a  4628              MOV      r0,r5                 ;371
00004c  f7fffffe          BL       move_window
000050  2800              CMP      r0,#0                 ;372
000052  d1f3              BNE      |L35.60|
000054  f3c90008          UBFX     r0,r9,#0,#9           ;373
000058  1941              ADDS     r1,r0,r5              ;373
00005a  3130              ADDS     r1,r1,#0x30           ;373
00005c  4640              MOV      r0,r8                 ;373
00005e  07e2              LSLS     r2,r4,#31             ;374
000060  d003              BEQ      |L35.106|
000062  4602              MOV      r2,r0                 ;374
000064  7808              LDRB     r0,[r1,#0]            ;374
000066  f362101f          BFI      r0,r2,#4,#28          ;374
                  |L35.106|
00006a  7008              STRB     r0,[r1,#0]            ;374
00006c  f1090801          ADD      r8,r9,#1              ;375
000070  f885b004          STRB     r11,[r5,#4]           ;376
000074  eb072158          ADD      r1,r7,r8,LSR #9       ;377
000078  4628              MOV      r0,r5                 ;377
00007a  f7fffffe          BL       move_window
00007e  2800              CMP      r0,#0                 ;378
000080  d1dc              BNE      |L35.60|
000082  f3c80108          UBFX     r1,r8,#0,#9           ;379
000086  4429              ADD      r1,r1,r5              ;379
000088  3130              ADDS     r1,r1,#0x30           ;379
00008a  07e2              LSLS     r2,r4,#31             ;380
00008c  d002              BEQ      |L35.148|
00008e  f3c61207          UBFX     r2,r6,#4,#8           ;380
000092  e006              B        |L35.162|
                  |L35.148|
000094  780a              LDRB     r2,[r1,#0]            ;380
000096  0a33              LSRS     r3,r6,#8              ;380
000098  f3c30303          UBFX     r3,r3,#0,#4           ;380
00009c  f00202f0          AND      r2,r2,#0xf0           ;380
0000a0  431a              ORRS     r2,r2,r3              ;380
                  |L35.162|
0000a2  700a              STRB     r2,[r1,#0]            ;380
0000a4  e7ca              B        |L35.60|
                  |L35.166|
0000a6  eb072114          ADD      r1,r7,r4,LSR #8       ;384
0000aa  4628              MOV      r0,r5                 ;384
0000ac  f7fffffe          BL       move_window
0000b0  2800              CMP      r0,#0                 ;385
0000b2  d1c3              BNE      |L35.60|
0000b4  0622              LSLS     r2,r4,#24             ;386
0000b6  eb0552d2          ADD      r2,r5,r2,LSR #23      ;386
0000ba  f882a030          STRB     r10,[r2,#0x30]        ;386
0000be  f8829031          STRB     r9,[r2,#0x31]         ;386
0000c2  e7bb              B        |L35.60|
                  |L35.196|
0000c4  eb0711d4          ADD      r1,r7,r4,LSR #7       ;390
0000c8  4628              MOV      r0,r5                 ;390
0000ca  f7fffffe          BL       move_window
0000ce  2800              CMP      r0,#0                 ;391
0000d0  d1b4              BNE      |L35.60|
0000d2  0661              LSLS     r1,r4,#25             ;391
0000d4  eb0551d1          ADD      r1,r5,r1,LSR #23      ;392
0000d8  0c32              LSRS     r2,r6,#16             ;392
0000da  f8018f30          STRB     r8,[r1,#0x30]!        ;392
0000de  f8819001          STRB     r9,[r1,#1]            ;392
0000e2  708a              STRB     r2,[r1,#2]            ;392
0000e4  0e32              LSRS     r2,r6,#24             ;392
0000e6  70ca              STRB     r2,[r1,#3]            ;392
0000e8  e7a8              B        |L35.60|
;;;403    #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.remove_chain||, CODE, READONLY, ALIGN=1

                  remove_chain PROC
;;;412    static
;;;413    FRESULT remove_chain (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;414    	FATFS *fs,			/* File system object */
;;;415    	DWORD clst			/* Cluster# to remove a chain from */
;;;416    )
;;;417    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;418    	FRESULT res;
;;;419    	DWORD nxt;
;;;420    
;;;421    
;;;422    	if (clst < 2 || clst >= fs->max_clust) {	/* Check the range of cluster# */
000008  2902              CMP      r1,#2
00000a  d318              BCC      |L36.62|
00000c  69f8              LDR      r0,[r7,#0x1c]
00000e  42b0              CMP      r0,r6
000010  d915              BLS      |L36.62|
;;;423    		res = FR_INT_ERR;
;;;424    
;;;425    	} else {
;;;426    		res = FR_OK;
000012  2500              MOVS     r5,#0
000014  f04f0801          MOV      r8,#1                 ;419
;;;427    		while (clst < fs->max_clust) {			/* Not a last link? */
;;;428    			nxt = get_fat(fs, clst);			/* Get cluster status */
;;;429    			if (nxt == 0) break;				/* Empty cluster? */
;;;430    			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
;;;431    			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
;;;432    			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
;;;433    			if (res != FR_OK) break;
;;;434    			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
;;;435    				fs->free_clust++;
;;;436    				fs->fsi_flag = 1;
;;;437    			}
;;;438    			clst = nxt;	/* Next cluster */
000018  e01d              B        |L36.86|
                  |L36.26|
00001a  4631              MOV      r1,r6                 ;428
00001c  4638              MOV      r0,r7                 ;428
00001e  f7fffffe          BL       get_fat
000022  0004              MOVS     r4,r0                 ;428
000024  d01a              BEQ      |L36.92|
000026  2c01              CMP      r4,#1                 ;430
000028  d009              BEQ      |L36.62|
00002a  1c60              ADDS     r0,r4,#1              ;431
00002c  d009              BEQ      |L36.66|
00002e  2200              MOVS     r2,#0                 ;432
000030  4631              MOV      r1,r6                 ;432
000032  4638              MOV      r0,r7                 ;432
000034  f7fffffe          BL       put_fat
000038  0005              MOVS     r5,r0                 ;432
00003a  d10f              BNE      |L36.92|
00003c  e003              B        |L36.70|
                  |L36.62|
00003e  2502              MOVS     r5,#2                 ;430
000040  e00c              B        |L36.92|
                  |L36.66|
000042  2501              MOVS     r5,#1                 ;431
000044  e00a              B        |L36.92|
                  |L36.70|
000046  6938              LDR      r0,[r7,#0x10]         ;434
000048  1c41              ADDS     r1,r0,#1              ;434
00004a  d003              BEQ      |L36.84|
00004c  1c40              ADDS     r0,r0,#1              ;435
00004e  6138              STR      r0,[r7,#0x10]         ;436
000050  f887800a          STRB     r8,[r7,#0xa]          ;436
                  |L36.84|
000054  4626              MOV      r6,r4
                  |L36.86|
000056  69f8              LDR      r0,[r7,#0x1c]         ;427
000058  42b0              CMP      r0,r6                 ;427
00005a  d8de              BHI      |L36.26|
                  |L36.92|
;;;439    		}
;;;440    	}
;;;441    
;;;442    	return res;
00005c  4628              MOV      r0,r5
;;;443    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;444    #endif
                          ENDP


                          AREA ||i.sync||, CODE, READONLY, ALIGN=1

                  sync PROC
;;;270    static
;;;271    FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;272    	FATFS *fs	/* File system object */
;;;273    )
;;;274    {
000004  4604              MOV      r4,r0
;;;275    	FRESULT res;
;;;276    
;;;277    
;;;278    	res = move_window(fs, 0);
000006  2100              MOVS     r1,#0
000008  f7fffffe          BL       move_window
00000c  0005              MOVS     r5,r0
;;;279    	if (res == FR_OK) {
00000e  d150              BNE      |L37.178|
;;;280    		/* Update FSInfo sector if needed */
;;;281    		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
000010  7820              LDRB     r0,[r4,#0]
000012  2803              CMP      r0,#3
000014  d146              BNE      |L37.164|
000016  7aa0              LDRB     r0,[r4,#0xa]
000018  b3f0              CBZ      r0,|L37.152|
;;;282    			fs->winsect = 0;
00001a  2600              MOVS     r6,#0
;;;283    			mem_set(fs->win, 0, 512);
00001c  f1040030          ADD      r0,r4,#0x30
000020  f44f7200          MOV      r2,#0x200
000024  4631              MOV      r1,r6
000026  4607              MOV      r7,r0
000028  62e6              STR      r6,[r4,#0x2c]
00002a  f7fffffe          BL       mem_set
;;;284    			ST_WORD(fs->win+BS_55AA, 0xAA55);
00002e  2055              MOVS     r0,#0x55
000030  f884022e          STRB     r0,[r4,#0x22e]
000034  20aa              MOVS     r0,#0xaa
000036  f884022f          STRB     r0,[r4,#0x22f]
;;;285    			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
00003a  2052              MOVS     r0,#0x52
00003c  f8840030          STRB     r0,[r4,#0x30]
000040  f8840031          STRB     r0,[r4,#0x31]
000044  2061              MOVS     r0,#0x61
000046  f8840032          STRB     r0,[r4,#0x32]
00004a  2141              MOVS     r1,#0x41
00004c  f8841033          STRB     r1,[r4,#0x33]
;;;286    			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
000050  2272              MOVS     r2,#0x72
000052  f8842214          STRB     r2,[r4,#0x214]
000056  f8842215          STRB     r2,[r4,#0x215]
00005a  f8841216          STRB     r1,[r4,#0x216]
00005e  f8840217          STRB     r0,[r4,#0x217]
;;;287    			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
000062  6920              LDR      r0,[r4,#0x10]
000064  f8840218          STRB     r0,[r4,#0x218]
000068  0a01              LSRS     r1,r0,#8
00006a  f8841219          STRB     r1,[r4,#0x219]
00006e  0c01              LSRS     r1,r0,#16
000070  f884121a          STRB     r1,[r4,#0x21a]
000074  0e00              LSRS     r0,r0,#24
000076  f884021b          STRB     r0,[r4,#0x21b]
;;;288    			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
00007a  68e0              LDR      r0,[r4,#0xc]
00007c  f884021c          STRB     r0,[r4,#0x21c]
000080  0a01              LSRS     r1,r0,#8
000082  f884121d          STRB     r1,[r4,#0x21d]
000086  0c01              LSRS     r1,r0,#16
000088  0e00              LSRS     r0,r0,#24
00008a  f884121e          STRB     r1,[r4,#0x21e]
00008e  f884021f          STRB     r0,[r4,#0x21f]
;;;289    			disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
000092  7860              LDRB     r0,[r4,#1]
000094  2301              MOVS     r3,#1
000096  e000              B        |L37.154|
                  |L37.152|
000098  e004              B        |L37.164|
                  |L37.154|
00009a  4639              MOV      r1,r7
00009c  6962              LDR      r2,[r4,#0x14]
00009e  f7fffffe          BL       disk_write
;;;290    			fs->fsi_flag = 0;
0000a2  72a6              STRB     r6,[r4,#0xa]
                  |L37.164|
;;;291    		}
;;;292    		/* Make sure that no pending write process in the physical drive */
;;;293    		if (disk_ioctl(fs->drive, CTRL_SYNC, (void*)NULL) != RES_OK)
0000a4  2200              MOVS     r2,#0
0000a6  7860              LDRB     r0,[r4,#1]
0000a8  4611              MOV      r1,r2
0000aa  f7fffffe          BL       disk_ioctl
0000ae  b100              CBZ      r0,|L37.178|
;;;294    			res = FR_DISK_ERR;
0000b0  2501              MOVS     r5,#1
                  |L37.178|
;;;295    	}
;;;296    
;;;297    	return res;
0000b2  4628              MOV      r0,r5
;;;298    }
0000b4  e8bd81f0          POP      {r4-r8,pc}
;;;299    #endif
                          ENDP


                          AREA ||i.validate||, CODE, READONLY, ALIGN=1

                  validate PROC
;;;1582   static
;;;1583   FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
000000  b510              PUSH     {r4,lr}
;;;1584   	FATFS *fs,		/* Pointer to the file system object */
;;;1585   	WORD id			/* Member id of the target object to be checked */
;;;1586   )
;;;1587   {
;;;1588   	if (!fs || !fs->fs_type || fs->id != id)
000002  b120              CBZ      r0,|L38.14|
000004  7802              LDRB     r2,[r0,#0]
000006  b112              CBZ      r2,|L38.14|
000008  88c2              LDRH     r2,[r0,#6]
00000a  428a              CMP      r2,r1
00000c  d001              BEQ      |L38.18|
                  |L38.14|
;;;1589   		return FR_INVALID_OBJECT;
00000e  2009              MOVS     r0,#9
                  |L38.16|
;;;1590   
;;;1591   	ENTER_FF(fs);		/* Lock file system */
;;;1592   
;;;1593   	if (disk_status(fs->drive) & STA_NOINIT)
;;;1594   		return FR_NOT_READY;
;;;1595   
;;;1596   	return FR_OK;
;;;1597   }
000010  bd10              POP      {r4,pc}
                  |L38.18|
000012  7840              LDRB     r0,[r0,#1]            ;1593
000014  f7fffffe          BL       disk_status
000018  07c0              LSLS     r0,r0,#31             ;1593
00001a  d0f9              BEQ      |L38.16|
00001c  2003              MOVS     r0,#3                 ;1594
00001e  bd10              POP      {r4,pc}
;;;1598   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  fatstr
000000  46415400          DCB      0x46,0x41,0x54,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  Fsid
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  FatFs
                          DCD      0x00000000
