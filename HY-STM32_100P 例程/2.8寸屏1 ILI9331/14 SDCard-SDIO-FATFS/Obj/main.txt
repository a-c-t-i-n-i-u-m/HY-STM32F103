; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\main.o --depend=.\Obj\main.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\FWlib\inc -I.\user -I.\fatfs -I.\fatfs -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\Obj\main.crf user\main.c]
                          THUMB

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=1

                  Delay PROC
;;;94     
;;;95     void Delay(__IO uint32_t nCount)
000000  e000              B        |L1.4|
                  |L1.2|
;;;96     {
;;;97       for(; nCount != 0; nCount--);
000002  1e40              SUBS     r0,r0,#1
                  |L1.4|
000004  2800              CMP      r0,#0
000006  d1fc              BNE      |L1.2|
;;;98     }
000008  4770              BX       lr
;;;99     
                          ENDP


                          AREA ||i.GetKey||, CODE, READONLY, ALIGN=2

                  GetKey PROC
;;;376    
;;;377    int GetKey (void)  {                    /* Read character from Serial Port    */
000000  4804              LDR      r0,|L2.20|
;;;378    
;;;379      while (!(USART1->SR & USART_FLAG_RXNE));
000002  bf00              NOP      
                  |L2.4|
000004  f8b01800          LDRH     r1,[r0,#0x800]
000008  0689              LSLS     r1,r1,#26
00000a  d5fb              BPL      |L2.4|
;;;380      return (USART_ReceiveData(USART1));
00000c  4802              LDR      r0,|L2.24|
00000e  f7ffbffe          B.W      USART_ReceiveData
;;;381    }
;;;382    
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40013000
                  |L2.24|
                          DCD      0x40013800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;353    *******************************************************************************/
;;;354    void NVIC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;355    {
;;;356      NVIC_InitTypeDef NVIC_InitStructure;
;;;357    
;;;358      /* Configure the NVIC Preemption Priority Bits */
;;;359      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
000002  f44f60c0          MOV      r0,#0x600
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;360    
;;;361      NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQn;
00000a  2031              MOVS     r0,#0x31
00000c  f88d0000          STRB     r0,[sp,#0]
;;;362      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000010  2000              MOVS     r0,#0
000012  f88d0001          STRB     r0,[sp,#1]
;;;363      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  f88d0002          STRB     r0,[sp,#2]
;;;364      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001a  2001              MOVS     r0,#1
00001c  f88d0003          STRB     r0,[sp,#3]
;;;365      NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;366    }
000026  bd08              POP      {r3,pc}
;;;367    
                          ENDP


                          AREA ||i.OutPutFile||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  OutPutFile PROC
;;;141     
;;;142    void OutPutFile(void)
000000  b09a              SUB      sp,sp,#0x68
;;;143    { unsigned int a;
;;;144      FRESULT res;
;;;145      FILINFO finfo;
;;;146      DIR dirs;
;;;147    //  int i;
;;;148    //  char *fn;
;;;149      char path[50]={""};  
000002  2134              MOVS     r1,#0x34
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       __aeabi_memclr4
;;;150    //  char name[]={"WVO.TXT"};
;;;151        
;;;152      printf("\n  file system(Tini-FatFa0.07C) starting! \n");
00000a  a026              ADR      r0,|L4.164|
00000c  f7fffffe          BL       __2printf
;;;153      
;;;154      disk_initialize(0);
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       disk_initialize
;;;155        
;;;156      f_mount(0, &fs);
000016  492e              LDR      r1,|L4.208|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       f_mount
;;;157    
;;;158     if (f_opendir(&dirs, path) == FR_OK) 
00001e  4669              MOV      r1,sp
000020  a813              ADD      r0,sp,#0x4c
000022  f7fffffe          BL       f_opendir
;;;159      {
;;;160        while (f_readdir(&dirs, &finfo) == FR_OK)  
;;;161        {
;;;162          if (finfo.fattrib & AM_ARC) 
;;;163          {
;;;164            if(!finfo.fname[0])	
;;;165              break;         
;;;166            printf("\r\n file name is:\n   %s\n",finfo.fname);
;;;167            res = f_open(&fsrc, finfo.fname, FA_OPEN_EXISTING | FA_READ);
;;;168    		//res = f_open(&fdst, "a3.rar", FA_CREATE_ALWAYS | FA_WRITE);
;;;169            br=1;
000026  f8df80ac          LDR      r8,|L4.212|
;;;170    		a=0;
;;;171    		for (;;) {
;;;172    			for(a=0; a<512; a++) buffer[a]=0; 
00002a  f44f7400          MOV      r4,#0x200
00002e  b388              CBZ      r0,|L4.148|
000030  e036              B        |L4.160|
000032  bf00              NOP                            ;162
                  |L4.52|
000034  f89d003c          LDRB     r0,[sp,#0x3c]         ;162
000038  0680              LSLS     r0,r0,#26             ;162
00003a  d52b              BPL      |L4.148|
00003c  f89d003d          LDRB     r0,[sp,#0x3d]         ;164
000040  b370              CBZ      r0,|L4.160|
000042  f10d013d          ADD      r1,sp,#0x3d           ;166
000046  460d              MOV      r5,r1                 ;166
000048  a023              ADR      r0,|L4.216|
00004a  f7fffffe          BL       __2printf
00004e  2201              MOVS     r2,#1                 ;167
000050  4629              MOV      r1,r5                 ;167
000052  4827              LDR      r0,|L4.240|
000054  f7fffffe          BL       f_open
000058  2101              MOVS     r1,#1                 ;169
00005a  4e26              LDR      r6,|L4.244|
00005c  2500              MOVS     r5,#0                 ;154
00005e  f8c81004          STR      r1,[r8,#4]  ; br
                  |L4.98|
000062  2000              MOVS     r0,#0
000064  4622              MOV      r2,r4
                  |L4.102|
000066  5435              STRB     r5,[r6,r0]
000068  1c40              ADDS     r0,r0,#1
00006a  4290              CMP      r0,r2
00006c  d3fb              BCC      |L4.102|
;;;173        	    res = f_read(&fsrc, buffer, sizeof(buffer), &br);
00006e  4b19              LDR      r3,|L4.212|
000070  4920              LDR      r1,|L4.244|
000072  1d1b              ADDS     r3,r3,#4
000074  481e              LDR      r0,|L4.240|
000076  f7fffffe          BL       f_read
00007a  4607              MOV      r7,r0
;;;174    			printf("%s\n",buffer);	
00007c  491d              LDR      r1,|L4.244|
00007e  a01b              ADR      r0,|L4.236|
000080  f7fffffe          BL       __2printf
;;;175    			//printp("\r\n@@@@@res=%2d  br=%6d  bw=%6d",res,br,bw);
;;;176        	    if (res || br == 0) break;   // error or eof
000084  b91f              CBNZ     r7,|L4.142|
000086  f8d80004          LDR      r0,[r8,#4]  ; br
00008a  2800              CMP      r0,#0
00008c  d1e9              BNE      |L4.98|
                  |L4.142|
;;;177           	    //res = f_write(&fdst, buffer, br, &bw);
;;;178    		    //printp("\r\n$$$$$res=%2d  br=%6d  bw=%6d",res,br,bw);
;;;179                //if (res || bw < br) break;   // error or disk full	
;;;180            }
;;;181    		f_close(&fsrc);
00008e  4818              LDR      r0,|L4.240|
000090  f7fffffe          BL       f_close
                  |L4.148|
000094  a90d              ADD      r1,sp,#0x34           ;160
000096  a813              ADD      r0,sp,#0x4c           ;160
000098  f7fffffe          BL       f_readdir
00009c  2800              CMP      r0,#0                 ;160
00009e  d0c9              BEQ      |L4.52|
                  |L4.160|
;;;182        	//f_close(&fdst);	
;;;183    	    //printf("\r\n asdasdasdasdasdasdas");	
;;;184    		//break;	                      
;;;185          }
;;;186        } 
;;;187        
;;;188      }
;;;189      
;;;190      while(1);
0000a0  e7fe              B        |L4.160|
;;;191    }
;;;192    /*******************************************************************************
                          ENDP

0000a2  0000              DCW      0x0000
                  |L4.164|
0000a4  0a202066          DCB      "\n  file system(Tini-FatFa0.07C) starting! \n",0
0000a8  696c6520
0000ac  73797374
0000b0  656d2854
0000b4  696e692d
0000b8  46617446
0000bc  61302e30
0000c0  37432920
0000c4  73746172
0000c8  74696e67
0000cc  21200a00
                  |L4.208|
                          DCD      ||area_number.14||+0x50
                  |L4.212|
                          DCD      ||area_number.29||
                  |L4.216|
0000d8  0d0a2066          DCB      "\r\n file name is:\n   "
0000dc  696c6520
0000e0  6e616d65
0000e4  2069733a
0000e8  0a202020
                  |L4.236|
0000ec  25730a00          DCB      "%s\n",0
                  |L4.240|
                          DCD      ||area_number.14||+0x280
                  |L4.244|
                          DCD      ||area_number.14||+0x4a4

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;99     
;;;100    void RCC_Configuration(void)
000000  f7ffbffe          B.W      SystemInit
;;;101    {
;;;102      /* Setup the microcontroller system. Initialize the Embedded Flash Interface,
;;;103         initialize the PLL and update the SystemFrequency variable. */
;;;104      SystemInit();
;;;105    }
;;;106    
                          ENDP


                          AREA ||i.SendChar||, CODE, READONLY, ALIGN=2

                  SendChar PROC
;;;368    /* Implementation of putchar (also used by printf function to output data)    */
;;;369    int SendChar (int ch)  {                /* Write character to Serial Port     */
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;370    
;;;371      USART_SendData(USART1, (unsigned char) ch);
000004  b2c1              UXTB     r1,r0
000006  4805              LDR      r0,|L6.28|
000008  f7fffffe          BL       USART_SendData
;;;372      while (!(USART1->SR & USART_FLAG_TXE));
00000c  4804              LDR      r0,|L6.32|
00000e  bf00              NOP      
                  |L6.16|
000010  f8b01800          LDRH     r1,[r0,#0x800]
000014  0609              LSLS     r1,r1,#24
000016  d5fb              BPL      |L6.16|
;;;373      return (ch);
000018  4620              MOV      r0,r4
;;;374    }
00001a  bd10              POP      {r4,pc}
;;;375    
                          ENDP

                  |L6.28|
                          DCD      0x40013800
                  |L6.32|
                          DCD      0x40013000

                          AREA ||i.Serial_Init||, CODE, READONLY, ALIGN=2

                  Serial_Init PROC
;;;262     *************************************************************************/
;;;263    void Serial_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;264    {
000002  b086              SUB      sp,sp,#0x18
;;;265      GPIO_InitTypeDef GPIO_InitStructure;
;;;266      USART_InitTypeDef USART_InitStructure;
;;;267     
;;;268      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);
000004  2101              MOVS     r1,#1
000006  f2440004          MOV      r0,#0x4004
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;269      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
00000e  2100              MOVS     r1,#0
000010  f44f4080          MOV      r0,#0x4000
000014  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;270    
;;;271      /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;272      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000018  f44f7000          MOV      r0,#0x200
00001c  f8ad0000          STRH     r0,[sp,#0]
;;;273      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000020  2003              MOVS     r0,#3
000022  f88d0002          STRB     r0,[sp,#2]
;;;274      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000026  2018              MOVS     r0,#0x18
;;;275      GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  4c34              LDR      r4,|L7.252|
00002a  f88d0003          STRB     r0,[sp,#3]            ;274
00002e  4669              MOV      r1,sp
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       GPIO_Init
;;;276    
;;;277      /* Configure USART1 Rx (PA.10) as input floating */
;;;278      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000036  1520              ASRS     r0,r4,#20
000038  f8ad0000          STRH     r0,[sp,#0]
;;;279      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003c  2004              MOVS     r0,#4
00003e  f88d0003          STRB     r0,[sp,#3]
;;;280      GPIO_Init(GPIOA, &GPIO_InitStructure);
000042  4669              MOV      r1,sp
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       GPIO_Init
;;;281    
;;;282      
;;;283      //VS1003 PE12, PE13, PE14   CS,SI,CLK
;;;284      
;;;285      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14;
00004a  f44f40e0          MOV      r0,#0x7000
;;;286      
;;;287      GPIO_Init(GPIOE, &GPIO_InitStructure);
00004e  4d2c              LDR      r5,|L7.256|
000050  f8ad0000          STRH     r0,[sp,#0]            ;285
000054  4669              MOV      r1,sp
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       GPIO_Init
;;;288    
;;;289      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_13;    //PD13 VS1003 RST   
00005c  1460              ASRS     r0,r4,#17
00005e  f8ad0000          STRH     r0,[sp,#0]
;;;290      GPIO_Init(GPIOD, &GPIO_InitStructure);
000062  4669              MOV      r1,sp
000064  4827              LDR      r0,|L7.260|
000066  f7fffffe          BL       GPIO_Init
;;;291      
;;;292      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_6;    //PC6 VS1003 XDCS   
00006a  2040              MOVS     r0,#0x40
;;;293      GPIO_Init(GPIOC, &GPIO_InitStructure);
00006c  4e26              LDR      r6,|L7.264|
00006e  f8ad0000          STRH     r0,[sp,#0]            ;292
000072  4669              MOV      r1,sp
000074  4630              MOV      r0,r6
000076  f7fffffe          BL       GPIO_Init
;;;294    
;;;295      	
;;;296      //PENIRQ, SO	
;;;297      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11;
00007a  14e4              ASRS     r4,r4,#19
00007c  f8ad4000          STRH     r4,[sp,#0]
;;;298      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
000080  2028              MOVS     r0,#0x28
000082  f88d0003          STRB     r0,[sp,#3]
;;;299      //GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
;;;300      GPIO_Init(GPIOB, &GPIO_InitStructure);
000086  4669              MOV      r1,sp
000088  4820              LDR      r0,|L7.268|
00008a  f7fffffe          BL       GPIO_Init
;;;301    
;;;302      
;;;303      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11;	 //VS1003 DOUT
00008e  f8ad4000          STRH     r4,[sp,#0]
;;;304      GPIO_Init(GPIOE, &GPIO_InitStructure);
000092  4669              MOV      r1,sp
000094  4628              MOV      r0,r5
000096  f7fffffe          BL       GPIO_Init
;;;305    
;;;306      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;	 //VS1003 DREQ
00009a  2080              MOVS     r0,#0x80
00009c  f8ad0000          STRH     r0,[sp,#0]
;;;307      GPIO_Init(GPIOC, &GPIO_InitStructure);
0000a0  4669              MOV      r1,sp
0000a2  4630              MOV      r0,r6
0000a4  f7fffffe          BL       GPIO_Init
;;;308    
;;;309      //GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11;
;;;310      //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;311      //GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;312      
;;;313    
;;;314      GPIO_SetBits(GPIOC, GPIO_Pin_7);			//vs1003 DREQ
0000a8  2180              MOVS     r1,#0x80
0000aa  4630              MOV      r0,r6
0000ac  f7fffffe          BL       GPIO_SetBits
;;;315      
;;;316    
;;;317    
;;;318    
;;;319    
;;;320    /* USART1 configuration ------------------------------------------------------*/
;;;321      // USART1 configured as follow:
;;;322      USART_InitStructure.USART_BaudRate = 115200;
0000b0  f44f30e1          MOV      r0,#0x1c200
;;;323      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000b4  9001              STR      r0,[sp,#4]
0000b6  2000              MOVS     r0,#0
0000b8  f8ad0008          STRH     r0,[sp,#8]
;;;324      USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000bc  f8ad000a          STRH     r0,[sp,#0xa]
;;;325      USART_InitStructure.USART_Parity = USART_Parity_No;
0000c0  f8ad000c          STRH     r0,[sp,#0xc]
;;;326      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0000c4  f8ad0010          STRH     r0,[sp,#0x10]
;;;327      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0000c8  200c              MOVS     r0,#0xc
;;;328    
;;;329      /* Configure the USART1 */
;;;330      USART_Init(USART1, &USART_InitStructure);
0000ca  4c11              LDR      r4,|L7.272|
0000cc  f8ad000e          STRH     r0,[sp,#0xe]          ;327
0000d0  a901              ADD      r1,sp,#4
0000d2  4620              MOV      r0,r4
0000d4  f7fffffe          BL       USART_Init
;;;331    
;;;332      /* Enable the USART Transmoit interrupt: this interrupt is generated when the 
;;;333         USART1 transmit data register is empty */  
;;;334      USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
0000d8  2201              MOVS     r2,#1
0000da  f2407127          MOV      r1,#0x727
0000de  4620              MOV      r0,r4
0000e0  f7fffffe          BL       USART_ITConfig
;;;335    
;;;336      /* Enable the USART Receive interrupt: this interrupt is generated when the 
;;;337         USART1 receive data register is not empty */
;;;338      USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
0000e4  2201              MOVS     r2,#1
0000e6  f2405125          MOV      r1,#0x525
0000ea  4620              MOV      r0,r4
0000ec  f7fffffe          BL       USART_ITConfig
;;;339    
;;;340      /* Enable USART1 */
;;;341      USART_Cmd(USART1, ENABLE);
0000f0  2101              MOVS     r1,#1
0000f2  4620              MOV      r0,r4
0000f4  f7fffffe          BL       USART_Cmd
;;;342      
;;;343    }
0000f8  b006              ADD      sp,sp,#0x18
0000fa  bd70              POP      {r4-r6,pc}
;;;344    
                          ENDP

                  |L7.252|
                          DCD      0x40010800
                  |L7.256|
                          DCD      0x40011800
                  |L7.260|
                          DCD      0x40011400
                  |L7.264|
                          DCD      0x40011000
                  |L7.268|
                          DCD      0x40010c00
                  |L7.272|
                          DCD      0x40013800

                          AREA ||i.USART_Scanf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  USART_Scanf PROC
;;;413    *******************************************************************************/
;;;414    u8 USART_Scanf(u32 value)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;415    {
;;;416      u32 index = 0;
000004  2400              MOVS     r4,#0
;;;417      u32 tmp[2] = {0, 0};
;;;418    
;;;419      while (index < 2)
;;;420      {
;;;421        /* Loop until RXNE = 1 */
;;;422        while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
000006  4f18              LDR      r7,|L8.104|
000008  4605              MOV      r5,r0                 ;415
00000a  9400              STR      r4,[sp,#0]            ;417
00000c  466e              MOV      r6,sp                 ;417
00000e  9401              STR      r4,[sp,#4]
                  |L8.16|
000010  2120              MOVS     r1,#0x20
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L8.16|
;;;423        {}
;;;424        tmp[index++] = (USART_ReceiveData(USART1));
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       USART_ReceiveData
000022  f8460024          STR      r0,[r6,r4,LSL #2]
000026  1c64              ADDS     r4,r4,#1
;;;425        if ((tmp[index - 1] < 0x30) || (tmp[index - 1] > 0x39))
000028  eb060084          ADD      r0,r6,r4,LSL #2
00002c  f8500c04          LDR      r0,[r0,#-4]
000030  3830              SUBS     r0,r0,#0x30
000032  280a              CMP      r0,#0xa
000034  d303              BCC      |L8.62|
;;;426        {
;;;427          printf("\n\rPlease enter valid number between 0 and 9");
000036  a00d              ADR      r0,|L8.108|
000038  f7fffffe          BL       __2printf
;;;428          index--;
00003c  1e64              SUBS     r4,r4,#1
                  |L8.62|
00003e  2c02              CMP      r4,#2                 ;419
000040  d3e6              BCC      |L8.16|
000042  e9dd1000          LDRD     r1,r0,[sp,#0]         ;419
;;;429        }
;;;430      }
;;;431      /* Calculate the Corresponding value */
;;;432      index = (tmp[1] - 0x30) + ((tmp[0] - 0x30) * 10);
000046  4a14              LDR      r2,|L8.152|
000048  eb010181          ADD      r1,r1,r1,LSL #2
00004c  eb020141          ADD      r1,r2,r1,LSL #1
000050  4408              ADD      r0,r0,r1
;;;433      /* Checks */
;;;434      if (index > value)
000052  42a8              CMP      r0,r5
000054  d906              BLS      |L8.100|
;;;435      {
;;;436        printf("\n\rPlease enter valid number between 0 and %d", value);
000056  4629              MOV      r1,r5
000058  a010              ADR      r0,|L8.156|
00005a  f7fffffe          BL       __2printf
;;;437        return 0xFF;
00005e  20ff              MOVS     r0,#0xff
                  |L8.96|
;;;438      }
;;;439      return index;
;;;440    }
000060  e8bd81fc          POP      {r2-r8,pc}
                  |L8.100|
000064  b2c0              UXTB     r0,r0                 ;439
000066  e7fb              B        |L8.96|
;;;441    
                          ENDP

                  |L8.104|
                          DCD      0x40013800
                  |L8.108|
00006c  0a0d506c          DCB      "\n\rPlease enter valid number between 0 and 9",0
000070  65617365
000074  20656e74
000078  65722076
00007c  616c6964
000080  206e756d
000084  62657220
000088  62657477
00008c  65656e20
000090  3020616e
000094  64203900
                  |L8.152|
                          DCD      0xfffffdf0
                  |L8.156|
00009c  0a0d506c          DCB      "\n\rPlease enter valid number between 0 and %d",0
0000a0  65617365
0000a4  20656e74
0000a8  65722076
0000ac  616c6964
0000b0  206e756d
0000b4  62657220
0000b8  62657477
0000bc  65656e20
0000c0  3020616e
0000c4  64202564
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;391    *******************************************************************************/
;;;392    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;393    {
;;;394      /* Place your implementation of fputc here */
;;;395      /* e.g. write a character to the USART */
;;;396      USART_SendData(USART1, (u8) ch);
000002  4d07              LDR      r5,|L9.32|
000004  4604              MOV      r4,r0                 ;393
000006  b2c1              UXTB     r1,r0
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       USART_SendData
                  |L9.14|
;;;397    
;;;398      /* Loop until the end of transmission */
;;;399      while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
00000e  2140              MOVS     r1,#0x40
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       USART_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L9.14|
;;;400      {
;;;401      }
;;;402    
;;;403      return ch;
00001a  4620              MOV      r0,r4
;;;404    }
00001c  bd70              POP      {r4-r6,pc}
;;;405    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x40013800

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;198    *******************************************************************************/
;;;199    int main(void)
000000  f7fffffe          BL       SystemInit
;;;200    {
;;;201    #ifdef DEBUG
;;;202      debug();
;;;203    #endif
;;;204      
;;;205     
;;;206      
;;;207      // Clock Config: HSE 72 MHz
;;;208      RCC_Configuration();
;;;209      
;;;210      // Interrupt Config
;;;211      NVIC_Configuration();
000004  f7fffffe          BL       NVIC_Configuration
;;;212      
;;;213      // USART Config : 115200,8,n,1
;;;214      Serial_Init();
000008  f7fffffe          BL       Serial_Init
;;;215      
;;;216      /////////////////////////////////////////////////////////////////////
;;;217      //////// SDCARD Initialisation //////////////////////////////////////
;;;218      /////////////////Section adapted from ST example/////////////////////
;;;219      
;;;220      /*-------------------------- SD Init ----------------------------- */
;;;221      Status = SD_Init();
00000c  f7fffffe          BL       SD_Init
000010  4c0d              LDR      r4,|L10.72|
;;;222    
;;;223      if (Status == SD_OK)
000012  282a              CMP      r0,#0x2a
000014  7020              STRB     r0,[r4,#0]            ;221
000016  d115              BNE      |L10.68|
;;;224      {
;;;225        /*----------------- Read CSD/CID MSD registers ------------------*/
;;;226        Status = SD_GetCardInfo(&SDCardInfo);
000018  480c              LDR      r0,|L10.76|
00001a  f7fffffe          BL       SD_GetCardInfo
00001e  7020              STRB     r0,[r4,#0]
;;;227      }
;;;228      
;;;229      if (Status == SD_OK)
000020  282a              CMP      r0,#0x2a
000022  d10f              BNE      |L10.68|
;;;230      {
;;;231        /*----------------- Select Card --------------------------------*/
;;;232        Status = SD_SelectDeselect((u32) (SDCardInfo.RCA << 16));
000024  4809              LDR      r0,|L10.76|
000026  f8b0004c          LDRH     r0,[r0,#0x4c]  ; SDCardInfo
00002a  0400              LSLS     r0,r0,#16
00002c  f7fffffe          BL       SD_SelectDeselect
000030  7020              STRB     r0,[r4,#0]
;;;233      }
;;;234      
;;;235      if (Status == SD_OK)
;;;236      {
;;;237        //Status = SD_EnableWideBusOperation(SDIO_BusWide_4b);
;;;238      }
;;;239      
;;;240      /* Set Device Transfer Mode to DMA */
;;;241      if (Status == SD_OK)
000032  282a              CMP      r0,#0x2a
000034  d106              BNE      |L10.68|
;;;242      {  
;;;243    //    Status = SD_SetDeviceMode(SD_DMA_MODE);//oet
;;;244     //   Status = SD_SetDeviceMode(SD_POLLING_MODE);
;;;245        Status = SD_SetDeviceMode(SD_INTERRUPT_MODE);
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       SD_SetDeviceMode
00003c  7020              STRB     r0,[r4,#0]
;;;246    	printf("\nTEST OK!\n");
00003e  a004              ADR      r0,|L10.80|
000040  f7fffffe          BL       __2printf
                  |L10.68|
;;;247      }
;;;248      
;;;249      
;;;250      OutPutFile();
000044  f7fffffe          BL       OutPutFile
;;;251    
;;;252            
;;;253      printf("\nLet's loop for infinity, and beyond!\n");
;;;254      while (1)
;;;255      {}
;;;256    }
;;;257    
                          ENDP

                  |L10.72|
                          DCD      ||area_number.29||
                  |L10.76|
                          DCD      ||area_number.14||
                  |L10.80|
000050  0a544553          DCB      "\nTEST OK!\n",0
000054  54204f4b
000058  210a00  
00005b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USART_InitStructure
                          %        16

                          AREA ||area_number.13||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.13||, ||.bss||
                  RxBuffer1
                          %        44

                          AREA ||area_number.14||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.bss||
                  SDCardInfo
                          %        80
                  ||fs||
                          %        560
                  fsrc
                          %        548
                  buffer
                          %        512

                          AREA ||area_number.15||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.bss||
                  Buffer_Block_Tx
                          %        512

                          AREA ||area_number.16||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.bss||
                  Buffer_Block_Rx
                          %        512

                          AREA ||area_number.17||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.bss||
                  Buffer_MultiBlock_Tx
                          %        1024

                          AREA ||area_number.18||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.bss||
                  Buffer_MultiBlock_Rx
                          %        1024

                          AREA ||area_number.19||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.bss||
                  fdst
                          %        548

                          AREA ||.data||, DATA, ALIGN=0

                  TxBuffer1
000000  55534152          DCB      0x55,0x53,0x41,0x52
000004  5420496e          DCB      0x54,0x20,0x49,0x6e
000008  74657272          DCB      0x74,0x65,0x72,0x72
00000c  75707420          DCB      0x75,0x70,0x74,0x20
000010  4578616d          DCB      0x45,0x78,0x61,0x6d
000014  706c653a          DCB      0x70,0x6c,0x65,0x3a
000018  20546869          DCB      0x20,0x54,0x68,0x69
00001c  73206973          DCB      0x73,0x20,0x69,0x73
000020  20555341          DCB      0x20,0x55,0x53,0x41
000024  52543120          DCB      0x52,0x54,0x31,0x20
000028  44454d4f          DCB      0x44,0x45,0x4d,0x4f
00002c  00                DCB      0x00

                          AREA ||area_number.22||, DATA, ALIGN=0

                          EXPORTAS ||area_number.22||, ||.data||
                  TxCounter1
000000  00                DCB      0x00

                          AREA ||area_number.23||, DATA, ALIGN=0

                          EXPORTAS ||area_number.23||, ||.data||
                  RxCounter1
000000  00                DCB      0x00

                          AREA ||area_number.24||, DATA, ALIGN=0

                          EXPORTAS ||area_number.24||, ||.data||
                  NbrOfDataToTransfer1
000000  2c                DCB      0x2c

                          AREA ||area_number.25||, DATA, ALIGN=0

                          EXPORTAS ||area_number.25||, ||.data||
                  NbrOfDataToRead1
000000  2c                DCB      0x2c

                          AREA ||area_number.26||, DATA, ALIGN=0

                          EXPORTAS ||area_number.26||, ||.data||
                  EraseStatus
000000  00                DCB      0x00

                          AREA ||area_number.27||, DATA, ALIGN=0

                          EXPORTAS ||area_number.27||, ||.data||
                  TransferStatus1
000000  00                DCB      0x00

                          AREA ||area_number.28||, DATA, ALIGN=0

                          EXPORTAS ||area_number.28||, ||.data||
                  TransferStatus2
000000  00                DCB      0x00

                          AREA ||area_number.29||, DATA, ALIGN=2

                          EXPORTAS ||area_number.29||, ||.data||
                  Status
000000  2a000000          DCB      0x2a,0x00,0x00,0x00
                  ||br||
                          DCD      0x00000000

                          AREA ||area_number.30||, DATA, ALIGN=0

                          EXPORTAS ||area_number.30||, ||.data||
                  rec_f
000000  00                DCB      0x00

                          AREA ||area_number.31||, DATA, ALIGN=0

                          EXPORTAS ||area_number.31||, ||.data||
                  ||res||
000000  00                DCB      0x00

                          AREA ||area_number.32||, DATA, ALIGN=2

                          EXPORTAS ||area_number.32||, ||.data||
                  ||bw||
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
