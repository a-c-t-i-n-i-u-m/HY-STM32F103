; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\diskio.o --depend=.\Obj\diskio.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\FWlib\inc -I.\user -I.\fatfs -I.\fatfs -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\Obj\diskio.crf fatfs\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;22     
;;;23     DSTATUS disk_initialize (
000000  2000              MOVS     r0,#0
;;;24     	BYTE drv				/* Physical drive nmuber (0..) */
;;;25     )
;;;26     {
;;;27     	return 0;
;;;28     }
000002  4770              BX       lr
;;;29     
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=1

                  disk_ioctl PROC
;;;103    
;;;104    DRESULT disk_ioctl (
000000  2000              MOVS     r0,#0
;;;105    	BYTE drv,		/* Physical drive nmuber (0..) */
;;;106    	BYTE ctrl,		/* Control code */
;;;107    	void *buff		/* Buffer to send/receive control data */
;;;108    )
;;;109    {
;;;110    
;;;111    	return RES_OK;
;;;112    }
000002  4770              BX       lr
;;;113    
                          ENDP


                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;46     
;;;47     DRESULT disk_read (
000000  b510              PUSH     {r4,lr}
;;;48     	BYTE drv,		/* Physical drive nmuber (0..) */
;;;49     	BYTE *buff,		/* Data buffer to store read data */
;;;50     	DWORD sector,	/* Sector address (LBA) */
;;;51     	BYTE count		/* Number of sectors to read (1..255) */
;;;52     )
;;;53     {
;;;54       //memset(buff2, 0, sizeof(buff2));
;;;55     	if(count==1)
;;;56             {
;;;57               SD_ReadBlock(sector << 9 ,(u32 *)(&buff[0]),SECTOR_SIZE);
000002  0250              LSLS     r0,r2,#9
000004  f44f7400          MOV      r4,#0x200
000008  2b01              CMP      r3,#1                 ;55
;;;58               //memcpy(buff,buff2,SECTOR_SIZE);
;;;59     	}
;;;60     	else
;;;61             {
;;;62               SD_ReadMultiBlocks(sector << 9 ,(u32 *)(&buff[0]),SECTOR_SIZE,count);
00000a  4622              MOV      r2,r4
00000c  d003              BEQ      |L3.22|
00000e  f7fffffe          BL       SD_ReadMultiBlocks
                  |L3.18|
;;;63               //memcpy(buff,buff2,SECTOR_SIZE * count);
;;;64     	}
;;;65     
;;;66     
;;;67     	return RES_OK;
000012  2000              MOVS     r0,#0
;;;68     }
000014  bd10              POP      {r4,pc}
                  |L3.22|
000016  f7fffffe          BL       SD_ReadBlock
00001a  e7fa              B        |L3.18|
;;;69     
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;34     
;;;35     DSTATUS disk_status (
000000  2000              MOVS     r0,#0
;;;36     	BYTE drv		/* Physical drive nmuber (0..) */
;;;37     )
;;;38     {	
;;;39     	return 0;
;;;40     }
000002  4770              BX       lr
;;;41     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;75     #if _READONLY == 0
;;;76     DRESULT disk_write (
000000  b510              PUSH     {r4,lr}
;;;77     	BYTE drv,			/* Physical drive nmuber (0..) */
;;;78     	const BYTE *buff,	/* Data to be written */
;;;79     	DWORD sector,		/* Sector address (LBA) */
;;;80     	BYTE count			/* Number of sectors to write (1..255) */
;;;81     )
;;;82     {
;;;83       //memset(buff2, 0, sizeof(buff2));
;;;84     	if(count==1)
;;;85             {
;;;86               //memcpy(buff2,buff,SECTOR_SIZE);
;;;87               SD_WriteBlock(sector << 9 ,(u32 *)(&buff[0]),SECTOR_SIZE);
000002  0250              LSLS     r0,r2,#9
000004  f44f7400          MOV      r4,#0x200
000008  2b01              CMP      r3,#1                 ;84
;;;88     	}
;;;89     	else
;;;90             {
;;;91               //memcpy(buff2,buff,SECTOR_SIZE * count);
;;;92               SD_WriteMultiBlocks(sector << 9 ,(u32 *)(&buff[0]),SECTOR_SIZE,count);
00000a  4622              MOV      r2,r4
00000c  d003              BEQ      |L5.22|
00000e  f7fffffe          BL       SD_WriteMultiBlocks
                  |L5.18|
;;;93     	}
;;;94             
;;;95       return RES_OK;
000012  2000              MOVS     r0,#0
;;;96     }
000014  bd10              POP      {r4,pc}
                  |L5.22|
000016  f7fffffe          BL       SD_WriteBlock
00001a  e7fa              B        |L5.18|
;;;97     #endif /* _READONLY */
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;113    
;;;114    DWORD get_fattime(void){
000000  2000              MOVS     r0,#0
;;;115    	return 0;
;;;116    }
000002  4770              BX       lr
;;;117    
                          ENDP

